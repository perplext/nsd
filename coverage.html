
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>graph: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/user/netmon/pkg/graph/graph.go (3.9%)</option>
				
				<option value="file1">github.com/user/netmon/pkg/netcap/capture.go (14.9%)</option>
				
				<option value="file2">github.com/user/netmon/pkg/protocols/analyzer.go (15.9%)</option>
				
				<option value="file3">github.com/user/netmon/pkg/protocols/ftp_analyzer.go (0.5%)</option>
				
				<option value="file4">github.com/user/netmon/pkg/protocols/imap_analyzer.go (0.3%)</option>
				
				<option value="file5">github.com/user/netmon/pkg/protocols/irc_analyzer.go (0.0%)</option>
				
				<option value="file6">github.com/user/netmon/pkg/protocols/pop3_analyzer.go (0.4%)</option>
				
				<option value="file7">github.com/user/netmon/pkg/protocols/scp_analyzer.go (0.0%)</option>
				
				<option value="file8">github.com/user/netmon/pkg/protocols/smtp_analyzer.go (0.0%)</option>
				
				<option value="file9">github.com/user/netmon/pkg/protocols/ssh_analyzer.go (0.5%)</option>
				
				<option value="file10">github.com/user/netmon/pkg/security/network_attacks.go (0.4%)</option>
				
				<option value="file11">github.com/user/netmon/pkg/security/sigma_engine.go (13.4%)</option>
				
				<option value="file12">github.com/user/netmon/pkg/security/snort_engine.go (25.2%)</option>
				
				<option value="file13">github.com/user/netmon/pkg/security/suricata_engine.go (18.9%)</option>
				
				<option value="file14">github.com/user/netmon/pkg/security/yara_engine.go (2.7%)</option>
				
				<option value="file15">github.com/user/netmon/pkg/security/zeek_engine.go (4.2%)</option>
				
				<option value="file16">github.com/user/netmon/pkg/ui/borderanimation.go (0.0%)</option>
				
				<option value="file17">github.com/user/netmon/pkg/ui/borderstyle.go (25.0%)</option>
				
				<option value="file18">github.com/user/netmon/pkg/ui/custombox.go (2.2%)</option>
				
				<option value="file19">github.com/user/netmon/pkg/ui/dashboard_builder.go (0.0%)</option>
				
				<option value="file20">github.com/user/netmon/pkg/ui/export.go (0.0%)</option>
				
				<option value="file21">github.com/user/netmon/pkg/ui/styledgrid.go (15.6%)</option>
				
				<option value="file22">github.com/user/netmon/pkg/ui/theme.go (53.9%)</option>
				
				<option value="file23">github.com/user/netmon/pkg/ui/tui.go (10.5%)</option>
				
				<option value="file24">github.com/user/netmon/pkg/ui/visualization.go (22.6%)</option>
				
				<option value="file25">github.com/user/netmon/pkg/ui/viz_conn_lifetime.go (0.0%)</option>
				
				<option value="file26">github.com/user/netmon/pkg/ui/viz_constellation.go (0.0%)</option>
				
				<option value="file27">github.com/user/netmon/pkg/ui/viz_dns_timeline.go (0.0%)</option>
				
				<option value="file28">github.com/user/netmon/pkg/ui/viz_heartbeat.go (0.0%)</option>
				
				<option value="file29">github.com/user/netmon/pkg/ui/viz_heatmap.go (0.0%)</option>
				
				<option value="file30">github.com/user/netmon/pkg/ui/viz_matrix.go (0.0%)</option>
				
				<option value="file31">github.com/user/netmon/pkg/ui/viz_packet_dist.go (0.0%)</option>
				
				<option value="file32">github.com/user/netmon/pkg/ui/viz_radial.go (0.0%)</option>
				
				<option value="file33">github.com/user/netmon/pkg/ui/viz_sankey.go (0.0%)</option>
				
				<option value="file34">github.com/user/netmon/pkg/ui/viz_speedometer.go (0.0%)</option>
				
				<option value="file35">github.com/user/netmon/pkg/ui/viz_sunburst.go (0.0%)</option>
				
				<option value="file36">github.com/user/netmon/pkg/ui/viz_weather.go (0.0%)</option>
				
				<option value="file37">github.com/user/netmon/pkg/ui/worldmap.go (0.0%)</option>
				
				<option value="file38">github.com/user/netmon/pkg/utils/format.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package graph

import (
        "fmt"
        "sync"
        "time"

        "github.com/gdamore/tcell/v2"
        "github.com/rivo/tview"
)

// DataPoint represents a single data point in the graph
type DataPoint struct {
        Value     float64
        Timestamp time.Time
}

// GraphStyle represents the rendering style of the graph
type GraphStyle int

const (
        // StyleBraille uses Unicode Braille patterns for smooth graphs
        StyleBraille GraphStyle = iota
        // StyleBlock uses block characters for traditional graphs
        StyleBlock
        // StyleTTY uses ASCII characters for compatibility
        StyleTTY
)

// Graph represents a time-series graph
type Graph struct {
        *tview.Box
        title         string
        data          []DataPoint
        maxPoints     int
        maxValue      float64
        autoScale     bool
        color         tcell.Color
        secondaryData []DataPoint
        secondaryColor tcell.Color
        mutex         sync.RWMutex
        unit          string
        lastUpdate    time.Time
        showLegend    bool
        primaryLabel  string
        secondaryLabel string
        gradientEnabled bool // static gradient shading enabled
        style          GraphStyle
        gradientColors []tcell.Color // pre-calculated gradient colors
}

// NewGraph creates a new graph
func NewGraph() *Graph <span class="cov0" title="0">{
        g := &amp;Graph{
                Box:            tview.NewBox(),
                maxPoints:      120,
                data:           make([]DataPoint, 0, 120),
                secondaryData:  make([]DataPoint, 0, 120),
                autoScale:      true,
                color:          tcell.ColorGreen,
                secondaryColor: tcell.ColorBlue,
                unit:           "B/s",
                showLegend:     true,
                primaryLabel:   "In",
                secondaryLabel: "Out",
                gradientEnabled: true, // default on
                style:          StyleBraille, // default to Braille style
        }
        
        // Pre-calculate gradient colors
        g.calculateGradientColors()
        
        // Add some initial data points to make the graph visible immediately
        now := time.Now()
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                g.data = append(g.data, DataPoint{
                        Value:     float64(i * 10),
                        Timestamp: now.Add(time.Duration(-i) * time.Second),
                })
                g.secondaryData = append(g.secondaryData, DataPoint{
                        Value:     float64((10-i) * 5),
                        Timestamp: now.Add(time.Duration(-i) * time.Second),
                })
        }</span>
        
        // Set a reasonable default max value
        <span class="cov0" title="0">g.maxValue = 100
        
        return g</span>
}

// SetStyle sets the graph rendering style
func (g *Graph) SetStyle(style GraphStyle) *Graph <span class="cov0" title="0">{
        g.style = style
        return g
}</span>

// calculateGradientColors pre-calculates gradient colors for performance
func (g *Graph) calculateGradientColors() <span class="cov0" title="0">{
        steps := 20
        g.gradientColors = make([]tcell.Color, steps)
        
        pr, pg, pb := g.color.RGB()
        sr, sg, sb := g.secondaryColor.RGB()
        
        for i := 0; i &lt; steps; i++ </span><span class="cov0" title="0">{
                ratio := float64(i) / float64(steps-1)
                r := int32(float64(pr)*(1-ratio) + float64(sr)*ratio)
                gr := int32(float64(pg)*(1-ratio) + float64(sg)*ratio)
                b := int32(float64(pb)*(1-ratio) + float64(sb)*ratio)
                g.gradientColors[i] = tcell.NewRGBColor(r, gr, b)
        }</span>
}

// getBrailleChar returns the appropriate Braille character for the given heights
// heights is an array of 2x4 values (0-3) representing the dots in a Braille cell
func getBrailleChar(heights [8]int) rune <span class="cov0" title="0">{
        // Braille Unicode block starts at 0x2800
        // Each dot position has a specific bit value:
        // 1 4
        // 2 5
        // 3 6
        // 7 8
        bitmap := 0
        dotValues := []int{0x01, 0x02, 0x04, 0x40, 0x08, 0x10, 0x20, 0x80}
        
        for i, height := range heights </span><span class="cov0" title="0">{
                if height &gt; 0 </span><span class="cov0" title="0">{
                        bitmap |= dotValues[i]
                }</span>
        }
        
        <span class="cov0" title="0">return rune(0x2800 + bitmap)</span>
}

// SetTitle sets the graph title
func (g *Graph) SetTitle(title string) *Graph <span class="cov0" title="0">{
        g.title = title
        return g
}</span>

// SetColor sets the primary graph color
func (g *Graph) SetColor(color tcell.Color) *Graph <span class="cov0" title="0">{
        g.color = color
        g.calculateGradientColors() // recalculate gradients
        return g
}</span>

// SetSecondaryColor sets the secondary graph color
func (g *Graph) SetSecondaryColor(color tcell.Color) *Graph <span class="cov0" title="0">{
        g.secondaryColor = color
        g.calculateGradientColors() // recalculate gradients
        return g
}</span>

// SetMaxValue sets the maximum value for the y-axis
func (g *Graph) SetMaxValue(max float64) *Graph <span class="cov0" title="0">{
        g.maxValue = max
        g.autoScale = false
        return g
}</span>

// SetAutoScale enables or disables auto-scaling
func (g *Graph) SetAutoScale(auto bool) *Graph <span class="cov0" title="0">{
        g.autoScale = auto
        return g
}</span>

// SetUnit sets the unit for the y-axis
func (g *Graph) SetUnit(unit string) *Graph <span class="cov0" title="0">{
        g.unit = unit
        return g
}</span>

// SetLabels sets the labels for the primary and secondary data
func (g *Graph) SetLabels(primary, secondary string) *Graph <span class="cov0" title="0">{
        g.primaryLabel = primary
        g.secondaryLabel = secondary
        return g
}</span>

// ShowLegend enables or disables the legend
func (g *Graph) ShowLegend(show bool) *Graph <span class="cov0" title="0">{
        g.showLegend = show
        return g
}</span>

// SetGradientEnabled toggles static gradient shading for the graph
func (g *Graph) SetGradientEnabled(enabled bool) *Graph <span class="cov0" title="0">{
        g.gradientEnabled = enabled
        return g
}</span>

// GradientEnabled reports whether static gradient shading is enabled
func (g *Graph) GradientEnabled() bool <span class="cov0" title="0">{
        return g.gradientEnabled
}</span>

// AddPoint adds a data point to the graph
func (g *Graph) AddPoint(value float64) <span class="cov0" title="0">{
        g.mutex.Lock()
        defer g.mutex.Unlock()

        now := time.Now()
        g.data = append(g.data, DataPoint{Value: value, Timestamp: now})
        if len(g.data) &gt; g.maxPoints </span><span class="cov0" title="0">{
                g.data = g.data[1:]
        }</span>

        <span class="cov0" title="0">g.lastUpdate = now
        g.updateMaxValue()</span>
}

// AddDualPoint adds a primary and secondary data point to the graph
func (g *Graph) AddDualPoint(primary, secondary float64) <span class="cov0" title="0">{
        g.mutex.Lock()
        defer g.mutex.Unlock()

        now := time.Now()
        
        // Add primary data point
        g.data = append(g.data, DataPoint{Value: primary, Timestamp: now})
        if len(g.data) &gt; g.maxPoints </span><span class="cov0" title="0">{
                g.data = g.data[1:]
        }</span>

        // Add secondary data point
        <span class="cov0" title="0">g.secondaryData = append(g.secondaryData, DataPoint{Value: secondary, Timestamp: now})
        if len(g.secondaryData) &gt; g.maxPoints </span><span class="cov0" title="0">{
                g.secondaryData = g.secondaryData[1:]
        }</span>

        <span class="cov0" title="0">g.lastUpdate = now
        g.updateMaxValue()</span>
}

// updateMaxValue updates the maximum value if auto-scaling is enabled
func (g *Graph) updateMaxValue() <span class="cov0" title="0">{
        if !g.autoScale </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">maxVal := 0.0
        for _, point := range g.data </span><span class="cov0" title="0">{
                if point.Value &gt; maxVal </span><span class="cov0" title="0">{
                        maxVal = point.Value
                }</span>
        }

        <span class="cov0" title="0">for _, point := range g.secondaryData </span><span class="cov0" title="0">{
                if point.Value &gt; maxVal </span><span class="cov0" title="0">{
                        maxVal = point.Value
                }</span>
        }

        // Add a 10% buffer
        <span class="cov0" title="0">g.maxValue = maxVal * 1.1

        // If the max value is very small, set a minimum
        if g.maxValue &lt; 10 </span><span class="cov0" title="0">{
                g.maxValue = 10
        }</span>
}

// shadeBlock returns a shading glyph for a ratio [0..1]
func shadeBlock(ratio float64) rune <span class="cov10" title="10">{
        switch </span>{
        case ratio &lt; 0.1:<span class="cov3" title="2">
                return '·'</span>
        case ratio &lt; 0.3:<span class="cov3" title="2">
                return '░'</span>
        case ratio &lt; 0.6:<span class="cov3" title="2">
                return '▒'</span>
        case ratio &lt; 0.9:<span class="cov3" title="2">
                return '▓'</span>
        default:<span class="cov3" title="2">
                return '█'</span>
        }
}

// ShadeBlock returns a shading rune for a ratio [0..1], wrapping internal shadeBlock.
func ShadeBlock(ratio float64) rune <span class="cov10" title="10">{
        return shadeBlock(ratio)
}</span>

// Draw draws the graph
func (g *Graph) Draw(screen tcell.Screen) <span class="cov0" title="0">{
        // Draw the box
        g.Box.DrawForSubclass(screen, g)

        g.mutex.RLock()
        defer g.mutex.RUnlock()

        // Get the graph area
        x, y, width, height := g.GetInnerRect()
        if width &lt;= 10 || height &lt;= 3 </span><span class="cov0" title="0">{
                return
        }</span>

        // Draw title
        <span class="cov0" title="0">if g.title != "" </span><span class="cov0" title="0">{
                tview.Print(screen, g.title, x, y, width, tview.AlignCenter, g.color)
                y++
                height--
        }</span>

        // Reserve space for legend
        <span class="cov0" title="0">if g.showLegend </span><span class="cov0" title="0">{
                height--
        }</span>

        // Calculate graph dimensions
        <span class="cov0" title="0">labelWidth := len(formatValue(g.maxValue) + g.unit) + 1
        graphX := x + labelWidth
        graphWidth := width - labelWidth - 1
        graphHeight := height - 1

        if graphWidth &lt; 2 || graphHeight &lt; 2 </span><span class="cov0" title="0">{
                return
        }</span>

        // Draw y-axis labels
        // Top label
        <span class="cov0" title="0">maxLabel := formatValue(g.maxValue) + g.unit
        tview.Print(screen, maxLabel, x, y, labelWidth-1, tview.AlignRight, tcell.ColorGray)
        
        // Middle label
        if graphHeight &gt; 4 </span><span class="cov0" title="0">{
                midLabel := formatValue(g.maxValue/2) + g.unit
                tview.Print(screen, midLabel, x, y+graphHeight/2, labelWidth-1, tview.AlignRight, tcell.ColorGray)
        }</span>
        
        // Bottom label
        <span class="cov0" title="0">tview.Print(screen, "0"+g.unit, x, y+graphHeight-1, labelWidth-1, tview.AlignRight, tcell.ColorGray)

        // Draw axis lines
        axisStyle := tcell.StyleDefault.Foreground(tcell.ColorGray)
        // Vertical axis
        for i := 0; i &lt; graphHeight; i++ </span><span class="cov0" title="0">{
                screen.SetContent(graphX-1, y+i, '│', nil, axisStyle)
        }</span>
        // Horizontal axis
        <span class="cov0" title="0">screen.SetContent(graphX-1, y+graphHeight, '└', nil, axisStyle)
        for i := 0; i &lt; graphWidth; i++ </span><span class="cov0" title="0">{
                screen.SetContent(graphX+i, y+graphHeight, '─', nil, axisStyle)
        }</span>

        // Choose rendering method based on style
        <span class="cov0" title="0">switch g.style </span>{
        case StyleBraille:<span class="cov0" title="0">
                g.drawBrailleGraph(screen, graphX, y, graphWidth, graphHeight)</span>
        case StyleBlock:<span class="cov0" title="0">
                g.drawBlockGraph(screen, graphX, y, graphWidth, graphHeight)</span>
        case StyleTTY:<span class="cov0" title="0">
                g.drawTTYGraph(screen, graphX, y, graphWidth, graphHeight)</span>
        }

        // Draw legend
        <span class="cov0" title="0">if g.showLegend </span><span class="cov0" title="0">{
                legendY := y + graphHeight + 1
                legendText := fmt.Sprintf("[%s]█ %s[white]  [%s]█ %s", 
                        ColorToHex(g.color), g.primaryLabel,
                        ColorToHex(g.secondaryColor), g.secondaryLabel)
                tview.Print(screen, legendText, x, legendY, width, tview.AlignCenter, tcell.ColorWhite)
        }</span>
}

// drawBrailleGraph draws the graph using Braille Unicode characters
func (g *Graph) drawBrailleGraph(screen tcell.Screen, x, y, width, height int) <span class="cov0" title="0">{
        if len(g.data) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Each Braille character represents a 2x4 grid
        <span class="cov0" title="0">brailleWidth := width
        brailleHeight := height * 4

        // Create value buffers
        primaryValues := make([]float64, brailleWidth*2)
        secondaryValues := make([]float64, brailleWidth*2)

        // Sample data points
        for i := 0; i &lt; brailleWidth*2; i++ </span><span class="cov0" title="0">{
                idx := int(float64(i) / float64(brailleWidth*2-1) * float64(len(g.data)-1))
                if idx &gt;= len(g.data) </span><span class="cov0" title="0">{
                        idx = len(g.data) - 1
                }</span>
                <span class="cov0" title="0">primaryValues[i] = g.data[idx].Value
                
                if len(g.secondaryData) &gt; 0 </span><span class="cov0" title="0">{
                        idx2 := int(float64(i) / float64(brailleWidth*2-1) * float64(len(g.secondaryData)-1))
                        if idx2 &gt;= len(g.secondaryData) </span><span class="cov0" title="0">{
                                idx2 = len(g.secondaryData) - 1
                        }</span>
                        <span class="cov0" title="0">secondaryValues[i] = g.secondaryData[idx2].Value</span>
                }
        }

        // Draw Braille characters
        <span class="cov0" title="0">for col := 0; col &lt; brailleWidth; col++ </span><span class="cov0" title="0">{
                for row := 0; row &lt; height; row++ </span><span class="cov0" title="0">{
                        cellY := y + row
                        cellX := x + col

                        // Calculate heights for this Braille cell
                        heights := [8]int{0, 0, 0, 0, 0, 0, 0, 0}
                        
                        // Process two columns of data for this character
                        for subCol := 0; subCol &lt; 2; subCol++ </span><span class="cov0" title="0">{
                                dataIdx := col*2 + subCol
                                if dataIdx &gt;= len(primaryValues) </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // Primary data
                                <span class="cov0" title="0">primaryHeight := int((primaryValues[dataIdx] / g.maxValue) * float64(brailleHeight))
                                if primaryHeight &lt; 0 </span><span class="cov0" title="0">{
                                        primaryHeight = 0
                                }</span>
                                <span class="cov0" title="0">if primaryHeight &gt; brailleHeight </span><span class="cov0" title="0">{
                                        primaryHeight = brailleHeight
                                }</span>

                                // Secondary data
                                <span class="cov0" title="0">secondaryHeight := 0
                                if len(g.secondaryData) &gt; 0 &amp;&amp; dataIdx &lt; len(secondaryValues) </span><span class="cov0" title="0">{
                                        secondaryHeight = int((secondaryValues[dataIdx] / g.maxValue) * float64(brailleHeight))
                                        if secondaryHeight &lt; 0 </span><span class="cov0" title="0">{
                                                secondaryHeight = 0
                                        }</span>
                                        <span class="cov0" title="0">if secondaryHeight &gt; brailleHeight </span><span class="cov0" title="0">{
                                                secondaryHeight = brailleHeight
                                        }</span>
                                }

                                // Fill in the Braille dots for this column
                                <span class="cov0" title="0">cellStartHeight := (height - row - 1) * 4
                                for dot := 0; dot &lt; 4; dot++ </span><span class="cov0" title="0">{
                                        dotHeight := cellStartHeight + dot
                                        dotIdx := subCol*4 + (3-dot)
                                        
                                        if dotHeight &lt; primaryHeight || dotHeight &lt; secondaryHeight </span><span class="cov0" title="0">{
                                                heights[dotIdx] = 1
                                        }</span>
                                }
                        }

                        // Get the Braille character
                        <span class="cov0" title="0">ch := getBrailleChar(heights)
                        
                        // Determine color with gradient
                        if ch != 0x2800 </span><span class="cov0" title="0">{ // Not empty
                                cellHeightRatio := float64(height-row-1) / float64(height-1)
                                var color tcell.Color
                                
                                if g.gradientEnabled &amp;&amp; len(g.gradientColors) &gt; 0 </span><span class="cov0" title="0">{
                                        gradIdx := int(cellHeightRatio * float64(len(g.gradientColors)-1))
                                        if gradIdx &gt;= len(g.gradientColors) </span><span class="cov0" title="0">{
                                                gradIdx = len(g.gradientColors) - 1
                                        }</span>
                                        <span class="cov0" title="0">color = g.gradientColors[gradIdx]</span>
                                } else<span class="cov0" title="0"> {
                                        // Simple color based on which data is higher at this position
                                        avgPrimary := (primaryValues[col*2] + primaryValues[min(col*2+1, len(primaryValues)-1)]) / 2
                                        avgSecondary := float64(0)
                                        if len(secondaryValues) &gt; 0 </span><span class="cov0" title="0">{
                                                avgSecondary = (secondaryValues[col*2] + secondaryValues[min(col*2+1, len(secondaryValues)-1)]) / 2
                                        }</span>
                                        
                                        <span class="cov0" title="0">if avgPrimary &gt;= avgSecondary </span><span class="cov0" title="0">{
                                                color = g.color
                                        }</span> else<span class="cov0" title="0"> {
                                                color = g.secondaryColor
                                        }</span>
                                }
                                
                                <span class="cov0" title="0">screen.SetContent(cellX, cellY, ch, nil, tcell.StyleDefault.Foreground(color))</span>
                        }
                }
        }
}

// drawBlockGraph draws the graph using block characters
func (g *Graph) drawBlockGraph(screen tcell.Screen, x, y, width, height int) <span class="cov0" title="0">{
        if len(g.data) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // blocks := []rune{' ', '▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'}

        <span class="cov0" title="0">for col := 0; col &lt; width; col++ </span><span class="cov0" title="0">{
                // Sample data
                idx := int(float64(col) / float64(width-1) * float64(len(g.data)-1))
                if idx &gt;= len(g.data) </span><span class="cov0" title="0">{
                        idx = len(g.data) - 1
                }</span>
                <span class="cov0" title="0">primaryValue := g.data[idx].Value
                
                secondaryValue := float64(0)
                if len(g.secondaryData) &gt; 0 </span><span class="cov0" title="0">{
                        idx2 := int(float64(col) / float64(width-1) * float64(len(g.secondaryData)-1))
                        if idx2 &gt;= len(g.secondaryData) </span><span class="cov0" title="0">{
                                idx2 = len(g.secondaryData) - 1
                        }</span>
                        <span class="cov0" title="0">secondaryValue = g.secondaryData[idx2].Value</span>
                }

                // Scale values
                <span class="cov0" title="0">primaryHeight := int((primaryValue / g.maxValue) * float64(height))
                secondaryHeight := int((secondaryValue / g.maxValue) * float64(height))

                // Draw column
                for row := 0; row &lt; height; row++ </span><span class="cov0" title="0">{
                        cellY := y + height - row - 1
                        cellHeight := row

                        var ch rune
                        var color tcell.Color

                        if cellHeight &lt; primaryHeight &amp;&amp; cellHeight &lt; secondaryHeight </span><span class="cov0" title="0">{
                                // Both data points at this height
                                ch = '█'
                                if g.gradientEnabled &amp;&amp; len(g.gradientColors) &gt; 0 </span><span class="cov0" title="0">{
                                        gradIdx := int(float64(row) / float64(height-1) * float64(len(g.gradientColors)-1))
                                        color = g.gradientColors[gradIdx]
                                }</span> else<span class="cov0" title="0"> {
                                        color = g.color
                                }</span>
                        } else<span class="cov0" title="0"> if cellHeight &lt; primaryHeight </span><span class="cov0" title="0">{
                                // Only primary
                                ch = '█'
                                color = g.color
                        }</span> else<span class="cov0" title="0"> if cellHeight &lt; secondaryHeight </span><span class="cov0" title="0">{
                                // Only secondary
                                ch = '█'
                                color = g.secondaryColor
                        }</span> else<span class="cov0" title="0"> {
                                continue</span>
                        }

                        <span class="cov0" title="0">screen.SetContent(x+col, cellY, ch, nil, tcell.StyleDefault.Foreground(color))</span>
                }
        }
}

// drawTTYGraph draws the graph using ASCII characters
func (g *Graph) drawTTYGraph(screen tcell.Screen, x, y, width, height int) <span class="cov0" title="0">{
        if len(g.data) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for col := 0; col &lt; width; col++ </span><span class="cov0" title="0">{
                // Sample data
                idx := int(float64(col) / float64(width-1) * float64(len(g.data)-1))
                if idx &gt;= len(g.data) </span><span class="cov0" title="0">{
                        idx = len(g.data) - 1
                }</span>
                <span class="cov0" title="0">value := g.data[idx].Value
                
                // Scale value
                scaledHeight := int((value / g.maxValue) * float64(height-1))
                if scaledHeight &gt;= height </span><span class="cov0" title="0">{
                        scaledHeight = height - 1
                }</span>

                // Draw character
                <span class="cov0" title="0">cellY := y + height - scaledHeight - 1
                screen.SetContent(x+col, cellY, '*', nil, tcell.StyleDefault.Foreground(g.color))
                
                // Draw secondary data if available
                if len(g.secondaryData) &gt; 0 </span><span class="cov0" title="0">{
                        idx2 := int(float64(col) / float64(width-1) * float64(len(g.secondaryData)-1))
                        if idx2 &gt;= len(g.secondaryData) </span><span class="cov0" title="0">{
                                idx2 = len(g.secondaryData) - 1
                        }</span>
                        <span class="cov0" title="0">value2 := g.secondaryData[idx2].Value
                        scaledHeight2 := int((value2 / g.maxValue) * float64(height-1))
                        if scaledHeight2 &gt;= height </span><span class="cov0" title="0">{
                                scaledHeight2 = height - 1
                        }</span>
                        <span class="cov0" title="0">cellY2 := y + height - scaledHeight2 - 1
                        if cellY2 != cellY </span><span class="cov0" title="0">{
                                screen.SetContent(x+col, cellY2, '+', nil, tcell.StyleDefault.Foreground(g.secondaryColor))
                        }</span>
                }
        }
}

// formatValue formats a value with appropriate units
func formatValue(value float64) string <span class="cov0" title="0">{
        if value &gt;= 1e9 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1fG", value/1e9)
        }</span> else<span class="cov0" title="0"> if value &gt;= 1e6 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1fM", value/1e6)
        }</span> else<span class="cov0" title="0"> if value &gt;= 1e3 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1fK", value/1e3)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f", value)</span>
}

// ColorToHex converts a tcell.Color to a hex string for tview
func ColorToHex(color tcell.Color) string <span class="cov7" title="5">{
        // Handle basic named colors for accurate hex mapping
        switch color </span>{
        case tcell.ColorRed:<span class="cov1" title="1">
                return "#ff0000"</span>
        case tcell.ColorGreen:<span class="cov1" title="1">
                return "#00ff00"</span>
        case tcell.ColorBlue:<span class="cov1" title="1">
                return "#0000ff"</span>
        case tcell.ColorWhite:<span class="cov1" title="1">
                return "#ffffff"</span>
        case tcell.ColorBlack:<span class="cov1" title="1">
                return "#000000"</span>
        }
        <span class="cov0" title="0">r, g, b := color.RGB()
        return fmt.Sprintf("#%02x%02x%02x", r, g, b)</span>
}

// min returns the minimum of two integers
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// GraphWidget is a wrapper around Graph that implements the tview.Primitive interface
type GraphWidget struct {
        *Graph
        historyDuration time.Duration
        sampleInterval  time.Duration
        dataFunc        func() (float64, float64)
        stopChan        chan struct{}
        started         bool
}

// NewGraphWidget creates a new graph widget
func NewGraphWidget() *GraphWidget <span class="cov0" title="0">{
        return &amp;GraphWidget{
                Graph:           NewGraph(),
                historyDuration: 2 * time.Minute,
                sampleInterval:  1 * time.Second,
                stopChan:        make(chan struct{}),
        }
}</span>

// SetDataFunc sets the function that provides data for the graph
func (gw *GraphWidget) SetDataFunc(f func() (float64, float64)) *GraphWidget <span class="cov0" title="0">{
        gw.dataFunc = f
        return gw
}</span>

// SetSampleInterval sets how often to sample data
func (gw *GraphWidget) SetSampleInterval(d time.Duration) *GraphWidget <span class="cov0" title="0">{
        gw.sampleInterval = d
        return gw
}</span>

// SetHistoryDuration sets how much history to keep
func (gw *GraphWidget) SetHistoryDuration(d time.Duration) *GraphWidget <span class="cov0" title="0">{
        gw.historyDuration = d
        maxPoints := int(d / gw.sampleInterval)
        gw.Graph.maxPoints = maxPoints
        return gw
}</span>

// Start starts the data collection
func (gw *GraphWidget) Start() <span class="cov0" title="0">{
        if gw.started || gw.dataFunc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">gw.started = true
        
        // Add some initial test data to make the graph visible immediately
        for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                // Use AddDualPoint instead since there's no AddSecondaryPoint method
                gw.AddDualPoint(float64(i * 10), float64((10-i) * 5))
        }</span>
        
        // Set initial max value
        <span class="cov0" title="0">gw.maxValue = 100
        
        go func() </span><span class="cov0" title="0">{
                // Add an initial real data point immediately in the goroutine
                primary, secondary := gw.dataFunc()
                gw.AddDualPoint(primary, secondary)
                
                ticker := time.NewTicker(gw.sampleInterval)
                defer ticker.Stop()
                
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                primary, secondary := gw.dataFunc()
                                gw.AddDualPoint(primary, secondary)</span>
                        case &lt;-gw.stopChan:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

// Stop stops the data collection
func (gw *GraphWidget) Stop() <span class="cov0" title="0">{
        if !gw.started </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">close(gw.stopChan)
        gw.started = false</span>
}

// GraphWidgets returns the slice of GraphWidget pointers in the MultiGraph
func (mg *MultiGraph) GraphWidgets() []*GraphWidget <span class="cov0" title="0">{
    return mg.graphs
}</span>

// DataPoints returns a copy of primary data points from the GraphWidget
func (gw *GraphWidget) DataPoints() []DataPoint <span class="cov0" title="0">{
    gw.mutex.RLock()
    defer gw.mutex.RUnlock()
    pts := make([]DataPoint, len(gw.data))
    copy(pts, gw.data)
    return pts
}</span>

// SecondaryDataPoints returns a copy of secondary data points from the GraphWidget
func (gw *GraphWidget) SecondaryDataPoints() []DataPoint <span class="cov0" title="0">{
    gw.mutex.RLock()
    defer gw.mutex.RUnlock()
    pts := make([]DataPoint, len(gw.secondaryData))
    copy(pts, gw.secondaryData)
    return pts
}</span>

// Labels returns the primary and secondary labels of the GraphWidget
func (gw *GraphWidget) Labels() (string, string) <span class="cov0" title="0">{
    return gw.primaryLabel, gw.secondaryLabel
}</span>

// MultiGraph is a widget that displays multiple graphs
type MultiGraph struct {
        *tview.Box
        graphs     []*GraphWidget
        showTitle  bool
        title      string
        titleAlign int
}

// NewMultiGraph creates a new multi-graph widget
func NewMultiGraph() *MultiGraph <span class="cov0" title="0">{
        return &amp;MultiGraph{
                Box:        tview.NewBox(),
                graphs:     make([]*GraphWidget, 0),
                showTitle:  true,
                titleAlign: tview.AlignCenter,
        }
}</span>

// SetTitle sets the title of the multi-graph
func (mg *MultiGraph) SetTitle(title string) *MultiGraph <span class="cov0" title="0">{
        mg.title = title
        return mg
}</span>

// SetTitleAlign sets the alignment of the title
func (mg *MultiGraph) SetTitleAlign(align int) *MultiGraph <span class="cov0" title="0">{
        mg.titleAlign = align
        return mg
}</span>

// ShowTitle enables or disables the title
func (mg *MultiGraph) ShowTitle(show bool) *MultiGraph <span class="cov0" title="0">{
        mg.showTitle = show
        return mg
}</span>

// AddGraph adds a graph to the multi-graph
func (mg *MultiGraph) AddGraph(graph *GraphWidget) *MultiGraph <span class="cov0" title="0">{
        mg.graphs = append(mg.graphs, graph)
        return mg
}</span>

// SetGradientEnabled toggles static gradient shading for all graphs
func (mg *MultiGraph) SetGradientEnabled(enabled bool) *MultiGraph <span class="cov0" title="0">{
        for _, gw := range mg.graphs </span><span class="cov0" title="0">{
                gw.SetGradientEnabled(enabled)
        }</span>
        <span class="cov0" title="0">return mg</span>
}

// Draw draws the multi-graph
func (mg *MultiGraph) Draw(screen tcell.Screen) <span class="cov0" title="0">{
        mg.Box.DrawForSubclass(screen, mg)
        
        x, y, width, height := mg.GetInnerRect()
        
        // Draw title if enabled
        titleHeight := 0
        if mg.showTitle &amp;&amp; mg.title != "" </span><span class="cov0" title="0">{
                titleColor := tcell.ColorWhite
                if len(mg.graphs) &gt; 0 </span><span class="cov0" title="0">{
                        titleColor = mg.graphs[0].color
                }</span>
                <span class="cov0" title="0">tview.Print(screen, mg.title, x, y, width, mg.titleAlign, titleColor)
                titleHeight = 1</span>
        }
        
        // Calculate the height for each graph
        <span class="cov0" title="0">numGraphs := len(mg.graphs)
        if numGraphs == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">graphHeight := (height - titleHeight) / numGraphs
        if graphHeight &lt; 5 </span><span class="cov0" title="0">{
                graphHeight = 5 // Minimum height for a graph
        }</span>
        
        // Draw each graph
        <span class="cov0" title="0">for i, graph := range mg.graphs </span><span class="cov0" title="0">{
                if i*graphHeight+graphHeight+titleHeight &gt; height </span><span class="cov0" title="0">{
                        break</span> // Don't draw graphs that don't fit
                }
                
                <span class="cov0" title="0">graphY := y + titleHeight + i*graphHeight
                
                // Set the position and size of the graph
                graph.SetRect(x, graphY, width, graphHeight)
                
                // Render the actual graph
                graph.Draw(screen)</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package netcap

import (
        "fmt"
        "log"
        "net"
        "sync"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
        "github.com/google/gopacket/pcap"
)

// Connection represents a network connection
type Connection struct {
        SrcIP    net.IP
        DstIP    net.IP
        SrcPort  uint16
        DstPort  uint16
        Protocol string
        Service  string         // application/service protocol
        Size     uint64
        Packets  uint64
        LastSeen time.Time
}

// ConnectionKey is used as a map key for connections
type ConnectionKey struct {
        SrcIP    string
        DstIP    string
        SrcPort  uint16
        DstPort  uint16
        Protocol string
}

// InterfaceStats contains statistics for a network interface
type InterfaceStats struct {
        Name        string
        BytesIn     uint64
        BytesOut    uint64
        PacketsIn   uint64
        PacketsOut  uint64
        Connections map[ConnectionKey]*Connection
        mutex       sync.RWMutex
}

// PacketInfo holds metadata for a captured packet
type PacketInfo struct {
        Timestamp time.Time
        SrcIP     net.IP
        DstIP     net.IP
        SrcPort   uint16
        DstPort   uint16
        Protocol  string
        Service   string         // application/service protocol (HTTP, DNS, etc.)
        Length    uint64
        Data      []byte         // raw packet data
}

// servicePortMap maps well-known ports to service names
var servicePortMap = map[uint16]string{
        80:   "HTTP",
        443:  "HTTPS",
        22:   "SSH",
        53:   "DNS",
        123:  "NTP",
        67:   "DHCP",
        68:   "DHCP",
        25:   "SMTP",
        143:  "IMAP",
        110:  "POP3",
}

// detectService returns the service name for given transport protocol and ports, falling back to the protocol
func detectService(proto string, srcPort, dstPort uint16) string <span class="cov10" title="11">{
        if proto != "TCP" &amp;&amp; proto != "UDP" </span><span class="cov3" title="2">{
                return proto
        }</span>
        <span class="cov9" title="9">if name, ok := servicePortMap[dstPort]; ok </span><span class="cov8" title="7">{
                return name
        }</span>
        <span class="cov3" title="2">if name, ok := servicePortMap[srcPort]; ok </span><span class="cov0" title="0">{
                return name
        }</span>
        <span class="cov3" title="2">return proto</span>
}

// NetworkMonitor monitors network traffic
type NetworkMonitor struct {
        Interfaces     map[string]*InterfaceStats
        ActiveHandles  map[string]*pcap.Handle
        StopCapture    chan bool
        mutex          sync.RWMutex
        localAddresses map[string]bool
        filterExpression string           // current BPF filter
        packetBuffer     []PacketInfo     // recent packets buffer
        bufferMutex      sync.RWMutex
        maxBufferSize    int
}

// NewNetworkMonitor creates a new network monitor
func NewNetworkMonitor() *NetworkMonitor <span class="cov7" title="6">{
        return &amp;NetworkMonitor{
                Interfaces:     make(map[string]*InterfaceStats),
                ActiveHandles:  make(map[string]*pcap.Handle),
                StopCapture:    make(chan bool),
                localAddresses: make(map[string]bool),
                filterExpression: "",
                packetBuffer:     make([]PacketInfo, 0),
                bufferMutex:      sync.RWMutex{},
                maxBufferSize:    1000,
        }
}</span>

// GetInterfaces returns a list of available network interfaces
func GetInterfaces() ([]pcap.Interface, error) <span class="cov0" title="0">{
        return pcap.FindAllDevs()
}</span>

// StartCapture starts capturing packets on the specified interface
func (nm *NetworkMonitor) StartCapture(interfaceName string) error <span class="cov0" title="0">{
        // Check if we're already capturing on this interface
        nm.mutex.Lock()
        if _, exists := nm.ActiveHandles[interfaceName]; exists </span><span class="cov0" title="0">{
                nm.mutex.Unlock()
                return fmt.Errorf("already capturing on interface %s", interfaceName)
        }</span>
        <span class="cov0" title="0">nm.mutex.Unlock()

        // Initialize interface stats if not already done
        nm.mutex.Lock()
        if _, exists := nm.Interfaces[interfaceName]; !exists </span><span class="cov0" title="0">{
                nm.Interfaces[interfaceName] = &amp;InterfaceStats{
                        Name:        interfaceName,
                        Connections: make(map[ConnectionKey]*Connection),
                }
        }</span>
        <span class="cov0" title="0">nm.mutex.Unlock()

        // Get local addresses
        nm.updateLocalAddresses()

        // Open the device for capturing
        handle, err := pcap.OpenLive(interfaceName, 1600, true, pcap.BlockForever)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error opening interface %s: %v", interfaceName, err)
        }</span>

        <span class="cov0" title="0">nm.mutex.Lock()
        nm.ActiveHandles[interfaceName] = handle
        nm.mutex.Unlock()

        // Start packet processing in a goroutine
        go nm.processPackets(interfaceName, handle)

        return nil</span>
}

// StopAllCaptures stops all active packet captures
func (nm *NetworkMonitor) StopAllCaptures() <span class="cov0" title="0">{
        nm.mutex.Lock()
        defer nm.mutex.Unlock()

        // Signal to stop
        close(nm.StopCapture)

        // Close all handles
        for name, handle := range nm.ActiveHandles </span><span class="cov0" title="0">{
                handle.Close()
                delete(nm.ActiveHandles, name)
        }</span>
}

// processPackets processes packets from the given handle
func (nm *NetworkMonitor) processPackets(interfaceName string, handle *pcap.Handle) <span class="cov0" title="0">{
        packetSource := gopacket.NewPacketSource(handle, handle.LinkType())
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-nm.StopCapture:<span class="cov0" title="0">
                        return</span>
                case packet, ok := &lt;-packetSource.Packets():<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">nm.processPacket(interfaceName, packet)</span>
                }
        }
}

// processPacket processes a single packet
func (nm *NetworkMonitor) processPacket(interfaceName string, packet gopacket.Packet) <span class="cov0" title="0">{
        // Get interface stats
        nm.mutex.RLock()
        ifStats, exists := nm.Interfaces[interfaceName]
        nm.mutex.RUnlock()
        
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        // Extract network layer info (IP)
        <span class="cov0" title="0">ipLayer := packet.NetworkLayer()
        if ipLayer == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">ipPacket, ok := ipLayer.(*layers.IPv4)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        // Get packet size
        <span class="cov0" title="0">packetSize := uint64(len(packet.Data()))

        // Determine direction (in/out) based on source/dest IPs
        srcIP := ipPacket.SrcIP
        dstIP := ipPacket.DstIP
        
        isOutbound := nm.isLocalAddress(srcIP.String())
        isInbound := nm.isLocalAddress(dstIP.String())

        // Update interface stats
        ifStats.mutex.Lock()
        if isOutbound </span><span class="cov0" title="0">{
                ifStats.BytesOut += packetSize
                ifStats.PacketsOut++
        }</span>
        <span class="cov0" title="0">if isInbound </span><span class="cov0" title="0">{
                ifStats.BytesIn += packetSize
                ifStats.PacketsIn++
        }</span>
        <span class="cov0" title="0">ifStats.mutex.Unlock()

        // Extract transport layer info (TCP/UDP)
        var srcPort, dstPort uint16
        var protocol string

        tcpLayer := packet.Layer(layers.LayerTypeTCP)
        if tcpLayer != nil </span><span class="cov0" title="0">{
                tcp, _ := tcpLayer.(*layers.TCP)
                srcPort = uint16(tcp.SrcPort)
                dstPort = uint16(tcp.DstPort)
                protocol = "TCP"
        }</span> else<span class="cov0" title="0"> {
                udpLayer := packet.Layer(layers.LayerTypeUDP)
                if udpLayer != nil </span><span class="cov0" title="0">{
                        udp, _ := udpLayer.(*layers.UDP)
                        srcPort = uint16(udp.SrcPort)
                        dstPort = uint16(udp.DstPort)
                        protocol = "UDP"
                }</span> else<span class="cov0" title="0"> {
                        // Neither TCP nor UDP
                        protocol = ipPacket.Protocol.String()
                }</span>
        }

        // Create connection key
        <span class="cov0" title="0">connKey := ConnectionKey{
                SrcIP:    srcIP.String(),
                DstIP:    dstIP.String(),
                SrcPort:  srcPort,
                DstPort:  dstPort,
                Protocol: protocol,
        }

        // Update connection stats
        ifStats.mutex.Lock()
        conn, exists := ifStats.Connections[connKey]
        if !exists </span><span class="cov0" title="0">{
                conn = &amp;Connection{
                        SrcIP:    srcIP,
                        DstIP:    dstIP,
                        SrcPort:  srcPort,
                        DstPort:  dstPort,
                        Protocol: protocol,
                        Service:  detectService(protocol, srcPort, dstPort),
                }
                ifStats.Connections[connKey] = conn
        }</span>
        
        <span class="cov0" title="0">conn.Size += packetSize
        conn.Packets++
        conn.LastSeen = time.Now()
        ifStats.mutex.Unlock()

        // Add to packet buffer
        nm.bufferMutex.Lock()
        pi := PacketInfo{
                Timestamp: packet.Metadata().Timestamp,
                SrcIP:     srcIP,
                DstIP:     dstIP,
                SrcPort:   srcPort,
                DstPort:   dstPort,
                Protocol:  protocol,
                Service:   detectService(protocol, srcPort, dstPort),
                Length:    packetSize,
                Data:      append([]byte(nil), packet.Data()...),
        }
        nm.packetBuffer = append(nm.packetBuffer, pi)
        if len(nm.packetBuffer) &gt; nm.maxBufferSize </span><span class="cov0" title="0">{
                nm.packetBuffer = nm.packetBuffer[len(nm.packetBuffer)-nm.maxBufferSize:]
        }</span>
        <span class="cov0" title="0">nm.bufferMutex.Unlock()</span>
}

// updateLocalAddresses gets all local IP addresses
func (nm *NetworkMonitor) updateLocalAddresses() <span class="cov0" title="0">{
        addrs, err := net.InterfaceAddrs()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error getting local addresses: %v", err)
                return
        }</span>

        <span class="cov0" title="0">nm.mutex.Lock()
        defer nm.mutex.Unlock()
        
        // Clear existing addresses
        nm.localAddresses = make(map[string]bool)
        
        // Add all local addresses
        for _, addr := range addrs </span><span class="cov0" title="0">{
                if ipnet, ok := addr.(*net.IPNet); ok </span><span class="cov0" title="0">{
                        nm.localAddresses[ipnet.IP.String()] = true
                }</span>
        }
}

// isLocalAddress checks if an IP address is local
func (nm *NetworkMonitor) isLocalAddress(ip string) bool <span class="cov3" title="2">{
        nm.mutex.RLock()
        defer nm.mutex.RUnlock()
        
        return nm.localAddresses[ip]
}</span>

// IsLocalAddress returns whether the given IP is local to any interface
func (nm *NetworkMonitor) IsLocalAddress(ip string) bool <span class="cov3" title="2">{
        return nm.isLocalAddress(ip)
}</span>

// SetBpfFilter applies a BPF filter on an active capture handle
func (nm *NetworkMonitor) SetBpfFilter(interfaceName, filter string) error <span class="cov1" title="1">{
        nm.mutex.Lock()
        defer nm.mutex.Unlock()
        handle, ok := nm.ActiveHandles[interfaceName]
        if !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("interface %s not capturing", interfaceName)
        }</span>
        <span class="cov0" title="0">if err := handle.SetBPFFilter(filter); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error setting BPF filter on %s: %v", interfaceName, err)
        }</span>
        <span class="cov0" title="0">nm.filterExpression = filter
        return nil</span>
}

// GetPacketBuffer returns a copy of recent captured packets
func (nm *NetworkMonitor) GetPacketBuffer() []PacketInfo <span class="cov1" title="1">{
        nm.bufferMutex.RLock()
        defer nm.bufferMutex.RUnlock()
        buf := make([]PacketInfo, len(nm.packetBuffer))
        copy(buf, nm.packetBuffer)
        return buf
}</span>

// GetFilterExpression returns the current BPF filter string
func (nm *NetworkMonitor) GetFilterExpression() string <span class="cov1" title="1">{
        nm.mutex.RLock()
        defer nm.mutex.RUnlock()
        return nm.filterExpression
}</span>

// GetInterfaceStats returns statistics for all interfaces
func (nm *NetworkMonitor) GetInterfaceStats() map[string]*InterfaceStats <span class="cov0" title="0">{
        nm.mutex.RLock()
        defer nm.mutex.RUnlock()
        
        // Create a copy to avoid concurrent access issues
        statsCopy := make(map[string]*InterfaceStats)
        for name, stats := range nm.Interfaces </span><span class="cov0" title="0">{
                statsCopy[name] = stats
        }</span>
        
        <span class="cov0" title="0">return statsCopy</span>
}

// GetConnections returns all connections for a specific interface
func (nm *NetworkMonitor) GetConnections(interfaceName string) []*Connection <span class="cov0" title="0">{
        nm.mutex.RLock()
        ifStats, exists := nm.Interfaces[interfaceName]
        nm.mutex.RUnlock()
        
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">ifStats.mutex.RLock()
        defer ifStats.mutex.RUnlock()
        
        // Create a slice of connections
        connections := make([]*Connection, 0, len(ifStats.Connections))
        for _, conn := range ifStats.Connections </span><span class="cov0" title="0">{
                connections = append(connections, conn)
        }</span>
        
        <span class="cov0" title="0">return connections</span>
}

// CleanupOldConnections removes connections that haven't been seen recently
func (nm *NetworkMonitor) CleanupOldConnections(maxAge time.Duration) <span class="cov0" title="0">{
        now := time.Now()
        
        nm.mutex.RLock()
        defer nm.mutex.RUnlock()
        
        for _, ifStats := range nm.Interfaces </span><span class="cov0" title="0">{
                ifStats.mutex.Lock()
                
                for key, conn := range ifStats.Connections </span><span class="cov0" title="0">{
                        if now.Sub(conn.LastSeen) &gt; maxAge </span><span class="cov0" title="0">{
                                delete(ifStats.Connections, key)
                        }</span>
                }
                
                <span class="cov0" title="0">ifStats.mutex.Unlock()</span>
        }
}

// GetPcapStats returns pcap statistics for a given interface (received, dropped, interface-dropped)
func (nm *NetworkMonitor) GetPcapStats(interfaceName string) (*pcap.Stats, error) <span class="cov0" title="0">{
        nm.mutex.RLock()
        handle, ok := nm.ActiveHandles[interfaceName]
        nm.mutex.RUnlock()
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("interface %s not capturing", interfaceName)
        }</span>
        <span class="cov0" title="0">stats, err := handle.Stats()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package protocols

import (
        "bufio"
        "fmt"
        "math/rand"
        "net"
        "strings"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
        "github.com/google/gopacket/tcpassembly"
        "github.com/google/gopacket/tcpassembly/tcpreader"
)

// ProtocolAnalyzer defines the interface for protocol-specific analyzers
type ProtocolAnalyzer interface {
        // GetProtocolName returns the name of the protocol
        GetProtocolName() string
        
        // GetPorts returns the standard ports for this protocol
        GetPorts() []uint16
        
        // AnalyzeStream analyzes a TCP stream for this protocol
        AnalyzeStream(flow gopacket.Flow, reader *tcpreader.ReaderStream) []ProtocolEvent
        
        // IsProtocolTraffic determines if the given data belongs to this protocol
        IsProtocolTraffic(data []byte) bool
}

// ProtocolEvent represents a protocol-specific event
type ProtocolEvent struct {
        ID          string                 `json:"id"`
        Protocol    string                 `json:"protocol"`
        EventType   EventType              `json:"event_type"`
        Timestamp   time.Time              `json:"timestamp"`
        SourceIP    net.IP                 `json:"source_ip"`
        DestIP      net.IP                 `json:"dest_ip"`
        SourcePort  uint16                 `json:"source_port"`
        DestPort    uint16                 `json:"dest_port"`
        Command     string                 `json:"command,omitempty"`
        Response    string                 `json:"response,omitempty"`
        Username    string                 `json:"username,omitempty"`
        Filename    string                 `json:"filename,omitempty"`
        FileSize    int64                  `json:"file_size,omitempty"`
        Status      string                 `json:"status,omitempty"`
        Direction   TransferDirection      `json:"direction"`
        Data        map[string]interface{} `json:"data,omitempty"`
        Raw         []byte                 `json:"raw,omitempty"`
}

// EventType categorizes different protocol events
type EventType string

const (
        EventTypeConnection    EventType = "connection"
        EventTypeAuthentication EventType = "authentication"
        EventTypeCommand       EventType = "command"
        EventTypeDataTransfer  EventType = "data_transfer"
        EventTypeFileTransfer  EventType = "file_transfer"
        EventTypeEmail         EventType = "email"
        EventTypeError         EventType = "error"
        EventTypeDisconnection EventType = "disconnection"
)

// TransferDirection indicates data flow direction
type TransferDirection string

const (
        DirectionUpload   TransferDirection = "upload"
        DirectionDownload TransferDirection = "download"
        DirectionInbound  TransferDirection = "inbound"
        DirectionOutbound TransferDirection = "outbound"
)

// ProtocolManager manages all protocol analyzers
type ProtocolManager struct {
        analyzers    map[string]ProtocolAnalyzer
        assembler    *tcpassembly.Assembler
        events       chan ProtocolEvent
        maxEvents    int
}

// NewProtocolManager creates a new protocol manager
func NewProtocolManager(maxEvents int) *ProtocolManager <span class="cov1" title="1">{
        pm := &amp;ProtocolManager{
                analyzers: make(map[string]ProtocolAnalyzer),
                events:    make(chan ProtocolEvent, maxEvents),
                maxEvents: maxEvents,
        }
        
        // Register built-in analyzers
        pm.RegisterAnalyzer(NewFTPAnalyzer())
        pm.RegisterAnalyzer(NewSSHAnalyzer())
        pm.RegisterAnalyzer(NewPOP3Analyzer())
        pm.RegisterAnalyzer(NewIMAPAnalyzer())
        
        // Create assembler with factory
        streamFactory := &amp;protocolStreamFactory{manager: pm}
        pm.assembler = tcpassembly.NewAssembler(tcpassembly.NewStreamPool(streamFactory))
        
        return pm
}</span>

// RegisterAnalyzer registers a new protocol analyzer
func (pm *ProtocolManager) RegisterAnalyzer(analyzer ProtocolAnalyzer) <span class="cov10" title="4">{
        pm.analyzers[analyzer.GetProtocolName()] = analyzer
}</span>

// ProcessPacket processes a packet through all analyzers
func (pm *ProtocolManager) ProcessPacket(packet gopacket.Packet) <span class="cov0" title="0">{
        if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                tcp := tcpLayer.(*layers.TCP)
                pm.assembler.AssembleWithTimestamp(packet.NetworkLayer().NetworkFlow(),
                        tcp, packet.Metadata().Timestamp)
        }</span>
}

// GetEvents returns the events channel
func (pm *ProtocolManager) GetEvents() &lt;-chan ProtocolEvent <span class="cov0" title="0">{
        return pm.events
}</span>

// GetAnalyzers returns all registered analyzers
func (pm *ProtocolManager) GetAnalyzers() map[string]ProtocolAnalyzer <span class="cov1" title="1">{
        return pm.analyzers
}</span>

// FlushConnections flushes all connections
func (pm *ProtocolManager) FlushConnections() <span class="cov0" title="0">{
        pm.assembler.FlushAll()
}</span>

// protocolStreamFactory creates streams for protocol analysis
type protocolStreamFactory struct {
        manager *ProtocolManager
}

func (factory *protocolStreamFactory) New(net, transport gopacket.Flow) tcpassembly.Stream <span class="cov0" title="0">{
        stream := &amp;protocolStream{
                net:       net,
                transport: transport,
                r:         tcpreader.NewReaderStream(),
                manager:   factory.manager,
        }
        go stream.run()
        return &amp;stream.r
}</span>

// protocolStream processes a single TCP stream
type protocolStream struct {
        net, transport gopacket.Flow
        r              tcpreader.ReaderStream
        manager        *ProtocolManager
}

func (stream *protocolStream) run() <span class="cov0" title="0">{
        defer stream.r.Close()
        
        // Determine which protocol analyzer to use based on port
        srcPort := uint16(stream.transport.Src().FastHash())
        dstPort := uint16(stream.transport.Dst().FastHash())
        
        var analyzer ProtocolAnalyzer
        
        // Check each analyzer to see if it handles this port
        for _, a := range stream.manager.analyzers </span><span class="cov0" title="0">{
                ports := a.GetPorts()
                for _, port := range ports </span><span class="cov0" title="0">{
                        if srcPort == port || dstPort == port </span><span class="cov0" title="0">{
                                analyzer = a
                                break</span>
                        }
                }
                <span class="cov0" title="0">if analyzer != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        
        <span class="cov0" title="0">if analyzer == nil </span><span class="cov0" title="0">{
                // Try to identify protocol by content
                buf := make([]byte, 1024)
                n, err := stream.r.Read(buf)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                
                <span class="cov0" title="0">for _, a := range stream.manager.analyzers </span><span class="cov0" title="0">{
                        if a.IsProtocolTraffic(buf[:n]) </span><span class="cov0" title="0">{
                                analyzer = a
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if analyzer == nil </span><span class="cov0" title="0">{
                        return // Unknown protocol
                }</span>
        }
        
        // Analyze the stream with the identified protocol analyzer
        <span class="cov0" title="0">events := analyzer.AnalyzeStream(stream.transport, &amp;stream.r)
        
        // Send events to the manager
        for _, event := range events </span><span class="cov0" title="0">{
                // Set connection details
                event.SourceIP = net.ParseIP(stream.net.Src().String())
                event.DestIP = net.ParseIP(stream.net.Dst().String())
                event.SourcePort = srcPort
                event.DestPort = dstPort
                event.Timestamp = time.Now()
                
                // Send to channel (non-blocking)
                select </span>{
                case stream.manager.events &lt;- event:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                        // Channel full, drop event
                }
        }
}

// BaseAnalyzer provides common functionality for protocol analyzers
type BaseAnalyzer struct {
        protocolName string
        ports        []uint16
}

// GetProtocolName returns the protocol name
func (ba *BaseAnalyzer) GetProtocolName() string <span class="cov10" title="4">{
        return ba.protocolName
}</span>

// GetPorts returns the standard ports
func (ba *BaseAnalyzer) GetPorts() []uint16 <span class="cov0" title="0">{
        return ba.ports
}</span>

// Helper functions for protocol analyzers

// ReadLine reads a line from the stream
func ReadLine(reader *bufio.Reader) (string, error) <span class="cov0" title="0">{
        line, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(line), nil</span>
}

// ReadUntil reads until a specific delimiter
func ReadUntil(reader *bufio.Reader, delimiter byte) ([]byte, error) <span class="cov0" title="0">{
        var data []byte
        for </span><span class="cov0" title="0">{
                b, err := reader.ReadByte()
                if err != nil </span><span class="cov0" title="0">{
                        return data, err
                }</span>
                <span class="cov0" title="0">data = append(data, b)
                if b == delimiter </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return data, nil</span>
}

// ParseCommand parses a protocol command
func ParseCommand(line string) (command string, args []string) <span class="cov0" title="0">{
        parts := strings.Fields(line)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return strings.ToUpper(parts[0]), parts[1:]</span>
}

// GenerateEventID generates a unique event ID
func GenerateEventID(protocol string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s_%d_%d", protocol, time.Now().UnixNano(), rand.Intn(1000))
}</pre>
		
		<pre class="file" id="file3" style="display: none">package protocols

import (
        "bufio"
        "fmt"
        "net"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/tcpassembly/tcpreader"
)

// FTPAnalyzer analyzes FTP protocol traffic
type FTPAnalyzer struct {
        BaseAnalyzer
        sessions map[string]*FTPSession
}

// FTPSession represents an active FTP session
type FTPSession struct {
        ID              string
        ClientIP        net.IP
        ServerIP        net.IP
        ControlPort     uint16
        DataPort        uint16
        Username        string
        CurrentDir      string
        TransferMode    string
        TransferType    string
        PassiveMode     bool
        DataConnection  *net.TCPAddr
        Commands        []FTPCommand
        Transfers       []FileTransfer
        StartTime       time.Time
        LastActivity    time.Time
        Authenticated   bool
}

// FTPCommand represents an FTP command
type FTPCommand struct {
        Command   string
        Arguments string
        Response  string
        Code      int
        Timestamp time.Time
}

// FileTransfer represents an FTP file transfer
type FileTransfer struct {
        Filename    string
        Direction   TransferDirection
        Size        int64
        StartTime   time.Time
        EndTime     time.Time
        Complete    bool
        Mode        string
        Type        string
}

// NewFTPAnalyzer creates a new FTP analyzer
func NewFTPAnalyzer() ProtocolAnalyzer <span class="cov8" title="1">{
        return &amp;FTPAnalyzer{
                BaseAnalyzer: BaseAnalyzer{
                        protocolName: "FTP",
                        ports:        []uint16{21, 20}, // Control and data ports
                },
                sessions: make(map[string]*FTPSession),
        }
}</span>

// AnalyzeStream analyzes an FTP stream
func (ftp *FTPAnalyzer) AnalyzeStream(flow gopacket.Flow, reader *tcpreader.ReaderStream) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        buf := bufio.NewReader(reader)
        
        // Create session key
        sessionKey := fmt.Sprintf("%s-&gt;%s", flow.Src().String(), flow.Dst().String())
        
        // Get or create session
        session := ftp.getOrCreateSession(sessionKey, flow)
        
        // Determine if this is control or data channel
        srcPort := uint16(flow.Src().FastHash())
        dstPort := uint16(flow.Dst().FastHash())
        
        if srcPort == 21 || dstPort == 21 </span><span class="cov0" title="0">{
                // Control channel
                events = append(events, ftp.analyzeControlChannel(session, buf)...)
        }</span> else<span class="cov0" title="0"> {
                // Data channel
                events = append(events, ftp.analyzeDataChannel(session, buf)...)
        }</span>
        
        <span class="cov0" title="0">return events</span>
}

// IsProtocolTraffic determines if data is FTP traffic
func (ftp *FTPAnalyzer) IsProtocolTraffic(data []byte) bool <span class="cov0" title="0">{
        dataStr := strings.ToUpper(string(data))
        
        // Check for FTP server welcome messages
        if strings.HasPrefix(dataStr, "220 ") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Check for common FTP commands
        <span class="cov0" title="0">ftpCommands := []string{"USER ", "PASS ", "STOR ", "RETR ", "LIST ", "NLST ", "PWD", "CWD ", "TYPE ", "MODE ", "PASV", "PORT "}
        for _, cmd := range ftpCommands </span><span class="cov0" title="0">{
                if strings.HasPrefix(dataStr, cmd) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

func (ftp *FTPAnalyzer) getOrCreateSession(sessionKey string, flow gopacket.Flow) *FTPSession <span class="cov0" title="0">{
        if session, exists := ftp.sessions[sessionKey]; exists </span><span class="cov0" title="0">{
                session.LastActivity = time.Now()
                return session
        }</span>
        
        <span class="cov0" title="0">session := &amp;FTPSession{
                ID:           fmt.Sprintf("ftp_%d", time.Now().UnixNano()),
                ClientIP:     net.ParseIP(flow.Src().String()),
                ServerIP:     net.ParseIP(flow.Dst().String()),
                ControlPort:  uint16(flow.Dst().FastHash()),
                Commands:     make([]FTPCommand, 0),
                Transfers:    make([]FileTransfer, 0),
                StartTime:    time.Now(),
                LastActivity: time.Now(),
                TransferType: "ASCII",
                TransferMode: "Stream",
        }
        
        ftp.sessions[sessionKey] = session
        return session</span>
}

func (ftp *FTPAnalyzer) analyzeControlChannel(session *FTPSession, reader *bufio.Reader) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        
        for </span><span class="cov0" title="0">{
                line, err := ReadLine(reader)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Determine if this is a command or response
                <span class="cov0" title="0">if ftp.isCommand(line) </span><span class="cov0" title="0">{
                        event := ftp.processCommand(session, line)
                        if event != nil </span><span class="cov0" title="0">{
                                events = append(events, *event)
                        }</span>
                } else<span class="cov0" title="0"> if ftp.isResponse(line) </span><span class="cov0" title="0">{
                        event := ftp.processResponse(session, line)
                        if event != nil </span><span class="cov0" title="0">{
                                events = append(events, *event)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return events</span>
}

func (ftp *FTPAnalyzer) analyzeDataChannel(session *FTPSession, reader *bufio.Reader) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        
        // Read all data from the data channel
        data := make([]byte, 0)
        buf := make([]byte, 4096)
        
        for </span><span class="cov0" title="0">{
                n, err := reader.Read(buf)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">data = append(data, buf[:n]...)</span>
        }
        
        // Create data transfer event
        <span class="cov0" title="0">event := ProtocolEvent{
                ID:        GenerateEventID("FTP"),
                Protocol:  "FTP",
                EventType: EventTypeDataTransfer,
                Data: map[string]interface{}{
                        "session_id": session.ID,
                        "data_size":  len(data),
                        "data_type":  session.TransferType,
                },
                Raw: data,
        }
        
        events = append(events, event)
        
        return events</span>
}

func (ftp *FTPAnalyzer) isCommand(line string) bool <span class="cov0" title="0">{
        // Commands are typically 3-4 characters followed by space or end of line
        if len(line) &lt; 3 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">command := strings.Fields(line)[0]
        return len(command) &gt;= 3 &amp;&amp; len(command) &lt;= 4 &amp;&amp; strings.ToUpper(command) == command</span>
}

func (ftp *FTPAnalyzer) isResponse(line string) bool <span class="cov0" title="0">{
        // Responses start with a 3-digit number
        if len(line) &lt; 3 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">code := line[:3]
        _, err := strconv.Atoi(code)
        return err == nil</span>
}

func (ftp *FTPAnalyzer) processCommand(session *FTPSession, line string) *ProtocolEvent <span class="cov0" title="0">{
        parts := strings.SplitN(line, " ", 2)
        command := strings.ToUpper(parts[0])
        var arguments string
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                arguments = parts[1]
        }</span>
        
        // Add to session commands
        <span class="cov0" title="0">ftpCmd := FTPCommand{
                Command:   command,
                Arguments: arguments,
                Timestamp: time.Now(),
        }
        session.Commands = append(session.Commands, ftpCmd)
        
        // Create event based on command type
        event := &amp;ProtocolEvent{
                ID:        GenerateEventID("FTP"),
                Protocol:  "FTP",
                EventType: EventTypeCommand,
                Command:   line,
                Data: map[string]interface{}{
                        "session_id": session.ID,
                        "command":    command,
                        "arguments":  arguments,
                },
        }
        
        // Handle specific commands
        switch command </span>{
        case "USER":<span class="cov0" title="0">
                session.Username = arguments
                event.Username = arguments
                event.EventType = EventTypeAuthentication</span>
                
        case "PASS":<span class="cov0" title="0">
                event.EventType = EventTypeAuthentication
                event.Data["password_provided"] = true</span>
                
        case "STOR":<span class="cov0" title="0">
                // File upload
                transfer := FileTransfer{
                        Filename:  arguments,
                        Direction: DirectionUpload,
                        StartTime: time.Now(),
                        Mode:      session.TransferMode,
                        Type:      session.TransferType,
                }
                session.Transfers = append(session.Transfers, transfer)
                
                event.EventType = EventTypeFileTransfer
                event.Filename = arguments
                event.Direction = DirectionUpload</span>
                
        case "RETR":<span class="cov0" title="0">
                // File download
                transfer := FileTransfer{
                        Filename:  arguments,
                        Direction: DirectionDownload,
                        StartTime: time.Now(),
                        Mode:      session.TransferMode,
                        Type:      session.TransferType,
                }
                session.Transfers = append(session.Transfers, transfer)
                
                event.EventType = EventTypeFileTransfer
                event.Filename = arguments
                event.Direction = DirectionDownload</span>
                
        case "CWD":<span class="cov0" title="0">
                session.CurrentDir = arguments
                event.Data["directory"] = arguments</span>
                
        case "TYPE":<span class="cov0" title="0">
                session.TransferType = arguments
                event.Data["transfer_type"] = arguments</span>
                
        case "MODE":<span class="cov0" title="0">
                session.TransferMode = arguments
                event.Data["transfer_mode"] = arguments</span>
                
        case "PASV":<span class="cov0" title="0">
                session.PassiveMode = true
                event.Data["passive_mode"] = true</span>
                
        case "PORT":<span class="cov0" title="0">
                session.PassiveMode = false
                dataAddr := ftp.parsePortCommand(arguments)
                if dataAddr != nil </span><span class="cov0" title="0">{
                        session.DataConnection = dataAddr
                        event.Data["data_connection"] = dataAddr.String()
                }</span>
                
        case "QUIT":<span class="cov0" title="0">
                event.EventType = EventTypeDisconnection</span>
        }
        
        <span class="cov0" title="0">return event</span>
}

func (ftp *FTPAnalyzer) processResponse(session *FTPSession, line string) *ProtocolEvent <span class="cov0" title="0">{
        // Parse response code
        code, err := strconv.Atoi(line[:3])
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">message := ""
        if len(line) &gt; 4 </span><span class="cov0" title="0">{
                message = line[4:]
        }</span>
        
        // Update last command with response
        <span class="cov0" title="0">if len(session.Commands) &gt; 0 </span><span class="cov0" title="0">{
                lastCmd := &amp;session.Commands[len(session.Commands)-1]
                lastCmd.Response = line
                lastCmd.Code = code
        }</span>
        
        <span class="cov0" title="0">event := &amp;ProtocolEvent{
                ID:        GenerateEventID("FTP"),
                Protocol:  "FTP",
                EventType: EventTypeCommand,
                Response:  line,
                Status:    fmt.Sprintf("%d", code),
                Data: map[string]interface{}{
                        "session_id":     session.ID,
                        "response_code":  code,
                        "response_text":  message,
                },
        }
        
        // Handle specific response codes
        switch </span>{
        case code == 220:<span class="cov0" title="0">
                // Welcome message
                event.EventType = EventTypeConnection
                event.Data["server_banner"] = message</span>
                
        case code == 230:<span class="cov0" title="0">
                // User logged in
                session.Authenticated = true
                event.EventType = EventTypeAuthentication
                event.Username = session.Username
                event.Data["login_successful"] = true</span>
                
        case code == 530:<span class="cov0" title="0">
                // Login failed
                event.EventType = EventTypeAuthentication
                event.Username = session.Username
                event.Data["login_failed"] = true</span>
                
        case code &gt;= 200 &amp;&amp; code &lt; 300:<span class="cov0" title="0">
                // Success responses
                event.Data["success"] = true</span>
                
        case code &gt;= 400:<span class="cov0" title="0">
                // Error responses
                event.EventType = EventTypeError
                event.Data["error"] = true</span>
                
        case code == 227:<span class="cov0" title="0">
                // Entering passive mode
                dataAddr := ftp.parsePassiveResponse(message)
                if dataAddr != nil </span><span class="cov0" title="0">{
                        session.DataConnection = dataAddr
                        event.Data["data_connection"] = dataAddr.String()
                }</span>
                
        case code == 150:<span class="cov0" title="0">
                // File transfer starting
                event.EventType = EventTypeFileTransfer
                if strings.Contains(message, "bytes") </span><span class="cov0" title="0">{
                        size := ftp.extractFileSize(message)
                        if size &gt; 0 </span><span class="cov0" title="0">{
                                event.FileSize = size
                                // Update transfer in session
                                if len(session.Transfers) &gt; 0 </span><span class="cov0" title="0">{
                                        session.Transfers[len(session.Transfers)-1].Size = size
                                }</span>
                        }
                }
                
        case code == 226:<span class="cov0" title="0">
                // Transfer complete
                event.EventType = EventTypeFileTransfer
                event.Data["transfer_complete"] = true
                // Mark last transfer as complete
                if len(session.Transfers) &gt; 0 </span><span class="cov0" title="0">{
                        transfer := &amp;session.Transfers[len(session.Transfers)-1]
                        transfer.Complete = true
                        transfer.EndTime = time.Now()
                }</span>
        }
        
        <span class="cov0" title="0">return event</span>
}

func (ftp *FTPAnalyzer) parsePortCommand(portStr string) *net.TCPAddr <span class="cov0" title="0">{
        // PORT command format: h1,h2,h3,h4,p1,p2
        parts := strings.Split(portStr, ",")
        if len(parts) != 6 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">var nums [6]int
        for i, part := range parts </span><span class="cov0" title="0">{
                num, err := strconv.Atoi(part)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">nums[i] = num</span>
        }
        
        <span class="cov0" title="0">ip := net.IPv4(byte(nums[0]), byte(nums[1]), byte(nums[2]), byte(nums[3]))
        port := nums[4]*256 + nums[5]
        
        return &amp;net.TCPAddr{
                IP:   ip,
                Port: port,
        }</span>
}

func (ftp *FTPAnalyzer) parsePassiveResponse(response string) *net.TCPAddr <span class="cov0" title="0">{
        // Extract IP and port from passive response: "Entering Passive Mode (h1,h2,h3,h4,p1,p2)"
        re := regexp.MustCompile(`\((\d+),(\d+),(\d+),(\d+),(\d+),(\d+)\)`)
        matches := re.FindStringSubmatch(response)
        
        if len(matches) != 7 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">var nums [6]int
        for i := 1; i &lt; 7; i++ </span><span class="cov0" title="0">{
                num, err := strconv.Atoi(matches[i])
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">nums[i-1] = num</span>
        }
        
        <span class="cov0" title="0">ip := net.IPv4(byte(nums[0]), byte(nums[1]), byte(nums[2]), byte(nums[3]))
        port := nums[4]*256 + nums[5]
        
        return &amp;net.TCPAddr{
                IP:   ip,
                Port: port,
        }</span>
}

func (ftp *FTPAnalyzer) extractFileSize(message string) int64 <span class="cov0" title="0">{
        // Extract file size from messages like "Opening data connection for file.txt (1234 bytes)"
        re := regexp.MustCompile(`\((\d+)\s+bytes?\)`)
        matches := re.FindStringSubmatch(message)
        
        if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                size, err := strconv.ParseInt(matches[1], 10, 64)
                if err == nil </span><span class="cov0" title="0">{
                        return size
                }</span>
        }
        
        <span class="cov0" title="0">return 0</span>
}

// GetActiveSessions returns all active FTP sessions
func (ftp *FTPAnalyzer) GetActiveSessions() []*FTPSession <span class="cov0" title="0">{
        var sessions []*FTPSession
        cutoff := time.Now().Add(-30 * time.Minute) // Consider sessions older than 30 minutes as inactive
        
        for key, session := range ftp.sessions </span><span class="cov0" title="0">{
                if session.LastActivity.After(cutoff) </span><span class="cov0" title="0">{
                        sessions = append(sessions, session)
                }</span> else<span class="cov0" title="0"> {
                        // Clean up old sessions
                        delete(ftp.sessions, key)
                }</span>
        }
        
        <span class="cov0" title="0">return sessions</span>
}

// GetSessionStats returns FTP session statistics
func (ftp *FTPAnalyzer) GetSessionStats() map[string]interface{} <span class="cov0" title="0">{
        activeSessions := ftp.GetActiveSessions()
        
        stats := map[string]interface{}{
                "active_sessions":     len(activeSessions),
                "authenticated_sessions": 0,
                "total_transfers":     0,
                "uploads":            0,
                "downloads":          0,
                "total_bytes":        int64(0),
        }
        
        for _, session := range activeSessions </span><span class="cov0" title="0">{
                if session.Authenticated </span><span class="cov0" title="0">{
                        stats["authenticated_sessions"] = stats["authenticated_sessions"].(int) + 1
                }</span>
                
                <span class="cov0" title="0">stats["total_transfers"] = stats["total_transfers"].(int) + len(session.Transfers)
                
                for _, transfer := range session.Transfers </span><span class="cov0" title="0">{
                        if transfer.Direction == DirectionUpload </span><span class="cov0" title="0">{
                                stats["uploads"] = stats["uploads"].(int) + 1
                        }</span> else<span class="cov0" title="0"> {
                                stats["downloads"] = stats["downloads"].(int) + 1
                        }</span>
                        <span class="cov0" title="0">stats["total_bytes"] = stats["total_bytes"].(int64) + transfer.Size</span>
                }
        }
        
        <span class="cov0" title="0">return stats</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package protocols

import (
        "bufio"
        "fmt"
        "net"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/tcpassembly/tcpreader"
)

// IMAPAnalyzer analyzes IMAP protocol traffic
type IMAPAnalyzer struct {
        BaseAnalyzer
        sessions map[string]*IMAPSession
}

// IMAPSession represents an active IMAP session
type IMAPSession struct {
        ID               string
        ClientIP         net.IP
        ServerIP         net.IP
        Port             uint16
        Username         string
        AuthMethod       string
        State            IMAPState
        Commands         []IMAPCommand
        Capabilities     []string
        Mailboxes        []IMAPMailbox
        SelectedMailbox  *IMAPMailbox
        Messages         []IMAPMessage
        StartTime        time.Time
        LastActivity     time.Time
        Authenticated    bool
        TLSEnabled       bool
        CurrentTag       string
}

// IMAPState represents the state of an IMAP connection
type IMAPState int

const (
        IMAPStateNotAuthenticated IMAPState = iota
        IMAPStateAuthenticated
        IMAPStateSelected
        IMAPStateLogout
)

// IMAPCommand represents an IMAP command
type IMAPCommand struct {
        Tag       string
        Command   string
        Arguments []string
        Response  []string
        Status    string
        Timestamp time.Time
}

// IMAPMailbox represents an IMAP mailbox
type IMAPMailbox struct {
        Name         string
        Attributes   []string
        Delimiter    string
        MessageCount int
        RecentCount  int
        UnseenCount  int
        UIDValidity  int64
        UIDNext      int64
        Flags        []string
}

// IMAPMessage represents an IMAP message
type IMAPMessage struct {
        UID          int64
        SequenceNum  int
        Mailbox      string
        Subject      string
        From         string
        To           []string
        Date         time.Time
        Size         int64
        Flags        []string
        Headers      map[string]string
        Body         string
        Attachments  []EmailAttachment
        Fetched      bool
        Timestamp    time.Time
}

// NewIMAPAnalyzer creates a new IMAP analyzer
func NewIMAPAnalyzer() ProtocolAnalyzer <span class="cov8" title="1">{
        return &amp;IMAPAnalyzer{
                BaseAnalyzer: BaseAnalyzer{
                        protocolName: "IMAP",
                        ports:        []uint16{143, 993}, // IMAP and IMAPS
                },
                sessions: make(map[string]*IMAPSession),
        }
}</span>

// AnalyzeStream analyzes an IMAP stream
func (imap *IMAPAnalyzer) AnalyzeStream(flow gopacket.Flow, reader *tcpreader.ReaderStream) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        buf := bufio.NewReader(reader)
        
        // Create session key
        sessionKey := fmt.Sprintf("%s-&gt;%s", flow.Src().String(), flow.Dst().String())
        
        // Get or create session
        session := imap.getOrCreateSession(sessionKey, flow)
        
        // Analyze IMAP protocol
        events = append(events, imap.analyzeIMAPStream(session, buf)...)
        
        return events
}</span>

// IsProtocolTraffic determines if data is IMAP traffic
func (imap *IMAPAnalyzer) IsProtocolTraffic(data []byte) bool <span class="cov0" title="0">{
        dataStr := strings.ToUpper(string(data))
        
        // Check for IMAP server greeting
        if strings.Contains(dataStr, "* OK") &amp;&amp; (strings.Contains(dataStr, "IMAP") || strings.Contains(dataStr, "READY")) </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Check for common IMAP commands (tagged)
        <span class="cov0" title="0">imapCommands := []string{"LOGIN", "SELECT", "EXAMINE", "FETCH", "STORE", "SEARCH", "LIST", "LSUB", "STATUS", "APPEND", "CHECK", "CLOSE", "EXPUNGE", "COPY", "UID", "LOGOUT", "NOOP", "CAPABILITY", "STARTTLS", "AUTHENTICATE"}
        
        // Look for tagged commands (e.g., "A001 LOGIN user pass")
        lines := strings.Split(dataStr, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                parts := strings.Fields(line)
                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        for _, cmd := range imapCommands </span><span class="cov0" title="0">{
                                if parts[1] == cmd </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        
        // Check for IMAP responses
        <span class="cov0" title="0">if strings.HasPrefix(dataStr, "* ") || strings.Contains(dataStr, " OK ") || strings.Contains(dataStr, " NO ") || strings.Contains(dataStr, " BAD ") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

func (imap *IMAPAnalyzer) getOrCreateSession(sessionKey string, flow gopacket.Flow) *IMAPSession <span class="cov0" title="0">{
        if session, exists := imap.sessions[sessionKey]; exists </span><span class="cov0" title="0">{
                session.LastActivity = time.Now()
                return session
        }</span>
        
        <span class="cov0" title="0">session := &amp;IMAPSession{
                ID:           fmt.Sprintf("imap_%d", time.Now().UnixNano()),
                ClientIP:     net.ParseIP(flow.Src().String()),
                ServerIP:     net.ParseIP(flow.Dst().String()),
                Port:         uint16(flow.Dst().FastHash()),
                State:        IMAPStateNotAuthenticated,
                Commands:     make([]IMAPCommand, 0),
                Capabilities: make([]string, 0),
                Mailboxes:    make([]IMAPMailbox, 0),
                Messages:     make([]IMAPMessage, 0),
                StartTime:    time.Now(),
                LastActivity: time.Now(),
        }
        
        imap.sessions[sessionKey] = session
        return session</span>
}

func (imap *IMAPAnalyzer) analyzeIMAPStream(session *IMAPSession, reader *bufio.Reader) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        
        for </span><span class="cov0" title="0">{
                line, err := ReadLine(reader)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Determine if this is a command or response
                <span class="cov0" title="0">if imap.isCommand(line) </span><span class="cov0" title="0">{
                        event := imap.processCommand(session, line)
                        if event != nil </span><span class="cov0" title="0">{
                                events = append(events, *event)
                        }</span>
                } else<span class="cov0" title="0"> if imap.isResponse(line) </span><span class="cov0" title="0">{
                        event := imap.processResponse(session, line)
                        if event != nil </span><span class="cov0" title="0">{
                                events = append(events, *event)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return events</span>
}

func (imap *IMAPAnalyzer) isCommand(line string) bool <span class="cov0" title="0">{
        // IMAP commands start with a tag followed by command
        parts := strings.Fields(line)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Tag is typically alphanumeric
        <span class="cov0" title="0">tag := parts[0]
        command := strings.ToUpper(parts[1])
        
        if len(tag) == 0 || strings.HasPrefix(tag, "*") </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">imapCommands := []string{"LOGIN", "SELECT", "EXAMINE", "FETCH", "STORE", "SEARCH", "LIST", "LSUB", "STATUS", "APPEND", "CHECK", "CLOSE", "EXPUNGE", "COPY", "UID", "LOGOUT", "NOOP", "CAPABILITY", "STARTTLS", "AUTHENTICATE", "RENAME", "DELETE", "CREATE", "SUBSCRIBE", "UNSUBSCRIBE"}
        
        for _, cmd := range imapCommands </span><span class="cov0" title="0">{
                if command == cmd </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

func (imap *IMAPAnalyzer) isResponse(line string) bool <span class="cov0" title="0">{
        // IMAP responses start with * (untagged) or tag followed by status
        if strings.HasPrefix(line, "* ") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">parts := strings.Fields(line)
        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                status := strings.ToUpper(parts[1])
                return status == "OK" || status == "NO" || status == "BAD"
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

func (imap *IMAPAnalyzer) processCommand(session *IMAPSession, line string) *ProtocolEvent <span class="cov0" title="0">{
        parts := strings.Fields(line)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">tag := parts[0]
        command := strings.ToUpper(parts[1])
        var arguments []string
        if len(parts) &gt; 2 </span><span class="cov0" title="0">{
                arguments = parts[2:]
        }</span>
        
        // Add to session commands
        <span class="cov0" title="0">imapCmd := IMAPCommand{
                Tag:       tag,
                Command:   command,
                Arguments: arguments,
                Response:  make([]string, 0),
                Timestamp: time.Now(),
        }
        session.Commands = append(session.Commands, imapCmd)
        session.CurrentTag = tag
        
        // Create event
        event := &amp;ProtocolEvent{
                ID:        GenerateEventID("IMAP"),
                Protocol:  "IMAP",
                EventType: EventTypeCommand,
                Command:   line,
                Data: map[string]interface{}{
                        "session_id": session.ID,
                        "tag":        tag,
                        "command":    command,
                        "arguments":  arguments,
                },
        }
        
        // Handle specific commands
        switch command </span>{
        case "LOGIN":<span class="cov0" title="0">
                if len(arguments) &gt;= 2 </span><span class="cov0" title="0">{
                        session.Username = arguments[0]
                        event.Username = arguments[0]
                        event.EventType = EventTypeAuthentication
                        event.Data["auth_method"] = "LOGIN"
                }</span>
                
        case "AUTHENTICATE":<span class="cov0" title="0">
                if len(arguments) &gt; 0 </span><span class="cov0" title="0">{
                        session.AuthMethod = arguments[0]
                        event.EventType = EventTypeAuthentication
                        event.Data["auth_method"] = arguments[0]
                }</span>
                
        case "STARTTLS":<span class="cov0" title="0">
                event.Data["tls_requested"] = true</span>
                
        case "CAPABILITY":<span class="cov0" title="0">
                event.Data["requesting_capabilities"] = true</span>
                
        case "SELECT", "EXAMINE":<span class="cov0" title="0">
                if len(arguments) &gt; 0 </span><span class="cov0" title="0">{
                        mailboxName := arguments[0]
                        event.Data["mailbox"] = mailboxName
                        if command == "SELECT" </span><span class="cov0" title="0">{
                                session.State = IMAPStateSelected
                        }</span>
                }
                
        case "LIST", "LSUB":<span class="cov0" title="0">
                event.Data["listing_mailboxes"] = true
                if len(arguments) &gt;= 2 </span><span class="cov0" title="0">{
                        event.Data["reference"] = arguments[0]
                        event.Data["pattern"] = arguments[1]
                }</span>
                
        case "FETCH":<span class="cov0" title="0">
                if len(arguments) &gt;= 2 </span><span class="cov0" title="0">{
                        event.EventType = EventTypeEmail
                        event.Data["sequence_set"] = arguments[0]
                        event.Data["fetch_items"] = strings.Join(arguments[1:], " ")
                }</span>
                
        case "SEARCH":<span class="cov0" title="0">
                event.Data["search_criteria"] = strings.Join(arguments, " ")</span>
                
        case "STORE":<span class="cov0" title="0">
                if len(arguments) &gt;= 3 </span><span class="cov0" title="0">{
                        event.Data["sequence_set"] = arguments[0]
                        event.Data["store_operation"] = arguments[1]
                        event.Data["flags"] = strings.Join(arguments[2:], " ")
                }</span>
                
        case "COPY":<span class="cov0" title="0">
                if len(arguments) &gt;= 2 </span><span class="cov0" title="0">{
                        event.Data["sequence_set"] = arguments[0]
                        event.Data["destination_mailbox"] = arguments[1]
                }</span>
                
        case "APPEND":<span class="cov0" title="0">
                if len(arguments) &gt;= 1 </span><span class="cov0" title="0">{
                        event.EventType = EventTypeEmail
                        event.Data["destination_mailbox"] = arguments[0]
                }</span>
                
        case "LOGOUT":<span class="cov0" title="0">
                event.EventType = EventTypeDisconnection
                session.State = IMAPStateLogout</span>
        }
        
        <span class="cov0" title="0">return event</span>
}

func (imap *IMAPAnalyzer) processResponse(session *IMAPSession, line string) *ProtocolEvent <span class="cov0" title="0">{
        event := &amp;ProtocolEvent{
                ID:        GenerateEventID("IMAP"),
                Protocol:  "IMAP",
                EventType: EventTypeCommand,
                Response:  line,
                Data: map[string]interface{}{
                        "session_id": session.ID,
                },
        }
        
        // Update last command with response
        if len(session.Commands) &gt; 0 </span><span class="cov0" title="0">{
                lastCmd := &amp;session.Commands[len(session.Commands)-1]
                lastCmd.Response = append(lastCmd.Response, line)
        }</span>
        
        <span class="cov0" title="0">if strings.HasPrefix(line, "* ") </span><span class="cov0" title="0">{
                // Untagged response
                event = imap.processUntaggedResponse(session, line, event)
        }</span> else<span class="cov0" title="0"> {
                // Tagged response
                event = imap.processTaggedResponse(session, line, event)
        }</span>
        
        <span class="cov0" title="0">return event</span>
}

func (imap *IMAPAnalyzer) processUntaggedResponse(session *IMAPSession, line string, event *ProtocolEvent) *ProtocolEvent <span class="cov0" title="0">{
        parts := strings.Fields(line[2:]) // Remove "* "
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return event
        }</span>
        
        <span class="cov0" title="0">responseType := strings.ToUpper(parts[0])
        
        switch responseType </span>{
        case "OK":<span class="cov0" title="0">
                if strings.Contains(line, "CAPABILITY") </span><span class="cov0" title="0">{
                        caps := imap.extractCapabilities(line)
                        session.Capabilities = caps
                        event.Data["capabilities"] = caps
                }</span>
                
        case "CAPABILITY":<span class="cov0" title="0">
                if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                        session.Capabilities = parts[1:]
                        event.Data["capabilities"] = parts[1:]
                }</span>
                
        case "LIST", "LSUB":<span class="cov0" title="0">
                mailbox := imap.parseMailboxResponse(parts)
                if mailbox != nil </span><span class="cov0" title="0">{
                        session.Mailboxes = append(session.Mailboxes, *mailbox)
                        event.Data["mailbox_info"] = map[string]interface{}{
                                "name":       mailbox.Name,
                                "attributes": mailbox.Attributes,
                                "delimiter":  mailbox.Delimiter,
                        }
                }</span>
                
        case "STATUS":<span class="cov0" title="0">
                if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                        mailboxName := parts[1]
                        statusItems := imap.parseStatusResponse(parts[2:])
                        event.Data["mailbox"] = mailboxName
                        event.Data["status"] = statusItems
                }</span>
                
        default:<span class="cov0" title="0">
                // Check if it's a number (message count, EXISTS, RECENT, etc.)
                if num, err := strconv.Atoi(responseType); err == nil </span><span class="cov0" title="0">{
                        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                msgType := strings.ToUpper(parts[1])
                                switch msgType </span>{
                                case "EXISTS":<span class="cov0" title="0">
                                        event.Data["message_count"] = num
                                        if session.SelectedMailbox != nil </span><span class="cov0" title="0">{
                                                session.SelectedMailbox.MessageCount = num
                                        }</span>
                                        
                                case "RECENT":<span class="cov0" title="0">
                                        event.Data["recent_count"] = num
                                        if session.SelectedMailbox != nil </span><span class="cov0" title="0">{
                                                session.SelectedMailbox.RecentCount = num
                                        }</span>
                                        
                                case "FETCH":<span class="cov0" title="0">
                                        event.EventType = EventTypeEmail
                                        fetchData := imap.parseFetchResponse(parts[2:])
                                        if fetchData != nil </span><span class="cov0" title="0">{
                                                event.Data["message_number"] = num
                                                event.Data["fetch_data"] = fetchData
                                                
                                                // Create or update message
                                                message := imap.createOrUpdateMessage(session, num, fetchData)
                                                if message != nil </span><span class="cov0" title="0">{
                                                        event.Data["subject"] = message.Subject
                                                        event.Data["from"] = message.From
                                                        event.Data["size"] = message.Size
                                                }</span>
                                        }
                                }
                        }
                }
        }
        
        <span class="cov0" title="0">return event</span>
}

func (imap *IMAPAnalyzer) processTaggedResponse(session *IMAPSession, line string, event *ProtocolEvent) *ProtocolEvent <span class="cov0" title="0">{
        parts := strings.Fields(line)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return event
        }</span>
        
        <span class="cov0" title="0">tag := parts[0]
        status := strings.ToUpper(parts[1])
        var message string
        if len(parts) &gt; 2 </span><span class="cov0" title="0">{
                message = strings.Join(parts[2:], " ")
        }</span>
        
        <span class="cov0" title="0">event.Data["tag"] = tag
        event.Data["status"] = status
        event.Data["message"] = message
        
        // Update command status
        if len(session.Commands) &gt; 0 </span><span class="cov0" title="0">{
                lastCmd := &amp;session.Commands[len(session.Commands)-1]
                if lastCmd.Tag == tag </span><span class="cov0" title="0">{
                        lastCmd.Status = status
                }</span>
        }
        
        // Handle specific command completions
        <span class="cov0" title="0">if len(session.Commands) &gt; 0 </span><span class="cov0" title="0">{
                lastCmd := session.Commands[len(session.Commands)-1]
                if lastCmd.Tag == tag </span><span class="cov0" title="0">{
                        switch lastCmd.Command </span>{
                        case "LOGIN":<span class="cov0" title="0">
                                if status == "OK" </span><span class="cov0" title="0">{
                                        session.Authenticated = true
                                        session.State = IMAPStateAuthenticated
                                        event.EventType = EventTypeAuthentication
                                        event.Username = session.Username
                                        event.Data["login_successful"] = true
                                }</span> else<span class="cov0" title="0"> {
                                        event.EventType = EventTypeAuthentication
                                        event.Username = session.Username
                                        event.Data["login_failed"] = true
                                }</span>
                                
                        case "SELECT", "EXAMINE":<span class="cov0" title="0">
                                if status == "OK" </span><span class="cov0" title="0">{
                                        // Extract mailbox info from previous untagged responses
                                        if len(lastCmd.Arguments) &gt; 0 </span><span class="cov0" title="0">{
                                                mailboxName := lastCmd.Arguments[0]
                                                mailbox := imap.findOrCreateMailbox(session, mailboxName)
                                                session.SelectedMailbox = mailbox
                                                event.Data["selected_mailbox"] = mailboxName
                                        }</span>
                                }
                                
                        case "STARTTLS":<span class="cov0" title="0">
                                if status == "OK" </span><span class="cov0" title="0">{
                                        session.TLSEnabled = true
                                        event.Data["tls_enabled"] = true
                                }</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return event</span>
}

func (imap *IMAPAnalyzer) extractCapabilities(line string) []string <span class="cov0" title="0">{
        // Extract capabilities from responses like "* OK [CAPABILITY IMAP4rev1 ...]"
        re := regexp.MustCompile(`\[CAPABILITY\s+([^\]]+)\]`)
        matches := re.FindStringSubmatch(line)
        
        if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                return strings.Fields(matches[1])
        }</span>
        
        <span class="cov0" title="0">return []string{}</span>
}

func (imap *IMAPAnalyzer) parseMailboxResponse(parts []string) *IMAPMailbox <span class="cov0" title="0">{
        // LIST/LSUB response format: (attributes) "delimiter" "name"
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Extract attributes (simplified)
        <span class="cov0" title="0">var attributes []string
        if strings.HasPrefix(parts[0], "(") </span><span class="cov0" title="0">{
                attrStr := strings.Join(parts[:1], " ")
                attrStr = strings.Trim(attrStr, "()")
                if attrStr != "" </span><span class="cov0" title="0">{
                        attributes = strings.Fields(attrStr)
                }</span>
        }
        
        // Extract delimiter and name
        <span class="cov0" title="0">delimiter := strings.Trim(parts[len(parts)-2], `"`)
        name := strings.Trim(parts[len(parts)-1], `"`)
        
        return &amp;IMAPMailbox{
                Name:       name,
                Attributes: attributes,
                Delimiter:  delimiter,
        }</span>
}

func (imap *IMAPAnalyzer) parseStatusResponse(parts []string) map[string]interface{} <span class="cov0" title="0">{
        status := make(map[string]interface{})
        
        // STATUS response format: (MESSAGES nn RECENT nn UIDNEXT nn UIDVALIDITY nn UNSEEN nn)
        statusStr := strings.Join(parts, " ")
        statusStr = strings.Trim(statusStr, "()")
        
        statusParts := strings.Fields(statusStr)
        for i := 0; i &lt; len(statusParts)-1; i += 2 </span><span class="cov0" title="0">{
                key := strings.ToLower(statusParts[i])
                if i+1 &lt; len(statusParts) </span><span class="cov0" title="0">{
                        if val, err := strconv.Atoi(statusParts[i+1]); err == nil </span><span class="cov0" title="0">{
                                status[key] = val
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return status</span>
}

func (imap *IMAPAnalyzer) parseFetchResponse(parts []string) map[string]interface{} <span class="cov0" title="0">{
        fetchData := make(map[string]interface{})
        
        // FETCH response is complex, simplified parsing
        responseStr := strings.Join(parts, " ")
        
        // Look for common FETCH items
        if strings.Contains(responseStr, "RFC822.SIZE") </span><span class="cov0" title="0">{
                re := regexp.MustCompile(`RFC822\.SIZE\s+(\d+)`)
                if matches := re.FindStringSubmatch(responseStr); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        if size, err := strconv.ParseInt(matches[1], 10, 64); err == nil </span><span class="cov0" title="0">{
                                fetchData["size"] = size
                        }</span>
                }
        }
        
        <span class="cov0" title="0">if strings.Contains(responseStr, "ENVELOPE") </span><span class="cov0" title="0">{
                fetchData["envelope"] = true
        }</span>
        
        <span class="cov0" title="0">if strings.Contains(responseStr, "BODY") </span><span class="cov0" title="0">{
                fetchData["body"] = true
        }</span>
        
        <span class="cov0" title="0">if strings.Contains(responseStr, "FLAGS") </span><span class="cov0" title="0">{
                re := regexp.MustCompile(`FLAGS\s+\(([^)]+)\)`)
                if matches := re.FindStringSubmatch(responseStr); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        flags := strings.Fields(matches[1])
                        fetchData["flags"] = flags
                }</span>
        }
        
        <span class="cov0" title="0">return fetchData</span>
}

func (imap *IMAPAnalyzer) findOrCreateMailbox(session *IMAPSession, name string) *IMAPMailbox <span class="cov0" title="0">{
        // Find existing mailbox
        for i, mailbox := range session.Mailboxes </span><span class="cov0" title="0">{
                if mailbox.Name == name </span><span class="cov0" title="0">{
                        return &amp;session.Mailboxes[i]
                }</span>
        }
        
        // Create new mailbox
        <span class="cov0" title="0">mailbox := IMAPMailbox{
                Name: name,
        }
        session.Mailboxes = append(session.Mailboxes, mailbox)
        return &amp;session.Mailboxes[len(session.Mailboxes)-1]</span>
}

func (imap *IMAPAnalyzer) createOrUpdateMessage(session *IMAPSession, seqNum int, fetchData map[string]interface{}) *IMAPMessage <span class="cov0" title="0">{
        // Find existing message
        for i, msg := range session.Messages </span><span class="cov0" title="0">{
                if msg.SequenceNum == seqNum </span><span class="cov0" title="0">{
                        // Update existing message
                        if size, ok := fetchData["size"].(int64); ok </span><span class="cov0" title="0">{
                                session.Messages[i].Size = size
                        }</span>
                        <span class="cov0" title="0">if flags, ok := fetchData["flags"].([]string); ok </span><span class="cov0" title="0">{
                                session.Messages[i].Flags = flags
                        }</span>
                        <span class="cov0" title="0">session.Messages[i].Fetched = true
                        return &amp;session.Messages[i]</span>
                }
        }
        
        // Create new message
        <span class="cov0" title="0">message := IMAPMessage{
                SequenceNum: seqNum,
                Mailbox:     "",
                Headers:     make(map[string]string),
                Flags:       make([]string, 0),
                Attachments: make([]EmailAttachment, 0),
                Timestamp:   time.Now(),
                Fetched:     true,
        }
        
        if session.SelectedMailbox != nil </span><span class="cov0" title="0">{
                message.Mailbox = session.SelectedMailbox.Name
        }</span>
        
        <span class="cov0" title="0">if size, ok := fetchData["size"].(int64); ok </span><span class="cov0" title="0">{
                message.Size = size
        }</span>
        <span class="cov0" title="0">if flags, ok := fetchData["flags"].([]string); ok </span><span class="cov0" title="0">{
                message.Flags = flags
        }</span>
        
        <span class="cov0" title="0">session.Messages = append(session.Messages, message)
        return &amp;session.Messages[len(session.Messages)-1]</span>
}

// GetActiveSessions returns all active IMAP sessions
func (imap *IMAPAnalyzer) GetActiveSessions() []*IMAPSession <span class="cov0" title="0">{
        var sessions []*IMAPSession
        cutoff := time.Now().Add(-30 * time.Minute)
        
        for key, session := range imap.sessions </span><span class="cov0" title="0">{
                if session.LastActivity.After(cutoff) </span><span class="cov0" title="0">{
                        sessions = append(sessions, session)
                }</span> else<span class="cov0" title="0"> {
                        delete(imap.sessions, key)
                }</span>
        }
        
        <span class="cov0" title="0">return sessions</span>
}

// GetSessionStats returns IMAP session statistics
func (imap *IMAPAnalyzer) GetSessionStats() map[string]interface{} <span class="cov0" title="0">{
        activeSessions := imap.GetActiveSessions()
        
        stats := map[string]interface{}{
                "active_sessions":        len(activeSessions),
                "authenticated_sessions": 0,
                "total_mailboxes":       0,
                "total_messages":        0,
                "fetched_messages":      0,
                "tls_sessions":          0,
                "total_message_size":    int64(0),
        }
        
        for _, session := range activeSessions </span><span class="cov0" title="0">{
                if session.Authenticated </span><span class="cov0" title="0">{
                        stats["authenticated_sessions"] = stats["authenticated_sessions"].(int) + 1
                }</span>
                
                <span class="cov0" title="0">if session.TLSEnabled </span><span class="cov0" title="0">{
                        stats["tls_sessions"] = stats["tls_sessions"].(int) + 1
                }</span>
                
                <span class="cov0" title="0">stats["total_mailboxes"] = stats["total_mailboxes"].(int) + len(session.Mailboxes)
                stats["total_messages"] = stats["total_messages"].(int) + len(session.Messages)
                
                for _, message := range session.Messages </span><span class="cov0" title="0">{
                        if message.Fetched </span><span class="cov0" title="0">{
                                stats["fetched_messages"] = stats["fetched_messages"].(int) + 1
                        }</span>
                        <span class="cov0" title="0">stats["total_message_size"] = stats["total_message_size"].(int64) + message.Size</span>
                }
        }
        
        <span class="cov0" title="0">return stats</span>
}

// ExtractMessages returns all messages extracted from IMAP sessions
func (imap *IMAPAnalyzer) ExtractMessages() []IMAPMessage <span class="cov0" title="0">{
        var messages []IMAPMessage
        
        for _, session := range imap.sessions </span><span class="cov0" title="0">{
                messages = append(messages, session.Messages...)
        }</span>
        
        <span class="cov0" title="0">return messages</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package protocols

import (
        "bufio"
        "fmt"
        "net"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/tcpassembly/tcpreader"
)

// IRCAnalyzer analyzes IRC protocol traffic including DCC file transfers
type IRCAnalyzer struct {
        BaseAnalyzer
        sessions    map[string]*IRCSession
        dccSessions map[string]*DCCSession
}

// IRCSession represents an active IRC session
type IRCSession struct {
        ID           string
        ClientIP     net.IP
        ServerIP     net.IP
        Port         uint16
        Nickname     string
        Username     string
        Realname     string
        ServerName   string
        Channels     []string
        Messages     []IRCMessage
        Commands     []IRCCommand
        DCCOffers    []DCCOffer
        StartTime    time.Time
        LastActivity time.Time
        Registered   bool
        Away         bool
}

// DCCSession represents a DCC file transfer session
type DCCSession struct {
        ID           string
        Type         DCCType
        ClientIP     net.IP
        ServerIP     net.IP
        Port         uint16
        Filename     string
        FileSize     int64
        Sender       string
        Receiver     string
        BytesTransferred int64
        StartTime    time.Time
        EndTime      time.Time
        Complete     bool
        Active       bool
}

// DCCType represents the type of DCC session
type DCCType string

const (
        DCCTypeSend DCCType = "SEND"
        DCCTypeChat DCCType = "CHAT"
        DCCTypeGet  DCCType = "GET"
)

// IRCMessage represents an IRC message
type IRCMessage struct {
        Prefix    string
        Command   string
        Params    []string
        Trailing  string
        Timestamp time.Time
        Channel   string
        Sender    string
        Message   string
        Type      MessageType
}

// MessageType categorizes IRC messages
type MessageType string

const (
        MessageTypePrivmsg MessageType = "PRIVMSG"
        MessageTypeNotice  MessageType = "NOTICE"
        MessageTypeJoin    MessageType = "JOIN"
        MessageTypePart    MessageType = "PART"
        MessageTypeQuit    MessageType = "QUIT"
        MessageTypeKick    MessageType = "KICK"
        MessageTypeMode    MessageType = "MODE"
        MessageTypeTopic   MessageType = "TOPIC"
        MessageTypeDCC     MessageType = "DCC"
)

// IRCCommand represents an IRC command
type IRCCommand struct {
        Command   string
        Params    []string
        Response  string
        Timestamp time.Time
}

// DCCOffer represents a DCC file transfer offer
type DCCOffer struct {
        ID       string
        Type     DCCType
        Filename string
        IP       net.IP
        Port     uint16
        Size     int64
        Sender   string
        Target   string
        Timestamp time.Time
}

// NewIRCAnalyzer creates a new IRC analyzer
func NewIRCAnalyzer() ProtocolAnalyzer <span class="cov0" title="0">{
        return &amp;IRCAnalyzer{
                BaseAnalyzer: BaseAnalyzer{
                        protocolName: "IRC",
                        ports:        []uint16{6667, 6668, 6669, 6697, 7000}, // Standard IRC ports
                },
                sessions:    make(map[string]*IRCSession),
                dccSessions: make(map[string]*DCCSession),
        }
}</span>

// AnalyzeStream analyzes an IRC stream
func (irc *IRCAnalyzer) AnalyzeStream(flow gopacket.Flow, reader *tcpreader.ReaderStream) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        buf := bufio.NewReader(reader)
        
        // Create session key
        sessionKey := fmt.Sprintf("%s-&gt;%s", flow.Src().String(), flow.Dst().String())
        
        // Check if this might be a DCC session
        srcPort := uint16(flow.Src().FastHash())
        dstPort := uint16(flow.Dst().FastHash())
        
        if irc.isDCCPort(srcPort) || irc.isDCCPort(dstPort) </span><span class="cov0" title="0">{
                // Handle DCC session
                events = append(events, irc.analyzeDCCStream(sessionKey, flow, buf)...)
        }</span> else<span class="cov0" title="0"> {
                // Handle regular IRC session
                session := irc.getOrCreateSession(sessionKey, flow)
                events = append(events, irc.analyzeIRCStream(session, buf)...)
        }</span>
        
        <span class="cov0" title="0">return events</span>
}

// IsProtocolTraffic determines if data is IRC traffic
func (irc *IRCAnalyzer) IsProtocolTraffic(data []byte) bool <span class="cov0" title="0">{
        dataStr := string(data)
        
        // Check for IRC server responses
        if strings.HasPrefix(dataStr, ":") &amp;&amp; strings.Contains(dataStr, " ") </span><span class="cov0" title="0">{
                parts := strings.Fields(dataStr)
                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        // Check for numeric IRC responses (001-999)
                        if code, err := strconv.Atoi(parts[1]); err == nil &amp;&amp; code &gt;= 1 &amp;&amp; code &lt;= 999 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        
        // Check for common IRC commands
        <span class="cov0" title="0">ircCommands := []string{"NICK ", "USER ", "JOIN ", "PART ", "PRIVMSG ", "NOTICE ", "QUIT", "PING ", "PONG ", "MODE ", "TOPIC ", "KICK ", "WHO ", "WHOIS "}
        dataUpper := strings.ToUpper(dataStr)
        
        for _, cmd := range ircCommands </span><span class="cov0" title="0">{
                if strings.HasPrefix(dataUpper, cmd) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        // Check for DCC offers
        <span class="cov0" title="0">if strings.Contains(dataUpper, "DCC SEND") || strings.Contains(dataUpper, "DCC CHAT") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

func (irc *IRCAnalyzer) getOrCreateSession(sessionKey string, flow gopacket.Flow) *IRCSession <span class="cov0" title="0">{
        if session, exists := irc.sessions[sessionKey]; exists </span><span class="cov0" title="0">{
                session.LastActivity = time.Now()
                return session
        }</span>
        
        <span class="cov0" title="0">session := &amp;IRCSession{
                ID:           fmt.Sprintf("irc_%d", time.Now().UnixNano()),
                ClientIP:     net.ParseIP(flow.Src().String()),
                ServerIP:     net.ParseIP(flow.Dst().String()),
                Port:         uint16(flow.Dst().FastHash()),
                Channels:     make([]string, 0),
                Messages:     make([]IRCMessage, 0),
                Commands:     make([]IRCCommand, 0),
                DCCOffers:    make([]DCCOffer, 0),
                StartTime:    time.Now(),
                LastActivity: time.Now(),
        }
        
        irc.sessions[sessionKey] = session
        return session</span>
}

func (irc *IRCAnalyzer) analyzeIRCStream(session *IRCSession, reader *bufio.Reader) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        
        for </span><span class="cov0" title="0">{
                line, err := ReadLine(reader)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Parse IRC message
                <span class="cov0" title="0">message := irc.parseIRCMessage(line)
                if message != nil </span><span class="cov0" title="0">{
                        session.Messages = append(session.Messages, *message)
                        
                        event := irc.processIRCMessage(session, message)
                        if event != nil </span><span class="cov0" title="0">{
                                events = append(events, *event)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return events</span>
}

func (irc *IRCAnalyzer) analyzeDCCStream(sessionKey string, flow gopacket.Flow, reader *bufio.Reader) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        
        // Create or find DCC session
        dccSession := irc.getOrCreateDCCSession(sessionKey, flow)
        
        // Count bytes transferred
        data := make([]byte, 4096)
        totalBytes := 0
        
        for </span><span class="cov0" title="0">{
                n, err := reader.Read(data)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">totalBytes += n
                dccSession.BytesTransferred += int64(n)</span>
        }
        
        <span class="cov0" title="0">if totalBytes &gt; 0 </span><span class="cov0" title="0">{
                event := ProtocolEvent{
                        ID:        GenerateEventID("IRC"),
                        Protocol:  "IRC",
                        EventType: EventTypeFileTransfer,
                        Data: map[string]interface{}{
                                "dcc_session_id":   dccSession.ID,
                                "dcc_type":         string(dccSession.Type),
                                "filename":         dccSession.Filename,
                                "bytes_transferred": totalBytes,
                                "total_bytes":      dccSession.BytesTransferred,
                                "sender":           dccSession.Sender,
                                "receiver":         dccSession.Receiver,
                        },
                }
                
                if dccSession.Filename != "" </span><span class="cov0" title="0">{
                        event.Filename = dccSession.Filename
                }</span>
                
                <span class="cov0" title="0">events = append(events, event)
                
                // Check if transfer is complete
                if dccSession.FileSize &gt; 0 &amp;&amp; dccSession.BytesTransferred &gt;= dccSession.FileSize </span><span class="cov0" title="0">{
                        dccSession.Complete = true
                        dccSession.EndTime = time.Now()
                }</span>
        }
        
        <span class="cov0" title="0">return events</span>
}

func (irc *IRCAnalyzer) parseIRCMessage(line string) *IRCMessage <span class="cov0" title="0">{
        message := &amp;IRCMessage{
                Timestamp: time.Now(),
        }
        
        // IRC message format: [':' prefix SPACE] command [params] [':' trailing]
        remaining := line
        
        // Extract prefix if present
        if strings.HasPrefix(remaining, ":") </span><span class="cov0" title="0">{
                parts := strings.SplitN(remaining[1:], " ", 2)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        message.Prefix = parts[0]
                        remaining = parts[1]
                }</span>
        }
        
        // Extract command and parameters
        <span class="cov0" title="0">parts := strings.Split(remaining, " :")
        cmdParts := strings.Fields(parts[0])
        
        if len(cmdParts) &gt; 0 </span><span class="cov0" title="0">{
                message.Command = strings.ToUpper(cmdParts[0])
                if len(cmdParts) &gt; 1 </span><span class="cov0" title="0">{
                        message.Params = cmdParts[1:]
                }</span>
        }
        
        // Extract trailing parameter
        <span class="cov0" title="0">if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                message.Trailing = strings.Join(parts[1:], " :")
        }</span>
        
        // Set message type
        <span class="cov0" title="0">message.Type = MessageType(message.Command)
        
        // Extract sender from prefix
        if message.Prefix != "" </span><span class="cov0" title="0">{
                if strings.Contains(message.Prefix, "!") </span><span class="cov0" title="0">{
                        message.Sender = strings.Split(message.Prefix, "!")[0]
                }</span>
        }
        
        // For PRIVMSG and NOTICE, extract channel and message
        <span class="cov0" title="0">if message.Command == "PRIVMSG" || message.Command == "NOTICE" </span><span class="cov0" title="0">{
                if len(message.Params) &gt; 0 </span><span class="cov0" title="0">{
                        message.Channel = message.Params[0]
                        message.Message = message.Trailing
                }</span>
        }
        
        <span class="cov0" title="0">return message</span>
}

func (irc *IRCAnalyzer) processIRCMessage(session *IRCSession, message *IRCMessage) *ProtocolEvent <span class="cov0" title="0">{
        event := &amp;ProtocolEvent{
                ID:        GenerateEventID("IRC"),
                Protocol:  "IRC",
                EventType: EventTypeCommand,
                Command:   message.Command,
                Data: map[string]interface{}{
                        "session_id": session.ID,
                        "command":    message.Command,
                        "sender":     message.Sender,
                },
        }
        
        switch message.Command </span>{
        case "NICK":<span class="cov0" title="0">
                if len(message.Params) &gt; 0 </span><span class="cov0" title="0">{
                        session.Nickname = message.Params[0]
                        event.Data["nickname"] = message.Params[0]
                }</span>
                
        case "USER":<span class="cov0" title="0">
                if len(message.Params) &gt;= 4 </span><span class="cov0" title="0">{
                        session.Username = message.Params[0]
                        session.Realname = message.Trailing
                        event.Data["username"] = session.Username
                        event.Data["realname"] = session.Realname
                }</span>
                
        case "JOIN":<span class="cov0" title="0">
                channel := message.Trailing
                if channel == "" &amp;&amp; len(message.Params) &gt; 0 </span><span class="cov0" title="0">{
                        channel = message.Params[0]
                }</span>
                <span class="cov0" title="0">if channel != "" </span><span class="cov0" title="0">{
                        session.Channels = append(session.Channels, channel)
                        event.Data["channel"] = channel
                }</span>
                
        case "PART":<span class="cov0" title="0">
                if len(message.Params) &gt; 0 </span><span class="cov0" title="0">{
                        channel := message.Params[0]
                        // Remove channel from session
                        for i, ch := range session.Channels </span><span class="cov0" title="0">{
                                if ch == channel </span><span class="cov0" title="0">{
                                        session.Channels = append(session.Channels[:i], session.Channels[i+1:]...)
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">event.Data["channel"] = channel</span>
                }
                
        case "PRIVMSG":<span class="cov0" title="0">
                event.Data["channel"] = message.Channel
                event.Data["message"] = message.Message
                
                // Check for DCC offers
                if strings.Contains(strings.ToUpper(message.Message), "DCC") </span><span class="cov0" title="0">{
                        dccOffer := irc.parseDCCOffer(message)
                        if dccOffer != nil </span><span class="cov0" title="0">{
                                session.DCCOffers = append(session.DCCOffers, *dccOffer)
                                event.EventType = EventTypeFileTransfer
                                event.Data["dcc_offer"] = map[string]interface{}{
                                        "type":     string(dccOffer.Type),
                                        "filename": dccOffer.Filename,
                                        "size":     dccOffer.Size,
                                        "ip":       dccOffer.IP.String(),
                                        "port":     dccOffer.Port,
                                }
                                event.Filename = dccOffer.Filename
                                event.FileSize = dccOffer.Size
                        }</span>
                }
                
        case "QUIT":<span class="cov0" title="0">
                event.EventType = EventTypeDisconnection
                event.Data["quit_message"] = message.Trailing</span>
                
        case "001":<span class="cov0" title="0"> // RPL_WELCOME
                session.Registered = true
                session.ServerName = irc.extractServerName(message.Prefix)
                event.EventType = EventTypeConnection
                event.Data["registered"] = true
                event.Data["server_name"] = session.ServerName</span>
                
        case "PING":<span class="cov0" title="0">
                event.Data["ping_data"] = message.Trailing</span>
                
        case "PONG":<span class="cov0" title="0">
                event.Data["pong_data"] = message.Trailing</span>
        }
        
        <span class="cov0" title="0">return event</span>
}

func (irc *IRCAnalyzer) parseDCCOffer(message *IRCMessage) *DCCOffer <span class="cov0" title="0">{
        // DCC SEND filename ip port [size]
        // DCC CHAT chat ip port
        dccText := strings.ToUpper(message.Message)
        
        if !strings.Contains(dccText, "DCC") </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">re := regexp.MustCompile(`DCC\s+(SEND|CHAT)\s+(\S+)\s+(\d+)\s+(\d+)(?:\s+(\d+))?`)
        matches := re.FindStringSubmatch(dccText)
        
        if len(matches) &lt; 5 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">dccType := DCCType(matches[1])
        filename := matches[2]
        
        // Convert IP from decimal to dotted decimal
        ipNum, err := strconv.ParseUint(matches[3], 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">ip := make(net.IP, 4)
        ip[0] = byte(ipNum &gt;&gt; 24)
        ip[1] = byte(ipNum &gt;&gt; 16)
        ip[2] = byte(ipNum &gt;&gt; 8)
        ip[3] = byte(ipNum)
        
        port, err := strconv.ParseUint(matches[4], 10, 16)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">var size int64
        if len(matches) &gt; 5 &amp;&amp; matches[5] != "" </span><span class="cov0" title="0">{
                size, _ = strconv.ParseInt(matches[5], 10, 64)
        }</span>
        
        <span class="cov0" title="0">offer := &amp;DCCOffer{
                ID:        fmt.Sprintf("dcc_%d", time.Now().UnixNano()),
                Type:      dccType,
                Filename:  filename,
                IP:        ip,
                Port:      uint16(port),
                Size:      size,
                Sender:    message.Sender,
                Timestamp: time.Now(),
        }
        
        // Extract target from channel or direct message
        if message.Channel != "" &amp;&amp; !strings.HasPrefix(message.Channel, "#") </span><span class="cov0" title="0">{
                offer.Target = message.Channel
        }</span>
        
        <span class="cov0" title="0">return offer</span>
}

func (irc *IRCAnalyzer) getOrCreateDCCSession(sessionKey string, flow gopacket.Flow) *DCCSession <span class="cov0" title="0">{
        if session, exists := irc.dccSessions[sessionKey]; exists </span><span class="cov0" title="0">{
                return session
        }</span>
        
        <span class="cov0" title="0">session := &amp;DCCSession{
                ID:        fmt.Sprintf("dcc_%d", time.Now().UnixNano()),
                Type:      DCCTypeSend, // Default assumption
                ClientIP:  net.ParseIP(flow.Src().String()),
                ServerIP:  net.ParseIP(flow.Dst().String()),
                Port:      uint16(flow.Dst().FastHash()),
                StartTime: time.Now(),
                Active:    true,
        }
        
        // Try to match with existing DCC offers
        for _, ircSession := range irc.sessions </span><span class="cov0" title="0">{
                for _, offer := range ircSession.DCCOffers </span><span class="cov0" title="0">{
                        if offer.Port == session.Port </span><span class="cov0" title="0">{
                                session.Type = offer.Type
                                session.Filename = offer.Filename
                                session.FileSize = offer.Size
                                session.Sender = offer.Sender
                                session.Receiver = offer.Target
                                break</span>
                        }
                }
        }
        
        <span class="cov0" title="0">irc.dccSessions[sessionKey] = session
        return session</span>
}

func (irc *IRCAnalyzer) isDCCPort(port uint16) bool <span class="cov0" title="0">{
        // DCC typically uses high ports (1024-65535)
        // This is a heuristic - in practice we'd match against known DCC offers
        return port &gt;= 1024
}</span>

func (irc *IRCAnalyzer) extractServerName(prefix string) string <span class="cov0" title="0">{
        if prefix == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        // Server names typically don't contain ! or @
        <span class="cov0" title="0">if !strings.Contains(prefix, "!") &amp;&amp; !strings.Contains(prefix, "@") </span><span class="cov0" title="0">{
                return prefix
        }</span>
        
        <span class="cov0" title="0">return ""</span>
}

// GetActiveSessions returns all active IRC sessions
func (irc *IRCAnalyzer) GetActiveSessions() []*IRCSession <span class="cov0" title="0">{
        var sessions []*IRCSession
        cutoff := time.Now().Add(-30 * time.Minute)
        
        for key, session := range irc.sessions </span><span class="cov0" title="0">{
                if session.LastActivity.After(cutoff) </span><span class="cov0" title="0">{
                        sessions = append(sessions, session)
                }</span> else<span class="cov0" title="0"> {
                        delete(irc.sessions, key)
                }</span>
        }
        
        <span class="cov0" title="0">return sessions</span>
}

// GetActiveDCCSessions returns all active DCC sessions
func (irc *IRCAnalyzer) GetActiveDCCSessions() []*DCCSession <span class="cov0" title="0">{
        var sessions []*DCCSession
        cutoff := time.Now().Add(-2 * time.Hour) // DCC transfers can be longer
        
        for key, session := range irc.dccSessions </span><span class="cov0" title="0">{
                if session.StartTime.After(cutoff) &amp;&amp; session.Active </span><span class="cov0" title="0">{
                        sessions = append(sessions, session)
                }</span> else<span class="cov0" title="0"> if session.Complete || session.StartTime.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(irc.dccSessions, key)
                }</span>
        }
        
        <span class="cov0" title="0">return sessions</span>
}

// GetSessionStats returns IRC session statistics
func (irc *IRCAnalyzer) GetSessionStats() map[string]interface{} <span class="cov0" title="0">{
        activeSessions := irc.GetActiveSessions()
        activeDCCSessions := irc.GetActiveDCCSessions()
        
        stats := map[string]interface{}{
                "active_sessions":         len(activeSessions),
                "registered_sessions":     0,
                "active_dcc_sessions":     len(activeDCCSessions),
                "total_channels":         0,
                "total_dcc_offers":       0,
                "completed_dcc_transfers": 0,
                "total_dcc_bytes":        int64(0),
        }
        
        for _, session := range activeSessions </span><span class="cov0" title="0">{
                if session.Registered </span><span class="cov0" title="0">{
                        stats["registered_sessions"] = stats["registered_sessions"].(int) + 1
                }</span>
                <span class="cov0" title="0">stats["total_channels"] = stats["total_channels"].(int) + len(session.Channels)
                stats["total_dcc_offers"] = stats["total_dcc_offers"].(int) + len(session.DCCOffers)</span>
        }
        
        <span class="cov0" title="0">for _, dccSession := range activeDCCSessions </span><span class="cov0" title="0">{
                if dccSession.Complete </span><span class="cov0" title="0">{
                        stats["completed_dcc_transfers"] = stats["completed_dcc_transfers"].(int) + 1
                }</span>
                <span class="cov0" title="0">stats["total_dcc_bytes"] = stats["total_dcc_bytes"].(int64) + dccSession.BytesTransferred</span>
        }
        
        <span class="cov0" title="0">return stats</span>
}

// GetDCCTransfers returns all DCC file transfers
func (irc *IRCAnalyzer) GetDCCTransfers() []DCCSession <span class="cov0" title="0">{
        var transfers []DCCSession
        
        for _, session := range irc.dccSessions </span><span class="cov0" title="0">{
                if session.Type == DCCTypeSend &amp;&amp; session.Filename != "" </span><span class="cov0" title="0">{
                        transfers = append(transfers, *session)
                }</span>
        }
        
        <span class="cov0" title="0">return transfers</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package protocols

import (
        "bufio"
        "fmt"
        "net"
        "net/mail"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/tcpassembly/tcpreader"
)

// POP3Analyzer analyzes POP3 protocol traffic
type POP3Analyzer struct {
        BaseAnalyzer
        sessions map[string]*POP3Session
}

// POP3Session represents an active POP3 session
type POP3Session struct {
        ID               string
        ClientIP         net.IP
        ServerIP         net.IP
        Port             uint16
        Username         string
        AuthMethod       string
        Commands         []POP3Command
        Emails           []EmailMessage
        Statistics       POP3Stats
        StartTime        time.Time
        LastActivity     time.Time
        Authenticated    bool
        TransactionState bool
        UpdateState      bool
        CurrentEmail     *EmailMessage
}

// POP3Command represents a POP3 command
type POP3Command struct {
        Command   string
        Arguments []string
        Response  string
        Success   bool
        Timestamp time.Time
}

// EmailMessage represents an email message retrieved via POP3
type EmailMessage struct {
        ID          string
        MessageID   string
        Subject     string
        From        string
        To          []string
        CC          []string
        BCC         []string
        Date        time.Time
        Size        int64
        Headers     map[string]string
        Body        string
        Attachments []EmailAttachment
        Retrieved   bool
        Deleted     bool
        Timestamp   time.Time
}

// EmailAttachment represents an email attachment
type EmailAttachment struct {
        Filename    string
        ContentType string
        Size        int64
        Content     []byte
        Encoding    string
}

// POP3Stats represents POP3 session statistics
type POP3Stats struct {
        MessageCount   int
        TotalSize      int64
        RetrievedCount int
        DeletedCount   int
        BytesReceived  int64
}

// NewPOP3Analyzer creates a new POP3 analyzer
func NewPOP3Analyzer() ProtocolAnalyzer <span class="cov8" title="1">{
        return &amp;POP3Analyzer{
                BaseAnalyzer: BaseAnalyzer{
                        protocolName: "POP3",
                        ports:        []uint16{110, 995}, // POP3 and POP3S
                },
                sessions: make(map[string]*POP3Session),
        }
}</span>

// AnalyzeStream analyzes a POP3 stream
func (pop3 *POP3Analyzer) AnalyzeStream(flow gopacket.Flow, reader *tcpreader.ReaderStream) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        buf := bufio.NewReader(reader)
        
        // Create session key
        sessionKey := fmt.Sprintf("%s-&gt;%s", flow.Src().String(), flow.Dst().String())
        
        // Get or create session
        session := pop3.getOrCreateSession(sessionKey, flow)
        
        // Analyze POP3 protocol
        events = append(events, pop3.analyzePOP3Stream(session, buf)...)
        
        return events
}</span>

// IsProtocolTraffic determines if data is POP3 traffic
func (pop3 *POP3Analyzer) IsProtocolTraffic(data []byte) bool <span class="cov0" title="0">{
        dataStr := strings.ToUpper(string(data))
        
        // Check for POP3 server greeting
        if strings.HasPrefix(dataStr, "+OK ") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Check for common POP3 commands
        <span class="cov0" title="0">pop3Commands := []string{"USER ", "PASS ", "STAT", "LIST", "RETR ", "DELE ", "NOOP", "RSET", "QUIT", "TOP ", "UIDL"}
        for _, cmd := range pop3Commands </span><span class="cov0" title="0">{
                if strings.HasPrefix(dataStr, cmd) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        // Check for POP3 error responses
        <span class="cov0" title="0">if strings.HasPrefix(dataStr, "-ERR ") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

func (pop3 *POP3Analyzer) getOrCreateSession(sessionKey string, flow gopacket.Flow) *POP3Session <span class="cov0" title="0">{
        if session, exists := pop3.sessions[sessionKey]; exists </span><span class="cov0" title="0">{
                session.LastActivity = time.Now()
                return session
        }</span>
        
        <span class="cov0" title="0">session := &amp;POP3Session{
                ID:           fmt.Sprintf("pop3_%d", time.Now().UnixNano()),
                ClientIP:     net.ParseIP(flow.Src().String()),
                ServerIP:     net.ParseIP(flow.Dst().String()),
                Port:         uint16(flow.Dst().FastHash()),
                Commands:     make([]POP3Command, 0),
                Emails:       make([]EmailMessage, 0),
                StartTime:    time.Now(),
                LastActivity: time.Now(),
                Statistics:   POP3Stats{},
        }
        
        pop3.sessions[sessionKey] = session
        return session</span>
}

func (pop3 *POP3Analyzer) analyzePOP3Stream(session *POP3Session, reader *bufio.Reader) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        var isMultilineResponse bool
        var multilineData []string
        var currentCommand *POP3Command
        
        for </span><span class="cov0" title="0">{
                line, err := ReadLine(reader)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Handle multi-line responses
                <span class="cov0" title="0">if isMultilineResponse </span><span class="cov0" title="0">{
                        if line == "." </span><span class="cov0" title="0">{
                                // End of multi-line response
                                isMultilineResponse = false
                                
                                // Process collected data
                                event := pop3.processMultilineResponse(session, currentCommand, multilineData)
                                if event != nil </span><span class="cov0" title="0">{
                                        events = append(events, *event)
                                }</span>
                                
                                <span class="cov0" title="0">multilineData = []string{}
                                currentCommand = nil</span>
                        } else<span class="cov0" title="0"> {
                                // Collect multi-line data
                                multilineData = append(multilineData, line)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                
                // Determine if this is a command or response
                <span class="cov0" title="0">if pop3.isCommand(line) </span><span class="cov0" title="0">{
                        event := pop3.processCommand(session, line)
                        if event != nil </span><span class="cov0" title="0">{
                                events = append(events, *event)
                                
                                // Check if this command expects a multi-line response
                                command := strings.Fields(strings.ToUpper(line))[0]
                                if command == "RETR" || command == "TOP" || command == "LIST" || command == "UIDL" </span><span class="cov0" title="0">{
                                        currentCommand = &amp;session.Commands[len(session.Commands)-1]
                                }</span>
                        }
                } else<span class="cov0" title="0"> if pop3.isResponse(line) </span><span class="cov0" title="0">{
                        event := pop3.processResponse(session, line)
                        if event != nil </span><span class="cov0" title="0">{
                                events = append(events, *event)
                                
                                // Check if response indicates start of multi-line data
                                if strings.HasPrefix(line, "+OK") &amp;&amp; currentCommand != nil </span><span class="cov0" title="0">{
                                        cmd := strings.ToUpper(currentCommand.Command)
                                        if cmd == "RETR" || cmd == "TOP" || cmd == "LIST" || cmd == "UIDL" </span><span class="cov0" title="0">{
                                                isMultilineResponse = true
                                        }</span>
                                }
                        }
                }
        }
        
        <span class="cov0" title="0">return events</span>
}

func (pop3 *POP3Analyzer) isCommand(line string) bool <span class="cov0" title="0">{
        // POP3 commands are typically 3-4 characters
        parts := strings.Fields(line)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">command := strings.ToUpper(parts[0])
        pop3Commands := []string{"USER", "PASS", "STAT", "LIST", "RETR", "DELE", "NOOP", "RSET", "QUIT", "TOP", "UIDL", "APOP", "AUTH"}
        
        for _, cmd := range pop3Commands </span><span class="cov0" title="0">{
                if command == cmd </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

func (pop3 *POP3Analyzer) isResponse(line string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(line, "+OK") || strings.HasPrefix(line, "-ERR")
}</span>

func (pop3 *POP3Analyzer) processCommand(session *POP3Session, line string) *ProtocolEvent <span class="cov0" title="0">{
        parts := strings.Fields(line)
        command := strings.ToUpper(parts[0])
        var arguments []string
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                arguments = parts[1:]
        }</span>
        
        // Add to session commands
        <span class="cov0" title="0">pop3Cmd := POP3Command{
                Command:   command,
                Arguments: arguments,
                Timestamp: time.Now(),
        }
        session.Commands = append(session.Commands, pop3Cmd)
        
        // Create event
        event := &amp;ProtocolEvent{
                ID:        GenerateEventID("POP3"),
                Protocol:  "POP3",
                EventType: EventTypeCommand,
                Command:   line,
                Data: map[string]interface{}{
                        "session_id": session.ID,
                        "command":    command,
                        "arguments":  arguments,
                },
        }
        
        // Handle specific commands
        switch command </span>{
        case "USER":<span class="cov0" title="0">
                if len(arguments) &gt; 0 </span><span class="cov0" title="0">{
                        session.Username = arguments[0]
                        event.Username = arguments[0]
                        event.EventType = EventTypeAuthentication
                }</span>
                
        case "PASS":<span class="cov0" title="0">
                event.EventType = EventTypeAuthentication
                event.Data["password_provided"] = true</span>
                
        case "APOP":<span class="cov0" title="0">
                if len(arguments) &gt; 0 </span><span class="cov0" title="0">{
                        session.Username = arguments[0]
                        session.AuthMethod = "APOP"
                        event.Username = arguments[0]
                        event.EventType = EventTypeAuthentication
                        event.Data["auth_method"] = "APOP"
                }</span>
                
        case "STAT":<span class="cov0" title="0">
                event.Data["requesting_stats"] = true</span>
                
        case "LIST":<span class="cov0" title="0">
                event.Data["requesting_list"] = true
                if len(arguments) &gt; 0 </span><span class="cov0" title="0">{
                        event.Data["message_number"] = arguments[0]
                }</span>
                
        case "RETR":<span class="cov0" title="0">
                if len(arguments) &gt; 0 </span><span class="cov0" title="0">{
                        event.EventType = EventTypeEmail
                        event.Data["retrieving_message"] = arguments[0]
                }</span>
                
        case "DELE":<span class="cov0" title="0">
                if len(arguments) &gt; 0 </span><span class="cov0" title="0">{
                        event.Data["deleting_message"] = arguments[0]
                }</span>
                
        case "TOP":<span class="cov0" title="0">
                if len(arguments) &gt;= 2 </span><span class="cov0" title="0">{
                        event.EventType = EventTypeEmail
                        event.Data["message_number"] = arguments[0]
                        event.Data["lines_requested"] = arguments[1]
                }</span>
                
        case "QUIT":<span class="cov0" title="0">
                event.EventType = EventTypeDisconnection
                session.UpdateState = true</span>
        }
        
        <span class="cov0" title="0">return event</span>
}

func (pop3 *POP3Analyzer) processResponse(session *POP3Session, line string) *ProtocolEvent <span class="cov0" title="0">{
        success := strings.HasPrefix(line, "+OK")
        message := ""
        if len(line) &gt; 4 </span><span class="cov0" title="0">{
                message = line[4:]
        }</span>
        
        // Update last command with response
        <span class="cov0" title="0">if len(session.Commands) &gt; 0 </span><span class="cov0" title="0">{
                lastCmd := &amp;session.Commands[len(session.Commands)-1]
                lastCmd.Response = line
                lastCmd.Success = success
        }</span>
        
        <span class="cov0" title="0">event := &amp;ProtocolEvent{
                ID:        GenerateEventID("POP3"),
                Protocol:  "POP3",
                EventType: EventTypeCommand,
                Response:  line,
                Status:    fmt.Sprintf("%t", success),
                Data: map[string]interface{}{
                        "session_id": session.ID,
                        "success":    success,
                        "message":    message,
                },
        }
        
        // Handle specific responses
        if success </span><span class="cov0" title="0">{
                if len(session.Commands) &gt; 0 </span><span class="cov0" title="0">{
                        lastCmd := session.Commands[len(session.Commands)-1]
                        
                        switch lastCmd.Command </span>{
                        case "USER":<span class="cov0" title="0">
                                event.EventType = EventTypeAuthentication
                                event.Username = session.Username</span>
                                
                        case "PASS", "APOP":<span class="cov0" title="0">
                                if success </span><span class="cov0" title="0">{
                                        session.Authenticated = true
                                        session.TransactionState = true
                                        event.EventType = EventTypeAuthentication
                                        event.Username = session.Username
                                        event.Data["login_successful"] = true
                                }</span>
                                
                        case "STAT":<span class="cov0" title="0">
                                // Parse message count and total size
                                stats := pop3.parseStatResponse(message)
                                if stats != nil </span><span class="cov0" title="0">{
                                        session.Statistics.MessageCount = stats.MessageCount
                                        session.Statistics.TotalSize = stats.TotalSize
                                        event.Data["message_count"] = stats.MessageCount
                                        event.Data["total_size"] = stats.TotalSize
                                }</span>
                                
                        case "QUIT":<span class="cov0" title="0">
                                event.EventType = EventTypeDisconnection</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // Error response
                event.EventType = EventTypeError
                
                if len(session.Commands) &gt; 0 </span><span class="cov0" title="0">{
                        lastCmd := session.Commands[len(session.Commands)-1]
                        if lastCmd.Command == "PASS" || lastCmd.Command == "APOP" </span><span class="cov0" title="0">{
                                event.EventType = EventTypeAuthentication
                                event.Username = session.Username
                                event.Data["login_failed"] = true
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return event</span>
}

func (pop3 *POP3Analyzer) processMultilineResponse(session *POP3Session, command *POP3Command, data []string) *ProtocolEvent <span class="cov0" title="0">{
        if command == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">event := &amp;ProtocolEvent{
                ID:        GenerateEventID("POP3"),
                Protocol:  "POP3",
                EventType: EventTypeEmail,
                Data: map[string]interface{}{
                        "session_id": session.ID,
                        "command":    command.Command,
                        "data_lines": len(data),
                },
        }
        
        switch command.Command </span>{
        case "RETR":<span class="cov0" title="0">
                // Full email retrieval
                email := pop3.parseEmailMessage(data)
                if email != nil </span><span class="cov0" title="0">{
                        email.Retrieved = true
                        session.Emails = append(session.Emails, *email)
                        session.Statistics.RetrievedCount++
                        
                        event.Data["email_id"] = email.ID
                        event.Data["subject"] = email.Subject
                        event.Data["from"] = email.From
                        event.Data["size"] = email.Size
                        event.Data["attachments"] = len(email.Attachments)
                }</span>
                
        case "TOP":<span class="cov0" title="0">
                // Email headers only
                email := pop3.parseEmailHeaders(data)
                if email != nil </span><span class="cov0" title="0">{
                        event.Data["subject"] = email.Subject
                        event.Data["from"] = email.From
                        event.Data["headers_only"] = true
                }</span>
                
        case "LIST":<span class="cov0" title="0">
                // Message list
                messages := pop3.parseMessageList(data)
                event.Data["messages"] = len(messages)</span>
                
        case "UIDL":<span class="cov0" title="0">
                // Unique ID list
                uidList := pop3.parseUIDList(data)
                event.Data["unique_ids"] = len(uidList)</span>
        }
        
        <span class="cov0" title="0">return event</span>
}

func (pop3 *POP3Analyzer) parseStatResponse(message string) *POP3Stats <span class="cov0" title="0">{
        // STAT response format: "+OK nn mm" where nn is count and mm is size
        parts := strings.Fields(message)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">count, err1 := strconv.Atoi(parts[0])
        size, err2 := strconv.ParseInt(parts[1], 10, 64)
        
        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">return &amp;POP3Stats{
                MessageCount: count,
                TotalSize:    size,
        }</span>
}

func (pop3 *POP3Analyzer) parseEmailMessage(lines []string) *EmailMessage <span class="cov0" title="0">{
        if len(lines) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Join all lines to create full message
        <span class="cov0" title="0">fullMessage := strings.Join(lines, "\n")
        
        // Parse email headers and body
        email := &amp;EmailMessage{
                ID:          fmt.Sprintf("email_%d", time.Now().UnixNano()),
                Headers:     make(map[string]string),
                Timestamp:   time.Now(),
                Attachments: make([]EmailAttachment, 0),
        }
        
        // Split headers and body
        parts := strings.SplitN(fullMessage, "\n\n", 2)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return email
        }</span>
        
        <span class="cov0" title="0">headerLines := strings.Split(parts[0], "\n")
        email.Body = parts[1]
        email.Size = int64(len(fullMessage))
        
        // Parse headers
        for _, line := range headerLines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Handle folded headers
                <span class="cov0" title="0">if strings.HasPrefix(line, " ") || strings.HasPrefix(line, "\t") </span><span class="cov0" title="0">{
                        continue</span> // Skip folded lines for now
                }
                
                <span class="cov0" title="0">headerParts := strings.SplitN(line, ":", 2)
                if len(headerParts) == 2 </span><span class="cov0" title="0">{
                        key := strings.ToLower(strings.TrimSpace(headerParts[0]))
                        value := strings.TrimSpace(headerParts[1])
                        email.Headers[key] = value
                        
                        // Extract common fields
                        switch key </span>{
                        case "subject":<span class="cov0" title="0">
                                email.Subject = value</span>
                        case "from":<span class="cov0" title="0">
                                email.From = value</span>
                        case "to":<span class="cov0" title="0">
                                email.To = pop3.parseAddressList(value)</span>
                        case "cc":<span class="cov0" title="0">
                                email.CC = pop3.parseAddressList(value)</span>
                        case "bcc":<span class="cov0" title="0">
                                email.BCC = pop3.parseAddressList(value)</span>
                        case "message-id":<span class="cov0" title="0">
                                email.MessageID = value</span>
                        case "date":<span class="cov0" title="0">
                                if date, err := mail.ParseDate(value); err == nil </span><span class="cov0" title="0">{
                                        email.Date = date
                                }</span>
                        }
                }
        }
        
        // Extract attachments (simplified)
        <span class="cov0" title="0">email.Attachments = pop3.extractAttachments(email.Body)
        
        return email</span>
}

func (pop3 *POP3Analyzer) parseEmailHeaders(lines []string) *EmailMessage <span class="cov0" title="0">{
        email := &amp;EmailMessage{
                ID:        fmt.Sprintf("header_%d", time.Now().UnixNano()),
                Headers:   make(map[string]string),
                Timestamp: time.Now(),
        }
        
        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">headerParts := strings.SplitN(line, ":", 2)
                if len(headerParts) == 2 </span><span class="cov0" title="0">{
                        key := strings.ToLower(strings.TrimSpace(headerParts[0]))
                        value := strings.TrimSpace(headerParts[1])
                        email.Headers[key] = value
                        
                        switch key </span>{
                        case "subject":<span class="cov0" title="0">
                                email.Subject = value</span>
                        case "from":<span class="cov0" title="0">
                                email.From = value</span>
                        case "message-id":<span class="cov0" title="0">
                                email.MessageID = value</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return email</span>
}

func (pop3 *POP3Analyzer) parseMessageList(lines []string) []map[string]interface{} <span class="cov0" title="0">{
        var messages []map[string]interface{}
        
        for _, line := range lines </span><span class="cov0" title="0">{
                parts := strings.Fields(line)
                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        number, err1 := strconv.Atoi(parts[0])
                        size, err2 := strconv.ParseInt(parts[1], 10, 64)
                        
                        if err1 == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                                messages = append(messages, map[string]interface{}{
                                        "number": number,
                                        "size":   size,
                                })
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return messages</span>
}

func (pop3 *POP3Analyzer) parseUIDList(lines []string) []map[string]interface{} <span class="cov0" title="0">{
        var uidList []map[string]interface{}
        
        for _, line := range lines </span><span class="cov0" title="0">{
                parts := strings.Fields(line)
                if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                        number, err := strconv.Atoi(parts[0])
                        if err == nil </span><span class="cov0" title="0">{
                                uidList = append(uidList, map[string]interface{}{
                                        "number": number,
                                        "uid":    parts[1],
                                })
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return uidList</span>
}

func (pop3 *POP3Analyzer) parseAddressList(addresses string) []string <span class="cov0" title="0">{
        // Simple address parsing
        addrs := strings.Split(addresses, ",")
        var result []string
        
        for _, addr := range addrs </span><span class="cov0" title="0">{
                result = append(result, strings.TrimSpace(addr))
        }</span>
        
        <span class="cov0" title="0">return result</span>
}

func (pop3 *POP3Analyzer) extractAttachments(body string) []EmailAttachment <span class="cov0" title="0">{
        var attachments []EmailAttachment
        
        // Look for Content-Disposition: attachment
        re := regexp.MustCompile(`(?i)content-disposition:\s*attachment[^;]*;\s*filename[^=]*=\s*"?([^"\n\r]+)"?`)
        matches := re.FindAllStringSubmatch(body, -1)
        
        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt; 1 </span><span class="cov0" title="0">{
                        attachment := EmailAttachment{
                                Filename: strings.TrimSpace(match[1]),
                        }
                        attachments = append(attachments, attachment)
                }</span>
        }
        
        <span class="cov0" title="0">return attachments</span>
}

// GetActiveSessions returns all active POP3 sessions
func (pop3 *POP3Analyzer) GetActiveSessions() []*POP3Session <span class="cov0" title="0">{
        var sessions []*POP3Session
        cutoff := time.Now().Add(-30 * time.Minute)
        
        for key, session := range pop3.sessions </span><span class="cov0" title="0">{
                if session.LastActivity.After(cutoff) </span><span class="cov0" title="0">{
                        sessions = append(sessions, session)
                }</span> else<span class="cov0" title="0"> {
                        delete(pop3.sessions, key)
                }</span>
        }
        
        <span class="cov0" title="0">return sessions</span>
}

// GetSessionStats returns POP3 session statistics
func (pop3 *POP3Analyzer) GetSessionStats() map[string]interface{} <span class="cov0" title="0">{
        activeSessions := pop3.GetActiveSessions()
        
        stats := map[string]interface{}{
                "active_sessions":        len(activeSessions),
                "authenticated_sessions": 0,
                "total_emails":          0,
                "retrieved_emails":      0,
                "deleted_emails":        0,
                "total_attachments":     0,
                "total_bytes":           int64(0),
        }
        
        for _, session := range activeSessions </span><span class="cov0" title="0">{
                if session.Authenticated </span><span class="cov0" title="0">{
                        stats["authenticated_sessions"] = stats["authenticated_sessions"].(int) + 1
                }</span>
                
                <span class="cov0" title="0">stats["total_emails"] = stats["total_emails"].(int) + len(session.Emails)
                stats["retrieved_emails"] = stats["retrieved_emails"].(int) + session.Statistics.RetrievedCount
                stats["deleted_emails"] = stats["deleted_emails"].(int) + session.Statistics.DeletedCount
                stats["total_bytes"] = stats["total_bytes"].(int64) + session.Statistics.TotalSize
                
                for _, email := range session.Emails </span><span class="cov0" title="0">{
                        stats["total_attachments"] = stats["total_attachments"].(int) + len(email.Attachments)
                }</span>
        }
        
        <span class="cov0" title="0">return stats</span>
}

// ExtractEmails returns all emails extracted from POP3 sessions
func (pop3 *POP3Analyzer) ExtractEmails() []EmailMessage <span class="cov0" title="0">{
        var emails []EmailMessage
        
        for _, session := range pop3.sessions </span><span class="cov0" title="0">{
                emails = append(emails, session.Emails...)
        }</span>
        
        <span class="cov0" title="0">return emails</span>
}</pre>
		
		<pre class="file" id="file7" style="display: none">package protocols

import (
        "fmt"
        "net"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
)

type SCPAnalyzer struct {
        sessions map[string]*SCPSession
}

type SCPSession struct {
        ID              string
        ClientIP        net.IP
        ServerIP        net.IP
        ClientPort      uint16
        ServerPort      uint16
        State           string
        Command         string
        Direction       string // "upload" or "download"
        Filename        string
        FileSize        int64
        FileMode        string
        BytesTransferred int64
        StartTime       time.Time
        LastActivity    time.Time
        Complete        bool
        Error           string
        Files           []SCPFile
        Recursive       bool
        PreserveTimes   bool
        SourcePath      string
        TargetPath      string
}

type SCPFile struct {
        Name         string
        Size         int64
        Mode         string
        Timestamp    time.Time
        BytesTransferred int64
        Complete     bool
}

const (
        SCP_STATE_INIT       = "init"
        SCP_STATE_HANDSHAKE  = "handshake"
        SCP_STATE_AUTH       = "auth"
        SCP_STATE_COMMAND    = "command"
        SCP_STATE_TRANSFER   = "transfer"
        SCP_STATE_COMPLETE   = "complete"
        SCP_STATE_ERROR      = "error"
)

func NewSCPAnalyzer() *SCPAnalyzer <span class="cov0" title="0">{
        return &amp;SCPAnalyzer{
                sessions: make(map[string]*SCPSession),
        }
}</span>

func (scp *SCPAnalyzer) GetProtocol() string <span class="cov0" title="0">{
        return "SCP"
}</span>

func (scp *SCPAnalyzer) GetPort() uint16 <span class="cov0" title="0">{
        return 22 // SCP runs over SSH
}</span>

func (scp *SCPAnalyzer) ProcessPacket(packet gopacket.Packet) *ProtocolEvent <span class="cov0" title="0">{
        tcpLayer := packet.Layer(layers.LayerTypeTCP)
        if tcpLayer == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">tcp := tcpLayer.(*layers.TCP)
        
        // SCP runs over SSH (port 22)
        if tcp.DstPort != 22 &amp;&amp; tcp.SrcPort != 22 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">payload := tcp.Payload
        if len(payload) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">sessionID := scp.getSessionID(packet)
        session := scp.getOrCreateSession(sessionID, packet)

        return scp.processSSHPayload(session, payload, packet)</span>
}

func (scp *SCPAnalyzer) processSSHPayload(session *SCPSession, payload []byte, packet gopacket.Packet) *ProtocolEvent <span class="cov0" title="0">{
        // Since SCP runs over SSH, we need to detect SCP patterns in encrypted traffic
        // We look for SSH protocol patterns and SCP command patterns
        
        data := string(payload)
        
        // Look for SSH version exchange
        if strings.HasPrefix(data, "SSH-") </span><span class="cov0" title="0">{
                session.State = SCP_STATE_HANDSHAKE
                return &amp;ProtocolEvent{
                        Protocol:    "SCP",
                        EventType:   EventTypeConnection,
                        Timestamp:   time.Now(),
                        SourceIP:    session.ClientIP,
                        DestIP:      session.ServerIP,
                        SourcePort:  session.ClientPort,
                        DestPort:    session.ServerPort,
                        Data: map[string]interface{}{
                                "session_id": session.ID,
                                "ssh_version": strings.TrimSpace(data),
                        },
                }
        }</span>

        // Look for SCP command patterns (these appear during SSH channel establishment)
        <span class="cov0" title="0">if scp.detectSCPCommand(data, session) </span><span class="cov0" title="0">{
                return scp.createSCPCommandEvent(session)
        }</span>

        // Look for SCP protocol messages (C mode size filename, T mtime mtime atime atime)
        <span class="cov0" title="0">if event := scp.parseSCPProtocol(session, data); event != nil </span><span class="cov0" title="0">{
                return event
        }</span>

        // Monitor data transfer patterns
        <span class="cov0" title="0">if session.State == SCP_STATE_TRANSFER </span><span class="cov0" title="0">{
                return scp.processDataTransfer(session, len(payload))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (scp *SCPAnalyzer) detectSCPCommand(data string, session *SCPSession) bool <span class="cov0" title="0">{
        // Look for common SCP command patterns
        scpPatterns := []string{
                "scp -t",      // SCP sink mode (receiving files)
                "scp -f",      // SCP source mode (sending files)
                "scp -r",      // Recursive SCP
                "scp -p",      // Preserve timestamps
                "scp -v",      // Verbose mode
        }

        for _, pattern := range scpPatterns </span><span class="cov0" title="0">{
                if strings.Contains(data, pattern) </span><span class="cov0" title="0">{
                        session.Command = pattern
                        session.State = SCP_STATE_COMMAND
                        
                        // Determine direction based on flags
                        if strings.Contains(pattern, "-t") </span><span class="cov0" title="0">{
                                session.Direction = "upload"
                        }</span> else<span class="cov0" title="0"> if strings.Contains(pattern, "-f") </span><span class="cov0" title="0">{
                                session.Direction = "download"
                        }</span>
                        
                        <span class="cov0" title="0">return true</span>
                }
        }

        // Look for file paths in commands
        <span class="cov0" title="0">filePathPattern := regexp.MustCompile(`[/\w\.-]+\.(txt|pdf|doc|zip|tar|gz|jpg|png|mp4|avi|mov|mp3|wav|exe|bin|so|dll|conf|log|csv|json|xml|html|css|js|py|go|java|cpp|c|h)`)
        if matches := filePathPattern.FindStringSubmatch(data); len(matches) &gt; 0 </span><span class="cov0" title="0">{
                session.Filename = matches[0]
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (scp *SCPAnalyzer) parseSCPProtocol(session *SCPSession, data string) *ProtocolEvent <span class="cov0" title="0">{
        // SCP protocol messages:
        // C&lt;mode&gt; &lt;size&gt; &lt;filename&gt; - Copy file
        // D&lt;mode&gt; &lt;size&gt; &lt;dirname&gt;  - Directory
        // T&lt;mtime&gt; 0 &lt;atime&gt; 0     - Timestamp
        // E                        - End directory
        
        lines := strings.Split(data, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                
                // Copy file command
                if strings.HasPrefix(line, "C") &amp;&amp; len(line) &gt; 1 </span><span class="cov0" title="0">{
                        parts := strings.Fields(line[1:])
                        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                                mode := parts[0]
                                size, _ := strconv.ParseInt(parts[1], 10, 64)
                                filename := parts[2]
                                
                                file := SCPFile{
                                        Name:      filename,
                                        Size:      size,
                                        Mode:      mode,
                                        Timestamp: time.Now(),
                                }
                                
                                session.Files = append(session.Files, file)
                                session.Filename = filename
                                session.FileSize = size
                                session.FileMode = mode
                                session.State = SCP_STATE_TRANSFER
                                
                                return &amp;ProtocolEvent{
                                        Protocol:    "SCP",
                                        EventType:   EventTypeFileTransfer,
                                        Timestamp:   time.Now(),
                                        SourceIP:    session.ClientIP,
                                        DestIP:      session.ServerIP,
                                        SourcePort:  session.ClientPort,
                                        DestPort:    session.ServerPort,
                                        Filename:    filename,
                                        FileSize:    size,
                                        Data: map[string]interface{}{
                                                "session_id": session.ID,
                                                "filename":   filename,
                                                "size":       size,
                                                "mode":       mode,
                                                "direction":  session.Direction,
                                        },
                                }
                        }</span>
                }
                
                // Directory command
                <span class="cov0" title="0">if strings.HasPrefix(line, "D") &amp;&amp; len(line) &gt; 1 </span><span class="cov0" title="0">{
                        parts := strings.Fields(line[1:])
                        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                                dirname := parts[2]
                                return &amp;ProtocolEvent{
                                        Protocol:    "SCP",
                                        EventType:   EventTypeDataTransfer,
                                        Timestamp:   time.Now(),
                                        SourceIP:    session.ClientIP,
                                        DestIP:      session.ServerIP,
                                        SourcePort:  session.ClientPort,
                                        DestPort:    session.ServerPort,
                                        Data: map[string]interface{}{
                                                "session_id": session.ID,
                                                "directory":  dirname,
                                                "direction":  session.Direction,
                                        },
                                }
                        }</span>
                }
                
                // Timestamp command
                <span class="cov0" title="0">if strings.HasPrefix(line, "T") </span><span class="cov0" title="0">{
                        return &amp;ProtocolEvent{
                                Protocol:    "SCP",
                                EventType:   EventTypeDataTransfer,
                                Timestamp:   time.Now(),
                                SourceIP:    session.ClientIP,
                                DestIP:      session.ServerIP,
                                SourcePort:  session.ClientPort,
                                DestPort:    session.ServerPort,
                                Data: map[string]interface{}{
                                        "session_id": session.ID,
                                        "type": "timestamp_preservation",
                                },
                        }
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

func (scp *SCPAnalyzer) processDataTransfer(session *SCPSession, dataSize int) *ProtocolEvent <span class="cov0" title="0">{
        session.BytesTransferred += int64(dataSize)
        
        // Check if file transfer is complete
        if len(session.Files) &gt; 0 </span><span class="cov0" title="0">{
                currentFile := &amp;session.Files[len(session.Files)-1]
                currentFile.BytesTransferred += int64(dataSize)
                
                if currentFile.BytesTransferred &gt;= currentFile.Size </span><span class="cov0" title="0">{
                        currentFile.Complete = true
                        session.State = SCP_STATE_COMPLETE
                        
                        return &amp;ProtocolEvent{
                                Protocol:    "SCP",
                                EventType:   EventTypeFileTransfer,
                                Timestamp:   time.Now(),
                                SourceIP:    session.ClientIP,
                                DestIP:      session.ServerIP,
                                SourcePort:  session.ClientPort,
                                DestPort:    session.ServerPort,
                                Filename:    currentFile.Name,
                                FileSize:    currentFile.Size,
                                Direction:   DirectionUpload,
                                Data: map[string]interface{}{
                                        "session_id":        session.ID,
                                        "filename":          currentFile.Name,
                                        "size":              currentFile.Size,
                                        "bytes_transferred": currentFile.BytesTransferred,
                                        "direction":         session.Direction,
                                        "duration":          time.Since(session.StartTime),
                                        "extracted_file": map[string]interface{}{
                                                "filename":    currentFile.Name,
                                                "size":        currentFile.Size,
                                                "protocol":    "SCP",
                                                "direction":   session.Direction,
                                                "client_ip":   session.ClientIP.String(),
                                                "server_ip":   session.ServerIP.String(),
                                                "start_time":  session.StartTime,
                                                "duration":    time.Since(session.StartTime),
                                        },
                                },
                        }
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

func (scp *SCPAnalyzer) createSCPCommandEvent(session *SCPSession) *ProtocolEvent <span class="cov0" title="0">{
        direction := "download"
        if session.Direction == "upload" </span><span class="cov0" title="0">{
                direction = "upload"
        }</span>
        
        <span class="cov0" title="0">return &amp;ProtocolEvent{
                Protocol:    "SCP",
                EventType:   EventTypeCommand,
                Timestamp:   time.Now(),
                SourceIP:    session.ClientIP,
                DestIP:      session.ServerIP,
                SourcePort:  session.ClientPort,
                DestPort:    session.ServerPort,
                Command:     session.Command,
                Data: map[string]interface{}{
                        "session_id": session.ID,
                        "direction": direction,
                        "recursive": session.Recursive,
                        "preserve_times": session.PreserveTimes,
                        "source_path": session.SourcePath,
                        "target_path": session.TargetPath,
                },
        }</span>
}

func (scp *SCPAnalyzer) getSessionID(packet gopacket.Packet) string <span class="cov0" title="0">{
        netLayer := packet.NetworkLayer()
        if netLayer == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">tcpLayer := packet.Layer(layers.LayerTypeTCP)
        if tcpLayer == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">tcp := tcpLayer.(*layers.TCP)
        src := netLayer.NetworkFlow().Src().String()
        dst := netLayer.NetworkFlow().Dst().String()
        
        return fmt.Sprintf("%s:%d-%s:%d", src, tcp.SrcPort, dst, tcp.DstPort)</span>
}

func (scp *SCPAnalyzer) getOrCreateSession(sessionID string, packet gopacket.Packet) *SCPSession <span class="cov0" title="0">{
        if session, exists := scp.sessions[sessionID]; exists </span><span class="cov0" title="0">{
                session.LastActivity = time.Now()
                return session
        }</span>

        <span class="cov0" title="0">netLayer := packet.NetworkLayer()
        tcpLayer := packet.Layer(layers.LayerTypeTCP)
        tcp := tcpLayer.(*layers.TCP)

        session := &amp;SCPSession{
                ID:           sessionID,
                ClientIP:     net.ParseIP(netLayer.NetworkFlow().Src().String()),
                ServerIP:     net.ParseIP(netLayer.NetworkFlow().Dst().String()),
                ClientPort:   uint16(tcp.SrcPort),
                ServerPort:   uint16(tcp.DstPort),
                State:        SCP_STATE_INIT,
                StartTime:    time.Now(),
                LastActivity: time.Now(),
                Files:        make([]SCPFile, 0),
        }

        scp.sessions[sessionID] = session
        return session</span>
}

func (scp *SCPAnalyzer) GetSessions() map[string]interface{} <span class="cov0" title="0">{
        sessions := make(map[string]interface{})
        for id, session := range scp.sessions </span><span class="cov0" title="0">{
                sessions[id] = map[string]interface{}{
                        "client_ip":         session.ClientIP.String(),
                        "server_ip":         session.ServerIP.String(),
                        "state":             session.State,
                        "command":           session.Command,
                        "direction":         session.Direction,
                        "files_count":       len(session.Files),
                        "bytes_transferred": session.BytesTransferred,
                        "start_time":        session.StartTime,
                        "duration":          time.Since(session.StartTime),
                }
        }</span>
        <span class="cov0" title="0">return sessions</span>
}

func (scp *SCPAnalyzer) CleanupSessions() <span class="cov0" title="0">{
        cutoff := time.Now().Add(-10 * time.Minute)
        for id, session := range scp.sessions </span><span class="cov0" title="0">{
                if session.LastActivity.Before(cutoff) || session.Complete </span><span class="cov0" title="0">{
                        delete(scp.sessions, id)
                }</span>
        }
}</pre>
		
		<pre class="file" id="file8" style="display: none">package protocols

import (
        "bufio"
        "encoding/base64"
        "fmt"
        "net"
        "net/mail"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/tcpassembly/tcpreader"
)

// SMTPAnalyzer analyzes SMTP protocol traffic
type SMTPAnalyzer struct {
        BaseAnalyzer
        sessions map[string]*SMTPSession
}

// SMTPSession represents an active SMTP session
type SMTPSession struct {
        ID               string
        ClientIP         net.IP
        ServerIP         net.IP
        Port             uint16
        ServerName       string
        ClientName       string
        AuthMethod       string
        Username         string
        Commands         []SMTPCommand
        Emails           []SMTPEmail
        Extensions       []string
        StartTime        time.Time
        LastActivity     time.Time
        Authenticated    bool
        TLSEnabled       bool
        ESMTPEnabled     bool
        CurrentEmail     *SMTPEmail
        State            SMTPState
}

// SMTPState represents the state of an SMTP connection
type SMTPState int

const (
        SMTPStateInit SMTPState = iota
        SMTPStateGreeting
        SMTPStateAuthenticated
        SMTPStateMailTransaction
        SMTPStateData
        SMTPStateQuit
)

// SMTPCommand represents an SMTP command
type SMTPCommand struct {
        Command   string
        Arguments string
        Response  string
        Code      int
        Timestamp time.Time
}

// SMTPEmail represents an email being sent via SMTP
type SMTPEmail struct {
        ID          string
        MessageID   string
        From        string
        To          []string
        CC          []string
        BCC         []string
        Subject     string
        Date        time.Time
        Size        int64
        Headers     map[string]string
        Body        string
        Attachments []EmailAttachment
        Timestamp   time.Time
        Complete    bool
}

// NewSMTPAnalyzer creates a new SMTP analyzer
func NewSMTPAnalyzer() ProtocolAnalyzer <span class="cov0" title="0">{
        return &amp;SMTPAnalyzer{
                BaseAnalyzer: BaseAnalyzer{
                        protocolName: "SMTP",
                        ports:        []uint16{25, 465, 587}, // SMTP, SMTPS, Submission
                },
                sessions: make(map[string]*SMTPSession),
        }
}</span>

// AnalyzeStream analyzes an SMTP stream
func (smtp *SMTPAnalyzer) AnalyzeStream(flow gopacket.Flow, reader *tcpreader.ReaderStream) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        buf := bufio.NewReader(reader)
        
        // Create session key
        sessionKey := fmt.Sprintf("%s-&gt;%s", flow.Src().String(), flow.Dst().String())
        
        // Get or create session
        session := smtp.getOrCreateSession(sessionKey, flow)
        
        // Analyze SMTP protocol
        events = append(events, smtp.analyzeSMTPStream(session, buf)...)
        
        return events
}</span>

// IsProtocolTraffic determines if data is SMTP traffic
func (smtp *SMTPAnalyzer) IsProtocolTraffic(data []byte) bool <span class="cov0" title="0">{
        dataStr := strings.ToUpper(string(data))
        
        // Check for SMTP server greeting
        if strings.HasPrefix(dataStr, "220 ") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Check for common SMTP commands
        <span class="cov0" title="0">smtpCommands := []string{"HELO ", "EHLO ", "MAIL FROM:", "RCPT TO:", "DATA", "RSET", "VRFY ", "EXPN ", "HELP", "NOOP", "QUIT", "AUTH ", "STARTTLS"}
        for _, cmd := range smtpCommands </span><span class="cov0" title="0">{
                if strings.HasPrefix(dataStr, cmd) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        // Check for SMTP response codes
        <span class="cov0" title="0">if len(dataStr) &gt;= 3 </span><span class="cov0" title="0">{
                code := dataStr[:3]
                if _, err := strconv.Atoi(code); err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

func (smtp *SMTPAnalyzer) getOrCreateSession(sessionKey string, flow gopacket.Flow) *SMTPSession <span class="cov0" title="0">{
        if session, exists := smtp.sessions[sessionKey]; exists </span><span class="cov0" title="0">{
                session.LastActivity = time.Now()
                return session
        }</span>
        
        <span class="cov0" title="0">session := &amp;SMTPSession{
                ID:           fmt.Sprintf("smtp_%d", time.Now().UnixNano()),
                ClientIP:     net.ParseIP(flow.Src().String()),
                ServerIP:     net.ParseIP(flow.Dst().String()),
                Port:         uint16(flow.Dst().FastHash()),
                Commands:     make([]SMTPCommand, 0),
                Emails:       make([]SMTPEmail, 0),
                Extensions:   make([]string, 0),
                StartTime:    time.Now(),
                LastActivity: time.Now(),
                State:        SMTPStateInit,
        }
        
        smtp.sessions[sessionKey] = session
        return session</span>
}

func (smtp *SMTPAnalyzer) analyzeSMTPStream(session *SMTPSession, reader *bufio.Reader) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        var isDataMode bool
        var emailData []string
        
        for </span><span class="cov0" title="0">{
                line, err := ReadLine(reader)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Handle DATA mode
                <span class="cov0" title="0">if isDataMode </span><span class="cov0" title="0">{
                        if line == "." </span><span class="cov0" title="0">{
                                // End of email data
                                isDataMode = false
                                event := smtp.processEmailData(session, emailData)
                                if event != nil </span><span class="cov0" title="0">{
                                        events = append(events, *event)
                                }</span>
                                <span class="cov0" title="0">emailData = []string{}</span>
                        } else<span class="cov0" title="0"> {
                                // Collect email data
                                emailData = append(emailData, line)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                
                // Determine if this is a command or response
                <span class="cov0" title="0">if smtp.isCommand(line) </span><span class="cov0" title="0">{
                        event := smtp.processCommand(session, line)
                        if event != nil </span><span class="cov0" title="0">{
                                events = append(events, *event)
                                
                                // Check if entering DATA mode
                                if strings.ToUpper(strings.TrimSpace(line)) == "DATA" </span>{<span class="cov0" title="0">
                                        // Wait for 354 response, then enter data mode
                                }</span>
                        }
                } else<span class="cov0" title="0"> if smtp.isResponse(line) </span><span class="cov0" title="0">{
                        event := smtp.processResponse(session, line, &amp;isDataMode)
                        if event != nil </span><span class="cov0" title="0">{
                                events = append(events, *event)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return events</span>
}

func (smtp *SMTPAnalyzer) isCommand(line string) bool <span class="cov0" title="0">{
        // SMTP commands are typically at the start of the line
        parts := strings.Fields(line)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">command := strings.ToUpper(parts[0])
        smtpCommands := []string{"HELO", "EHLO", "MAIL", "RCPT", "DATA", "RSET", "VRFY", "EXPN", "HELP", "NOOP", "QUIT", "AUTH", "STARTTLS"}
        
        for _, cmd := range smtpCommands </span><span class="cov0" title="0">{
                if strings.HasPrefix(command, cmd) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

func (smtp *SMTPAnalyzer) isResponse(line string) bool <span class="cov0" title="0">{
        // SMTP responses start with a 3-digit code
        if len(line) &lt; 3 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">code := line[:3]
        _, err := strconv.Atoi(code)
        return err == nil</span>
}

func (smtp *SMTPAnalyzer) processCommand(session *SMTPSession, line string) *ProtocolEvent <span class="cov0" title="0">{
        parts := strings.SplitN(line, " ", 2)
        command := strings.ToUpper(parts[0])
        var arguments string
        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                arguments = parts[1]
        }</span>
        
        // Add to session commands
        <span class="cov0" title="0">smtpCmd := SMTPCommand{
                Command:   command,
                Arguments: arguments,
                Timestamp: time.Now(),
        }
        session.Commands = append(session.Commands, smtpCmd)
        
        // Create event
        event := &amp;ProtocolEvent{
                ID:        GenerateEventID("SMTP"),
                Protocol:  "SMTP",
                EventType: EventTypeCommand,
                Command:   line,
                Data: map[string]interface{}{
                        "session_id": session.ID,
                        "command":    command,
                        "arguments":  arguments,
                },
        }
        
        // Handle specific commands
        switch command </span>{
        case "HELO", "EHLO":<span class="cov0" title="0">
                session.ClientName = arguments
                session.State = SMTPStateGreeting
                if command == "EHLO" </span><span class="cov0" title="0">{
                        session.ESMTPEnabled = true
                }</span>
                <span class="cov0" title="0">event.Data["client_name"] = arguments
                event.Data["esmtp"] = command == "EHLO"</span>
                
        case "AUTH":<span class="cov0" title="0">
                event.EventType = EventTypeAuthentication
                authParts := strings.Fields(arguments)
                if len(authParts) &gt; 0 </span><span class="cov0" title="0">{
                        session.AuthMethod = authParts[0]
                        event.Data["auth_method"] = authParts[0]
                }</span>
                
        case "MAIL":<span class="cov0" title="0">
                // MAIL FROM:&lt;sender&gt;
                sender := smtp.extractEmailAddress(arguments)
                if sender != "" </span><span class="cov0" title="0">{
                        session.CurrentEmail = &amp;SMTPEmail{
                                ID:          fmt.Sprintf("email_%d", time.Now().UnixNano()),
                                From:        sender,
                                To:          make([]string, 0),
                                CC:          make([]string, 0),
                                BCC:         make([]string, 0),
                                Headers:     make(map[string]string),
                                Attachments: make([]EmailAttachment, 0),
                                Timestamp:   time.Now(),
                        }
                        session.State = SMTPStateMailTransaction
                        event.EventType = EventTypeEmail
                        event.Data["sender"] = sender
                }</span>
                
        case "RCPT":<span class="cov0" title="0">
                // RCPT TO:&lt;recipient&gt;
                recipient := smtp.extractEmailAddress(arguments)
                if recipient != "" &amp;&amp; session.CurrentEmail != nil </span><span class="cov0" title="0">{
                        session.CurrentEmail.To = append(session.CurrentEmail.To, recipient)
                        event.EventType = EventTypeEmail
                        event.Data["recipient"] = recipient
                }</span>
                
        case "DATA":<span class="cov0" title="0">
                session.State = SMTPStateData
                event.EventType = EventTypeEmail
                event.Data["starting_data"] = true</span>
                
        case "RSET":<span class="cov0" title="0">
                session.CurrentEmail = nil
                session.State = SMTPStateGreeting
                event.Data["reset"] = true</span>
                
        case "QUIT":<span class="cov0" title="0">
                session.State = SMTPStateQuit
                event.EventType = EventTypeDisconnection</span>
                
        case "STARTTLS":<span class="cov0" title="0">
                event.Data["tls_requested"] = true</span>
        }
        
        <span class="cov0" title="0">return event</span>
}

func (smtp *SMTPAnalyzer) processResponse(session *SMTPSession, line string, isDataMode *bool) *ProtocolEvent <span class="cov0" title="0">{
        code, err := strconv.Atoi(line[:3])
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">message := ""
        if len(line) &gt; 4 </span><span class="cov0" title="0">{
                message = line[4:]
        }</span>
        
        // Update last command with response
        <span class="cov0" title="0">if len(session.Commands) &gt; 0 </span><span class="cov0" title="0">{
                lastCmd := &amp;session.Commands[len(session.Commands)-1]
                lastCmd.Response = line
                lastCmd.Code = code
        }</span>
        
        <span class="cov0" title="0">event := &amp;ProtocolEvent{
                ID:        GenerateEventID("SMTP"),
                Protocol:  "SMTP",
                EventType: EventTypeCommand,
                Response:  line,
                Status:    fmt.Sprintf("%d", code),
                Data: map[string]interface{}{
                        "session_id":     session.ID,
                        "response_code":  code,
                        "response_text":  message,
                },
        }
        
        // Handle specific response codes
        switch </span>{
        case code == 220:<span class="cov0" title="0">
                // Service ready
                event.EventType = EventTypeConnection
                session.ServerName = smtp.extractServerName(message)
                event.Data["server_name"] = session.ServerName</span>
                
        case code == 250:<span class="cov0" title="0">
                // Command completed successfully
                if len(session.Commands) &gt; 0 </span><span class="cov0" title="0">{
                        lastCmd := session.Commands[len(session.Commands)-1]
                        
                        switch lastCmd.Command </span>{
                        case "EHLO":<span class="cov0" title="0">
                                // Extract ESMTP extensions
                                if strings.Contains(message, "AUTH") </span><span class="cov0" title="0">{
                                        session.Extensions = append(session.Extensions, "AUTH")
                                }</span>
                                <span class="cov0" title="0">if strings.Contains(message, "STARTTLS") </span><span class="cov0" title="0">{
                                        session.Extensions = append(session.Extensions, "STARTTLS")
                                }</span>
                                <span class="cov0" title="0">event.Data["extensions"] = session.Extensions</span>
                                
                        case "AUTH":<span class="cov0" title="0">
                                session.Authenticated = true
                                event.EventType = EventTypeAuthentication
                                event.Data["auth_successful"] = true</span>
                                
                        case "STARTTLS":<span class="cov0" title="0">
                                session.TLSEnabled = true
                                event.Data["tls_enabled"] = true</span>
                        }
                }
                
        case code == 354:<span class="cov0" title="0">
                // Start mail input
                *isDataMode = true
                event.EventType = EventTypeEmail
                event.Data["data_mode"] = true</span>
                
        case code == 535:<span class="cov0" title="0">
                // Authentication failed
                event.EventType = EventTypeAuthentication
                event.Data["auth_failed"] = true</span>
                
        case code &gt;= 400:<span class="cov0" title="0">
                // Error responses
                event.EventType = EventTypeError
                event.Data["error"] = true</span>
        }
        
        <span class="cov0" title="0">return event</span>
}

func (smtp *SMTPAnalyzer) processEmailData(session *SMTPSession, data []string) *ProtocolEvent <span class="cov0" title="0">{
        if session.CurrentEmail == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Join all data lines
        <span class="cov0" title="0">emailContent := strings.Join(data, "\n")
        
        // Parse email headers and body
        smtp.parseEmailContent(session.CurrentEmail, emailContent)
        
        // Add to session emails
        session.CurrentEmail.Complete = true
        session.Emails = append(session.Emails, *session.CurrentEmail)
        
        event := &amp;ProtocolEvent{
                ID:        GenerateEventID("SMTP"),
                Protocol:  "SMTP",
                EventType: EventTypeEmail,
                Data: map[string]interface{}{
                        "session_id":   session.ID,
                        "email_id":     session.CurrentEmail.ID,
                        "from":         session.CurrentEmail.From,
                        "to":           session.CurrentEmail.To,
                        "subject":      session.CurrentEmail.Subject,
                        "size":         session.CurrentEmail.Size,
                        "attachments":  len(session.CurrentEmail.Attachments),
                },
        }
        
        // Reset current email
        session.CurrentEmail = nil
        session.State = SMTPStateGreeting
        
        return event</span>
}

func (smtp *SMTPAnalyzer) extractEmailAddress(text string) string <span class="cov0" title="0">{
        // Extract email from MAIL FROM:&lt;email&gt; or RCPT TO:&lt;email&gt;
        re := regexp.MustCompile(`&lt;([^&gt;]+)&gt;`)
        matches := re.FindStringSubmatch(text)
        if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                return matches[1]
        }</span>
        
        // Fallback to simple extraction
        <span class="cov0" title="0">parts := strings.Fields(text)
        for _, part := range parts </span><span class="cov0" title="0">{
                if strings.Contains(part, "@") </span><span class="cov0" title="0">{
                        return strings.Trim(part, "&lt;&gt;")
                }</span>
        }
        
        <span class="cov0" title="0">return ""</span>
}

func (smtp *SMTPAnalyzer) extractServerName(greeting string) string <span class="cov0" title="0">{
        // Extract server name from greeting message
        parts := strings.Fields(greeting)
        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                return parts[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (smtp *SMTPAnalyzer) parseEmailContent(email *SMTPEmail, content string) <span class="cov0" title="0">{
        // Split headers and body
        parts := strings.SplitN(content, "\n\n", 2)
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">headerText := parts[0]
        email.Body = parts[1]
        email.Size = int64(len(content))
        
        // Parse headers
        headerLines := strings.Split(headerText, "\n")
        for i, line := range headerLines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Handle folded headers (RFC 5322)
                <span class="cov0" title="0">if strings.HasPrefix(line, " ") || strings.HasPrefix(line, "\t") </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                // Append to previous header
                                continue</span>
                        }
                }
                
                <span class="cov0" title="0">headerParts := strings.SplitN(line, ":", 2)
                if len(headerParts) == 2 </span><span class="cov0" title="0">{
                        key := strings.ToLower(strings.TrimSpace(headerParts[0]))
                        value := strings.TrimSpace(headerParts[1])
                        email.Headers[key] = value
                        
                        // Extract common fields
                        switch key </span>{
                        case "subject":<span class="cov0" title="0">
                                email.Subject = smtp.decodeHeader(value)</span>
                        case "message-id":<span class="cov0" title="0">
                                email.MessageID = value</span>
                        case "date":<span class="cov0" title="0">
                                if date, err := mail.ParseDate(value); err == nil </span><span class="cov0" title="0">{
                                        email.Date = date
                                }</span>
                        case "cc":<span class="cov0" title="0">
                                email.CC = smtp.parseAddressList(value)</span>
                        case "bcc":<span class="cov0" title="0">
                                email.BCC = smtp.parseAddressList(value)</span>
                        }
                }
        }
        
        // Extract attachments
        <span class="cov0" title="0">email.Attachments = smtp.extractEmailAttachments(content)</span>
}

func (smtp *SMTPAnalyzer) decodeHeader(header string) string <span class="cov0" title="0">{
        // Simple RFC 2047 decoding for encoded headers
        if strings.Contains(header, "=?") &amp;&amp; strings.Contains(header, "?=") </span><span class="cov0" title="0">{
                // This is a simplified decoder - full implementation would be more complex
                re := regexp.MustCompile(`=\?([^?]+)\?([BQbq])\?([^?]+)\?=`)
                return re.ReplaceAllStringFunc(header, func(match string) string </span><span class="cov0" title="0">{
                        parts := re.FindStringSubmatch(match)
                        if len(parts) != 4 </span><span class="cov0" title="0">{
                                return match
                        }</span>
                        
                        <span class="cov0" title="0">encoding := strings.ToUpper(parts[2])
                        encoded := parts[3]
                        
                        switch encoding </span>{
                        case "B":<span class="cov0" title="0">
                                if decoded, err := base64.StdEncoding.DecodeString(encoded); err == nil </span><span class="cov0" title="0">{
                                        return string(decoded)
                                }</span>
                        case "Q":<span class="cov0" title="0">
                                // Quoted-printable decoding (simplified)
                                decoded := strings.ReplaceAll(encoded, "_", " ")
                                return decoded</span>
                        }
                        
                        <span class="cov0" title="0">return match</span>
                })
        }
        
        <span class="cov0" title="0">return header</span>
}

func (smtp *SMTPAnalyzer) parseAddressList(addresses string) []string <span class="cov0" title="0">{
        // Simple address list parsing
        addrs := strings.Split(addresses, ",")
        var result []string
        
        for _, addr := range addrs </span><span class="cov0" title="0">{
                addr = strings.TrimSpace(addr)
                if addr != "" </span><span class="cov0" title="0">{
                        result = append(result, addr)
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

func (smtp *SMTPAnalyzer) extractEmailAttachments(content string) []EmailAttachment <span class="cov0" title="0">{
        var attachments []EmailAttachment
        
        // Look for MIME attachments
        if strings.Contains(content, "Content-Disposition: attachment") </span><span class="cov0" title="0">{
                // Simple attachment detection
                re := regexp.MustCompile(`(?i)content-disposition:\s*attachment[^;]*;\s*filename[^=]*=\s*"?([^"\n\r]+)"?`)
                matches := re.FindAllStringSubmatch(content, -1)
                
                for _, match := range matches </span><span class="cov0" title="0">{
                        if len(match) &gt; 1 </span><span class="cov0" title="0">{
                                attachment := EmailAttachment{
                                        Filename: strings.TrimSpace(match[1]),
                                }
                                
                                // Try to extract content type
                                ctRe := regexp.MustCompile(`(?i)content-type:\s*([^;\n\r]+)`)
                                if ctMatches := ctRe.FindStringSubmatch(content); len(ctMatches) &gt; 1 </span><span class="cov0" title="0">{
                                        attachment.ContentType = strings.TrimSpace(ctMatches[1])
                                }</span>
                                
                                <span class="cov0" title="0">attachments = append(attachments, attachment)</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return attachments</span>
}

// GetActiveSessions returns all active SMTP sessions
func (smtp *SMTPAnalyzer) GetActiveSessions() []*SMTPSession <span class="cov0" title="0">{
        var sessions []*SMTPSession
        cutoff := time.Now().Add(-30 * time.Minute)
        
        for key, session := range smtp.sessions </span><span class="cov0" title="0">{
                if session.LastActivity.After(cutoff) </span><span class="cov0" title="0">{
                        sessions = append(sessions, session)
                }</span> else<span class="cov0" title="0"> {
                        delete(smtp.sessions, key)
                }</span>
        }
        
        <span class="cov0" title="0">return sessions</span>
}

// GetSessionStats returns SMTP session statistics
func (smtp *SMTPAnalyzer) GetSessionStats() map[string]interface{} <span class="cov0" title="0">{
        activeSessions := smtp.GetActiveSessions()
        
        stats := map[string]interface{}{
                "active_sessions":        len(activeSessions),
                "authenticated_sessions": 0,
                "tls_sessions":          0,
                "total_emails":          0,
                "total_attachments":     0,
                "total_email_size":      int64(0),
        }
        
        for _, session := range activeSessions </span><span class="cov0" title="0">{
                if session.Authenticated </span><span class="cov0" title="0">{
                        stats["authenticated_sessions"] = stats["authenticated_sessions"].(int) + 1
                }</span>
                
                <span class="cov0" title="0">if session.TLSEnabled </span><span class="cov0" title="0">{
                        stats["tls_sessions"] = stats["tls_sessions"].(int) + 1
                }</span>
                
                <span class="cov0" title="0">stats["total_emails"] = stats["total_emails"].(int) + len(session.Emails)
                
                for _, email := range session.Emails </span><span class="cov0" title="0">{
                        stats["total_email_size"] = stats["total_email_size"].(int64) + email.Size
                        stats["total_attachments"] = stats["total_attachments"].(int) + len(email.Attachments)
                }</span>
        }
        
        <span class="cov0" title="0">return stats</span>
}

// ExtractEmails returns all emails sent via SMTP
func (smtp *SMTPAnalyzer) ExtractEmails() []SMTPEmail <span class="cov0" title="0">{
        var emails []SMTPEmail
        
        for _, session := range smtp.sessions </span><span class="cov0" title="0">{
                emails = append(emails, session.Emails...)
        }</span>
        
        <span class="cov0" title="0">return emails</span>
}</pre>
		
		<pre class="file" id="file9" style="display: none">package protocols

import (
        "bufio"
        "bytes"
        "crypto/md5"
        "encoding/binary"
        "fmt"
        "net"
        "strings"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/tcpassembly/tcpreader"
)

// SSHAnalyzer analyzes SSH protocol traffic
type SSHAnalyzer struct {
        BaseAnalyzer
        sessions map[string]*SSHSession
}

// SSHSession represents an active SSH session
type SSHSession struct {
        ID                string
        ClientIP          net.IP
        ServerIP          net.IP
        Port              uint16
        ClientVersion     string
        ServerVersion     string
        EncryptionAlg     string
        MACAlg           string
        CompressionAlg    string
        Username          string
        AuthMethod        string
        AuthAttempts      []AuthAttempt
        KeyExchanges      []KeyExchange
        ChannelRequests   []ChannelRequest
        StartTime         time.Time
        LastActivity      time.Time
        Authenticated     bool
        Encrypted         bool
        BytesTransferred  int64
        PacketsTransferred int64
        ClientFingerprint string
        ServerFingerprint string
        State             SSHState
}

// SSHState represents the state of an SSH connection
type SSHState int

const (
        SSHStateInit SSHState = iota
        SSHStateVersionExchange
        SSHStateKeyExchange
        SSHStateAuthentication
        SSHStateEstablished
        SSHStateTerminated
)

// AuthAttempt represents an SSH authentication attempt
type AuthAttempt struct {
        Username   string
        Method     string
        Success    bool
        Timestamp  time.Time
        PublicKey  string
        Error      string
}

// KeyExchange represents an SSH key exchange
type KeyExchange struct {
        Algorithm     string
        ClientKex     []byte
        ServerKex     []byte
        SharedSecret  []byte
        Timestamp     time.Time
}

// ChannelRequest represents an SSH channel request
type ChannelRequest struct {
        Type        string
        WantReply   bool
        Data        []byte
        Success     bool
        Timestamp   time.Time
}

// SSHMessage represents a parsed SSH protocol message
type SSHMessage struct {
        Type      byte
        Length    uint32
        Payload   []byte
        Raw       []byte
        Timestamp time.Time
}

// NewSSHAnalyzer creates a new SSH analyzer
func NewSSHAnalyzer() ProtocolAnalyzer <span class="cov8" title="1">{
        return &amp;SSHAnalyzer{
                BaseAnalyzer: BaseAnalyzer{
                        protocolName: "SSH",
                        ports:        []uint16{22, 2222}, // Standard and alternative SSH ports
                },
                sessions: make(map[string]*SSHSession),
        }
}</span>

// AnalyzeStream analyzes an SSH stream
func (ssh *SSHAnalyzer) AnalyzeStream(flow gopacket.Flow, reader *tcpreader.ReaderStream) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        buf := bufio.NewReader(reader)
        
        // Create session key
        sessionKey := fmt.Sprintf("%s-&gt;%s", flow.Src().String(), flow.Dst().String())
        
        // Get or create session
        session := ssh.getOrCreateSession(sessionKey, flow)
        
        // Read SSH protocol data
        events = append(events, ssh.analyzeSSHStream(session, buf)...)
        
        return events
}</span>

// IsProtocolTraffic determines if data is SSH traffic
func (ssh *SSHAnalyzer) IsProtocolTraffic(data []byte) bool <span class="cov0" title="0">{
        dataStr := string(data)
        
        // Check for SSH version string
        if strings.HasPrefix(dataStr, "SSH-2.0-") || strings.HasPrefix(dataStr, "SSH-1.") </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Check for common SSH server banners
        <span class="cov0" title="0">sshBanners := []string{"OpenSSH", "libssh", "Cisco", "dropbear"}
        for _, banner := range sshBanners </span><span class="cov0" title="0">{
                if strings.Contains(dataStr, banner) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

func (ssh *SSHAnalyzer) getOrCreateSession(sessionKey string, flow gopacket.Flow) *SSHSession <span class="cov0" title="0">{
        if session, exists := ssh.sessions[sessionKey]; exists </span><span class="cov0" title="0">{
                session.LastActivity = time.Now()
                return session
        }</span>
        
        <span class="cov0" title="0">session := &amp;SSHSession{
                ID:                fmt.Sprintf("ssh_%d", time.Now().UnixNano()),
                ClientIP:          net.ParseIP(flow.Src().String()),
                ServerIP:          net.ParseIP(flow.Dst().String()),
                Port:              uint16(flow.Dst().FastHash()),
                AuthAttempts:      make([]AuthAttempt, 0),
                KeyExchanges:      make([]KeyExchange, 0),
                ChannelRequests:   make([]ChannelRequest, 0),
                StartTime:         time.Now(),
                LastActivity:      time.Now(),
                State:             SSHStateInit,
        }
        
        ssh.sessions[sessionKey] = session
        return session</span>
}

func (ssh *SSHAnalyzer) analyzeSSHStream(session *SSHSession, reader *bufio.Reader) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        
        switch session.State </span>{
        case SSHStateInit, SSHStateVersionExchange:<span class="cov0" title="0">
                events = append(events, ssh.analyzeVersionExchange(session, reader)...)</span>
        case SSHStateKeyExchange:<span class="cov0" title="0">
                events = append(events, ssh.analyzeKeyExchange(session, reader)...)</span>
        case SSHStateAuthentication:<span class="cov0" title="0">
                events = append(events, ssh.analyzeAuthentication(session, reader)...)</span>
        case SSHStateEstablished:<span class="cov0" title="0">
                events = append(events, ssh.analyzeEstablishedSession(session, reader)...)</span>
        }
        
        <span class="cov0" title="0">return events</span>
}

func (ssh *SSHAnalyzer) analyzeVersionExchange(session *SSHSession, reader *bufio.Reader) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        
        // Read version strings
        for </span><span class="cov0" title="0">{
                line, err := ReadLine(reader)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">if strings.HasPrefix(line, "SSH-") </span><span class="cov0" title="0">{
                        event := ProtocolEvent{
                                ID:        GenerateEventID("SSH"),
                                Protocol:  "SSH",
                                EventType: EventTypeConnection,
                                Data: map[string]interface{}{
                                        "session_id": session.ID,
                                        "version":    line,
                                },
                        }
                        
                        // Determine if this is client or server version
                        if session.ClientVersion == "" </span><span class="cov0" title="0">{
                                session.ClientVersion = line
                                event.Data["role"] = "client"
                                
                                // Extract client information
                                ssh.parseClientVersion(session, line)
                                
                        }</span> else<span class="cov0" title="0"> if session.ServerVersion == "" </span><span class="cov0" title="0">{
                                session.ServerVersion = line
                                event.Data["role"] = "server"
                                
                                // Extract server information
                                ssh.parseServerVersion(session, line)
                                
                                // Version exchange complete, move to key exchange
                                session.State = SSHStateKeyExchange
                        }</span>
                        
                        <span class="cov0" title="0">events = append(events, event)</span>
                }
        }
        
        <span class="cov0" title="0">return events</span>
}

func (ssh *SSHAnalyzer) analyzeKeyExchange(session *SSHSession, reader *bufio.Reader) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        
        // Read SSH protocol messages
        for </span><span class="cov0" title="0">{
                msg, err := ssh.readSSHMessage(reader)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">event := ssh.processKeyExchangeMessage(session, msg)
                if event != nil </span><span class="cov0" title="0">{
                        events = append(events, *event)
                }</span>
        }
        
        <span class="cov0" title="0">return events</span>
}

func (ssh *SSHAnalyzer) analyzeAuthentication(session *SSHSession, reader *bufio.Reader) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        
        // Read SSH protocol messages during authentication phase
        for </span><span class="cov0" title="0">{
                msg, err := ssh.readSSHMessage(reader)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">event := ssh.processAuthMessage(session, msg)
                if event != nil </span><span class="cov0" title="0">{
                        events = append(events, *event)
                }</span>
        }
        
        <span class="cov0" title="0">return events</span>
}

func (ssh *SSHAnalyzer) analyzeEstablishedSession(session *SSHSession, reader *bufio.Reader) []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        
        // Count encrypted data packets
        data := make([]byte, 4096)
        totalBytes := 0
        
        for </span><span class="cov0" title="0">{
                n, err := reader.Read(data)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">totalBytes += n
                session.BytesTransferred += int64(n)
                session.PacketsTransferred++</span>
        }
        
        <span class="cov0" title="0">if totalBytes &gt; 0 </span><span class="cov0" title="0">{
                event := ProtocolEvent{
                        ID:        GenerateEventID("SSH"),
                        Protocol:  "SSH",
                        EventType: EventTypeDataTransfer,
                        Data: map[string]interface{}{
                                "session_id":      session.ID,
                                "bytes":          totalBytes,
                                "total_bytes":    session.BytesTransferred,
                                "total_packets":  session.PacketsTransferred,
                                "encrypted":      session.Encrypted,
                        },
                }
                events = append(events, event)
        }</span>
        
        <span class="cov0" title="0">return events</span>
}

func (ssh *SSHAnalyzer) readSSHMessage(reader *bufio.Reader) (*SSHMessage, error) <span class="cov0" title="0">{
        // Read packet length (first 4 bytes)
        lengthBytes := make([]byte, 4)
        _, err := reader.Read(lengthBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">length := binary.BigEndian.Uint32(lengthBytes)
        
        // Read padding length (1 byte)
        paddingLengthByte := make([]byte, 1)
        _, err = reader.Read(paddingLengthByte)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">paddingLength := paddingLengthByte[0]
        
        // Calculate payload length
        payloadLength := length - uint32(paddingLength) - 1
        
        // Read message type (1 byte)
        msgTypeByte := make([]byte, 1)
        _, err = reader.Read(msgTypeByte)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">msgType := msgTypeByte[0]
        
        // Read payload
        payload := make([]byte, payloadLength-1) // -1 for message type
        _, err = reader.Read(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Read padding
        <span class="cov0" title="0">padding := make([]byte, paddingLength)
        _, err = reader.Read(padding)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Reconstruct full message
        <span class="cov0" title="0">fullMsg := append(lengthBytes, paddingLengthByte...)
        fullMsg = append(fullMsg, msgTypeByte...)
        fullMsg = append(fullMsg, payload...)
        fullMsg = append(fullMsg, padding...)
        
        return &amp;SSHMessage{
                Type:      msgType,
                Length:    length,
                Payload:   payload,
                Raw:       fullMsg,
                Timestamp: time.Now(),
        }, nil</span>
}

func (ssh *SSHAnalyzer) processKeyExchangeMessage(session *SSHSession, msg *SSHMessage) *ProtocolEvent <span class="cov0" title="0">{
        event := &amp;ProtocolEvent{
                ID:        GenerateEventID("SSH"),
                Protocol:  "SSH",
                EventType: EventTypeCommand,
                Data: map[string]interface{}{
                        "session_id":   session.ID,
                        "message_type": msg.Type,
                        "message_size": len(msg.Raw),
                },
        }
        
        switch msg.Type </span>{
        case 20:<span class="cov0" title="0"> // SSH_MSG_KEXINIT
                kex := ssh.parseKexInit(msg.Payload)
                if kex != nil </span><span class="cov0" title="0">{
                        session.KeyExchanges = append(session.KeyExchanges, *kex)
                        event.Data["kex_algorithms"] = kex.Algorithm
                }</span>
                
        case 21:<span class="cov0" title="0"> // SSH_MSG_NEWKEYS
                session.Encrypted = true
                session.State = SSHStateAuthentication
                event.Data["encryption_enabled"] = true</span>
                
        case 30:<span class="cov0" title="0"> // SSH_MSG_KEXDH_INIT
                event.Data["kex_dh_init"] = true</span>
                
        case 31:<span class="cov0" title="0"> // SSH_MSG_KEXDH_REPLY
                event.Data["kex_dh_reply"] = true</span>
                
        default:<span class="cov0" title="0">
                event.Data["unknown_message"] = true</span>
        }
        
        <span class="cov0" title="0">return event</span>
}

func (ssh *SSHAnalyzer) processAuthMessage(session *SSHSession, msg *SSHMessage) *ProtocolEvent <span class="cov0" title="0">{
        event := &amp;ProtocolEvent{
                ID:        GenerateEventID("SSH"),
                Protocol:  "SSH",
                EventType: EventTypeAuthentication,
                Data: map[string]interface{}{
                        "session_id":   session.ID,
                        "message_type": msg.Type,
                },
        }
        
        switch msg.Type </span>{
        case 50:<span class="cov0" title="0"> // SSH_MSG_USERAUTH_REQUEST
                auth := ssh.parseAuthRequest(msg.Payload)
                if auth != nil </span><span class="cov0" title="0">{
                        session.AuthAttempts = append(session.AuthAttempts, *auth)
                        event.Username = auth.Username
                        event.Data["auth_method"] = auth.Method
                }</span>
                
        case 51:<span class="cov0" title="0"> // SSH_MSG_USERAUTH_FAILURE
                event.Data["auth_failed"] = true
                if len(session.AuthAttempts) &gt; 0 </span><span class="cov0" title="0">{
                        session.AuthAttempts[len(session.AuthAttempts)-1].Success = false
                }</span>
                
        case 52:<span class="cov0" title="0"> // SSH_MSG_USERAUTH_SUCCESS
                session.Authenticated = true
                session.State = SSHStateEstablished
                event.Data["auth_success"] = true
                if len(session.AuthAttempts) &gt; 0 </span><span class="cov0" title="0">{
                        session.AuthAttempts[len(session.AuthAttempts)-1].Success = true
                        session.Username = session.AuthAttempts[len(session.AuthAttempts)-1].Username
                        session.AuthMethod = session.AuthAttempts[len(session.AuthAttempts)-1].Method
                }</span>
                
        case 53:<span class="cov0" title="0"> // SSH_MSG_USERAUTH_BANNER
                banner := string(msg.Payload)
                event.Data["banner"] = banner</span>
                
        default:<span class="cov0" title="0">
                event.Data["unknown_auth_message"] = true</span>
        }
        
        <span class="cov0" title="0">return event</span>
}

func (ssh *SSHAnalyzer) parseClientVersion(session *SSHSession, version string) <span class="cov0" title="0">{
        // Extract client fingerprint from version string
        session.ClientFingerprint = ssh.calculateFingerprint(version)
}</span>

func (ssh *SSHAnalyzer) parseServerVersion(session *SSHSession, version string) <span class="cov0" title="0">{
        // Extract server fingerprint from version string
        session.ServerFingerprint = ssh.calculateFingerprint(version)
}</span>

func (ssh *SSHAnalyzer) calculateFingerprint(data string) string <span class="cov0" title="0">{
        hash := md5.Sum([]byte(data))
        return fmt.Sprintf("%x", hash)
}</span>

func (ssh *SSHAnalyzer) parseKexInit(payload []byte) *KeyExchange <span class="cov0" title="0">{
        if len(payload) &lt; 16 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Skip random bytes (16 bytes)
        // pos := 16
        
        // Read algorithm name lists (simplified parsing)
        <span class="cov0" title="0">kex := &amp;KeyExchange{
                Timestamp: time.Now(),
        }
        
        // In a full implementation, would parse all algorithm lists
        // For now, just mark that key exchange is happening
        kex.Algorithm = "diffie-hellman-group14-sha256" // Default assumption
        
        return kex</span>
}

func (ssh *SSHAnalyzer) parseAuthRequest(payload []byte) *AuthAttempt <span class="cov0" title="0">{
        if len(payload) &lt; 4 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">reader := bytes.NewReader(payload)
        
        // Read username length
        var usernameLen uint32
        binary.Read(reader, binary.BigEndian, &amp;usernameLen)
        
        // Read username
        username := make([]byte, usernameLen)
        reader.Read(username)
        
        // Read service name length
        var serviceLen uint32
        binary.Read(reader, binary.BigEndian, &amp;serviceLen)
        
        // Skip service name
        reader.Seek(int64(serviceLen), 1)
        
        // Read method name length
        var methodLen uint32
        binary.Read(reader, binary.BigEndian, &amp;methodLen)
        
        // Read method name
        method := make([]byte, methodLen)
        reader.Read(method)
        
        return &amp;AuthAttempt{
                Username:  string(username),
                Method:    string(method),
                Timestamp: time.Now(),
        }</span>
}

// GetActiveSessions returns all active SSH sessions
func (ssh *SSHAnalyzer) GetActiveSessions() []*SSHSession <span class="cov0" title="0">{
        var sessions []*SSHSession
        cutoff := time.Now().Add(-30 * time.Minute)
        
        for key, session := range ssh.sessions </span><span class="cov0" title="0">{
                if session.LastActivity.After(cutoff) </span><span class="cov0" title="0">{
                        sessions = append(sessions, session)
                }</span> else<span class="cov0" title="0"> {
                        delete(ssh.sessions, key)
                }</span>
        }
        
        <span class="cov0" title="0">return sessions</span>
}

// GetSessionStats returns SSH session statistics
func (ssh *SSHAnalyzer) GetSessionStats() map[string]interface{} <span class="cov0" title="0">{
        activeSessions := ssh.GetActiveSessions()
        
        stats := map[string]interface{}{
                "active_sessions":        len(activeSessions),
                "authenticated_sessions": 0,
                "failed_auth_attempts":   0,
                "successful_auths":       0,
                "total_bytes":           int64(0),
                "encrypted_sessions":     0,
        }
        
        for _, session := range activeSessions </span><span class="cov0" title="0">{
                if session.Authenticated </span><span class="cov0" title="0">{
                        stats["authenticated_sessions"] = stats["authenticated_sessions"].(int) + 1
                }</span>
                
                <span class="cov0" title="0">if session.Encrypted </span><span class="cov0" title="0">{
                        stats["encrypted_sessions"] = stats["encrypted_sessions"].(int) + 1
                }</span>
                
                <span class="cov0" title="0">stats["total_bytes"] = stats["total_bytes"].(int64) + session.BytesTransferred
                
                for _, auth := range session.AuthAttempts </span><span class="cov0" title="0">{
                        if auth.Success </span><span class="cov0" title="0">{
                                stats["successful_auths"] = stats["successful_auths"].(int) + 1
                        }</span> else<span class="cov0" title="0"> {
                                stats["failed_auth_attempts"] = stats["failed_auth_attempts"].(int) + 1
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return stats</span>
}

// DetectBruteForce detects SSH brute force attempts
func (ssh *SSHAnalyzer) DetectBruteForce() []ProtocolEvent <span class="cov0" title="0">{
        var events []ProtocolEvent
        threshold := 5 // Failed attempts threshold
        timeWindow := 5 * time.Minute
        
        // Group failed attempts by client IP
        failedAttempts := make(map[string][]AuthAttempt)
        
        for _, session := range ssh.sessions </span><span class="cov0" title="0">{
                clientIP := session.ClientIP.String()
                for _, auth := range session.AuthAttempts </span><span class="cov0" title="0">{
                        if !auth.Success &amp;&amp; time.Since(auth.Timestamp) &lt; timeWindow </span><span class="cov0" title="0">{
                                failedAttempts[clientIP] = append(failedAttempts[clientIP], auth)
                        }</span>
                }
        }
        
        // Check for brute force patterns
        <span class="cov0" title="0">for ip, attempts := range failedAttempts </span><span class="cov0" title="0">{
                if len(attempts) &gt;= threshold </span><span class="cov0" title="0">{
                        event := ProtocolEvent{
                                ID:        GenerateEventID("SSH"),
                                Protocol:  "SSH",
                                EventType: EventTypeError,
                                SourceIP:  net.ParseIP(ip),
                                Command:   "BRUTE_FORCE_DETECTED",
                                Data: map[string]interface{}{
                                        "client_ip":       ip,
                                        "failed_attempts": len(attempts),
                                        "time_window":     timeWindow.String(),
                                        "usernames":       ssh.extractUsernames(attempts),
                                },
                        }
                        events = append(events, event)
                }</span>
        }
        
        <span class="cov0" title="0">return events</span>
}

func (ssh *SSHAnalyzer) extractUsernames(attempts []AuthAttempt) []string <span class="cov0" title="0">{
        usernames := make(map[string]bool)
        for _, attempt := range attempts </span><span class="cov0" title="0">{
                usernames[attempt.Username] = true
        }</span>
        
        <span class="cov0" title="0">var result []string
        for username := range usernames </span><span class="cov0" title="0">{
                result = append(result, username)
        }</span>
        
        <span class="cov0" title="0">return result</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package security

import (
        "fmt"
        "net"
        "sync"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
)

// NetworkAttackDetector detects various network-based attacks
type NetworkAttackDetector struct {
        // MAC tracking
        ipMacMap      map[string]MACEntry
        macChangeLog  []MACChangeEvent
        
        // ARP tracking
        arpTable      map[string]ARPEntry
        arpRequests   map[string][]time.Time
        
        // DHCP tracking
        dhcpServers   map[string]DHCPServer
        dhcpRequests  map[string][]time.Time
        dhcpLeases    map[string]DHCPLease
        
        // DNS tracking
        dnsServers    map[string]DNSServer
        dnsQueries    map[string][]DNSQuery
        dnsResponses  map[string][]DNSResponse
        
        // WiFi tracking
        wifiClients   map[string]WiFiClient
        deauthPackets []DeauthEvent
        beacons       map[string][]BeaconFrame
        
        // VLAN tracking
        vlanTraffic   map[uint16]VLANStats
        
        // Statistics
        stats         AttackStats
        alerts        []AttackAlert
        
        mu            sync.RWMutex
}

// Attack detection structures

type MACEntry struct {
        IP           string
        MAC          string
        FirstSeen    time.Time
        LastSeen     time.Time
        PacketCount  int
        Vendor       string
}

type MACChangeEvent struct {
        Timestamp    time.Time
        IP           string
        OldMAC       string
        NewMAC       string
        Suspicious   bool
}

type ARPEntry struct {
        IP           string
        MAC          string
        Interface    string
        LastUpdated  time.Time
        IsGratuitous bool
}

type DHCPServer struct {
        IP           string
        MAC          string
        FirstSeen    time.Time
        LastSeen     time.Time
        OffersCount  int
        Legitimate   bool
}

type DHCPLease struct {
        ClientMAC    string
        ClientIP     string
        ServerIP     string
        LeaseTime    time.Duration
        Timestamp    time.Time
}

type DNSServer struct {
        IP           string
        FirstSeen    time.Time
        LastSeen     time.Time
        ResponseCount int
        Legitimate   bool
}

type DNSQuery struct {
        Timestamp    time.Time
        QueryID      uint16
        ClientIP     string
        ServerIP     string
        QueryName    string
        QueryType    string
}

type DNSResponse struct {
        Timestamp    time.Time
        QueryID      uint16
        ServerIP     string
        ClientIP     string
        Answers      []string
        Suspicious   bool
}

type WiFiClient struct {
        MAC          string
        SSID         string
        Channel      int
        SignalStrength int
        FirstSeen    time.Time
        LastSeen     time.Time
        ProbeRequests []string
}

type DeauthEvent struct {
        Timestamp    time.Time
        SourceMAC    string
        DestMAC      string
        BSSID        string
        Reason       uint16
}

type BeaconFrame struct {
        Timestamp    time.Time
        BSSID        string
        SSID         string
        Channel      int
        Encryption   string
}

type VLANStats struct {
        ID           uint16
        PacketCount  int
        ByteCount    int64
        FirstSeen    time.Time
        LastSeen     time.Time
        DoubleTagged bool
}

type AttackStats struct {
        TotalPackets      uint64
        MacSpoofing       uint64
        ArpSpoofing       uint64
        DhcpAttacks       uint64
        DnsHijacking      uint64
        WiFiAttacks       uint64
        VlanAttacks       uint64
        MonitorMode       uint64
}

type AttackAlert struct {
        Timestamp    time.Time
        Type         string
        Severity     string
        Description  string
        SourceIP     string
        SourceMAC    string
        DestIP       string
        DestMAC      string
        Details      map[string]interface{}
}

func NewNetworkAttackDetector() *NetworkAttackDetector <span class="cov8" title="1">{
        return &amp;NetworkAttackDetector{
                ipMacMap:      make(map[string]MACEntry),
                macChangeLog:  make([]MACChangeEvent, 0),
                arpTable:      make(map[string]ARPEntry),
                arpRequests:   make(map[string][]time.Time),
                dhcpServers:   make(map[string]DHCPServer),
                dhcpRequests:  make(map[string][]time.Time),
                dhcpLeases:    make(map[string]DHCPLease),
                dnsServers:    make(map[string]DNSServer),
                dnsQueries:    make(map[string][]DNSQuery),
                dnsResponses:  make(map[string][]DNSResponse),
                wifiClients:   make(map[string]WiFiClient),
                deauthPackets: make([]DeauthEvent, 0),
                beacons:       make(map[string][]BeaconFrame),
                vlanTraffic:   make(map[uint16]VLANStats),
                alerts:        make([]AttackAlert, 0),
        }
}</span>

func (nad *NetworkAttackDetector) ProcessPacket(packet gopacket.Packet) []AttackAlert <span class="cov0" title="0">{
        nad.mu.Lock()
        defer nad.mu.Unlock()
        
        nad.stats.TotalPackets++
        var alerts []AttackAlert
        
        // Layer 2 analysis
        if ethLayer := packet.Layer(layers.LayerTypeEthernet); ethLayer != nil </span><span class="cov0" title="0">{
                eth := ethLayer.(*layers.Ethernet)
                
                // Check for monitor mode indicators
                if nad.detectMonitorMode(packet) </span><span class="cov0" title="0">{
                        alert := nad.createAlert("monitor_mode", "high", 
                                "Monitor mode detected - possible wireless sniffing",
                                "", eth.SrcMAC.String(), "", eth.DstMAC.String(),
                                map[string]interface{}{"interface": "unknown"})
                        alerts = append(alerts, alert)
                        nad.stats.MonitorMode++
                }</span>
                
                // VLAN analysis
                <span class="cov0" title="0">if vlanLayer := packet.Layer(layers.LayerTypeDot1Q); vlanLayer != nil </span><span class="cov0" title="0">{
                        vlan := vlanLayer.(*layers.Dot1Q)
                        nad.analyzeVLAN(vlan, packet)
                }</span>
        }
        
        // ARP analysis
        <span class="cov0" title="0">if arpLayer := packet.Layer(layers.LayerTypeARP); arpLayer != nil </span><span class="cov0" title="0">{
                arp := arpLayer.(*layers.ARP)
                if arpAlerts := nad.analyzeARP(arp, packet); len(arpAlerts) &gt; 0 </span><span class="cov0" title="0">{
                        alerts = append(alerts, arpAlerts...)
                }</span>
        }
        
        // IP layer analysis for MAC tracking
        <span class="cov0" title="0">if netLayer := packet.NetworkLayer(); netLayer != nil </span><span class="cov0" title="0">{
                if ethLayer := packet.Layer(layers.LayerTypeEthernet); ethLayer != nil </span><span class="cov0" title="0">{
                        eth := ethLayer.(*layers.Ethernet)
                        srcIP := netLayer.NetworkFlow().Src().String()
                        
                        // Track IP-MAC mappings
                        if macAlerts := nad.trackIPMAC(srcIP, eth.SrcMAC.String()); len(macAlerts) &gt; 0 </span><span class="cov0" title="0">{
                                alerts = append(alerts, macAlerts...)
                        }</span>
                }
        }
        
        // DHCP analysis
        <span class="cov0" title="0">if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil </span><span class="cov0" title="0">{
                udp := udpLayer.(*layers.UDP)
                if udp.SrcPort == 67 || udp.DstPort == 67 || udp.SrcPort == 68 || udp.DstPort == 68 </span><span class="cov0" title="0">{
                        if dhcpAlerts := nad.analyzeDHCP(packet); len(dhcpAlerts) &gt; 0 </span><span class="cov0" title="0">{
                                alerts = append(alerts, dhcpAlerts...)
                        }</span>
                }
        }
        
        // DNS analysis
        <span class="cov0" title="0">if dnsLayer := packet.Layer(layers.LayerTypeDNS); dnsLayer != nil </span><span class="cov0" title="0">{
                dns := dnsLayer.(*layers.DNS)
                if dnsAlerts := nad.analyzeDNS(dns, packet); len(dnsAlerts) &gt; 0 </span><span class="cov0" title="0">{
                        alerts = append(alerts, dnsAlerts...)
                }</span>
        }
        
        // WiFi analysis (802.11)
        <span class="cov0" title="0">if dot11Layer := packet.Layer(layers.LayerTypeDot11); dot11Layer != nil </span><span class="cov0" title="0">{
                if wifiAlerts := nad.analyzeWiFi(packet); len(wifiAlerts) &gt; 0 </span><span class="cov0" title="0">{
                        alerts = append(alerts, wifiAlerts...)
                }</span>
        }
        
        // Add alerts to history
        <span class="cov0" title="0">nad.alerts = append(nad.alerts, alerts...)
        
        // Cleanup old data
        if len(nad.alerts) &gt; 10000 </span><span class="cov0" title="0">{
                nad.alerts = nad.alerts[len(nad.alerts)-10000:]
        }</span>
        
        <span class="cov0" title="0">return alerts</span>
}

// MAC Spoofing Detection

func (nad *NetworkAttackDetector) trackIPMAC(ip, mac string) []AttackAlert <span class="cov0" title="0">{
        var alerts []AttackAlert
        
        if entry, exists := nad.ipMacMap[ip]; exists </span><span class="cov0" title="0">{
                if entry.MAC != mac </span><span class="cov0" title="0">{
                        // MAC address changed for this IP
                        event := MACChangeEvent{
                                Timestamp:  time.Now(),
                                IP:         ip,
                                OldMAC:     entry.MAC,
                                NewMAC:     mac,
                                Suspicious: nad.isSuspiciousMACChange(entry.MAC, mac),
                        }
                        
                        nad.macChangeLog = append(nad.macChangeLog, event)
                        
                        if event.Suspicious </span><span class="cov0" title="0">{
                                alert := nad.createAlert("mac_spoofing", "high",
                                        fmt.Sprintf("MAC address spoofing detected for IP %s", ip),
                                        ip, mac, "", "",
                                        map[string]interface{}{
                                                "old_mac": entry.MAC,
                                                "new_mac": mac,
                                                "vendor_change": nad.getVendor(entry.MAC) != nad.getVendor(mac),
                                        })
                                alerts = append(alerts, alert)
                                nad.stats.MacSpoofing++
                        }</span>
                        
                        // Update entry
                        <span class="cov0" title="0">entry.MAC = mac
                        entry.LastSeen = time.Now()</span>
                } else<span class="cov0" title="0"> {
                        entry.LastSeen = time.Now()
                        entry.PacketCount++
                }</span>
                <span class="cov0" title="0">nad.ipMacMap[ip] = entry</span>
        } else<span class="cov0" title="0"> {
                // New IP-MAC mapping
                nad.ipMacMap[ip] = MACEntry{
                        IP:          ip,
                        MAC:         mac,
                        FirstSeen:   time.Now(),
                        LastSeen:    time.Now(),
                        PacketCount: 1,
                        Vendor:      nad.getVendor(mac),
                }
        }</span>
        
        <span class="cov0" title="0">return alerts</span>
}

func (nad *NetworkAttackDetector) isSuspiciousMACChange(oldMAC, newMAC string) bool <span class="cov0" title="0">{
        // Check if vendor changed (first 3 octets)
        if len(oldMAC) &gt;= 8 &amp;&amp; len(newMAC) &gt;= 8 </span><span class="cov0" title="0">{
                return oldMAC[:8] != newMAC[:8]
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (nad *NetworkAttackDetector) getVendor(mac string) string <span class="cov0" title="0">{
        // Simplified vendor lookup - in production would use OUI database
        if len(mac) &lt; 8 </span><span class="cov0" title="0">{
                return "Unknown"
        }</span>
        
        <span class="cov0" title="0">oui := mac[:8]
        vendorMap := map[string]string{
                "00:50:56": "VMware",
                "00:0C:29": "VMware",
                "00:1C:42": "Parallels",
                "08:00:27": "VirtualBox",
                "52:54:00": "QEMU/KVM",
                "00:15:5D": "Hyper-V",
        }
        
        if vendor, ok := vendorMap[oui]; ok </span><span class="cov0" title="0">{
                return vendor
        }</span>
        
        <span class="cov0" title="0">return "Unknown"</span>
}

// ARP Spoofing Detection

func (nad *NetworkAttackDetector) analyzeARP(arp *layers.ARP, packet gopacket.Packet) []AttackAlert <span class="cov0" title="0">{
        var alerts []AttackAlert
        
        srcIP := net.IP(arp.SourceProtAddress).String()
        srcMAC := net.HardwareAddr(arp.SourceHwAddress).String()
        dstIP := net.IP(arp.DstProtAddress).String()
        
        // Track ARP requests for flood detection
        nad.arpRequests[srcMAC] = append(nad.arpRequests[srcMAC], time.Now())
        
        // Check for ARP flooding
        if len(nad.arpRequests[srcMAC]) &gt; 10 </span><span class="cov0" title="0">{
                // Clean old entries
                cutoff := time.Now().Add(-10 * time.Second)
                var recent []time.Time
                for _, t := range nad.arpRequests[srcMAC] </span><span class="cov0" title="0">{
                        if t.After(cutoff) </span><span class="cov0" title="0">{
                                recent = append(recent, t)
                        }</span>
                }
                <span class="cov0" title="0">nad.arpRequests[srcMAC] = recent
                
                if len(recent) &gt; 10 </span><span class="cov0" title="0">{
                        alert := nad.createAlert("arp_flood", "medium",
                                "ARP request flood detected",
                                srcIP, srcMAC, dstIP, "",
                                map[string]interface{}{
                                        "request_count": len(recent),
                                        "time_window": "10s",
                                })
                        alerts = append(alerts, alert)
                }</span>
        }
        
        // Check for gratuitous ARP (potential ARP poisoning)
        <span class="cov0" title="0">if arp.Operation == layers.ARPRequest &amp;&amp; srcIP == dstIP </span><span class="cov0" title="0">{
                // Gratuitous ARP
                if entry, exists := nad.arpTable[srcIP]; exists </span><span class="cov0" title="0">{
                        if entry.MAC != srcMAC </span><span class="cov0" title="0">{
                                // MAC changed via gratuitous ARP - highly suspicious
                                alert := nad.createAlert("arp_poisoning", "critical",
                                        fmt.Sprintf("ARP cache poisoning detected for IP %s", srcIP),
                                        srcIP, srcMAC, "", "",
                                        map[string]interface{}{
                                                "type": "gratuitous_arp",
                                                "old_mac": entry.MAC,
                                                "new_mac": srcMAC,
                                        })
                                alerts = append(alerts, alert)
                                nad.stats.ArpSpoofing++
                        }</span>
                }
                
                <span class="cov0" title="0">nad.arpTable[srcIP] = ARPEntry{
                        IP:           srcIP,
                        MAC:          srcMAC,
                        LastUpdated:  time.Now(),
                        IsGratuitous: true,
                }</span>
        } else<span class="cov0" title="0"> if arp.Operation == layers.ARPReply </span><span class="cov0" title="0">{
                // Check for unsolicited ARP replies
                if _, requested := nad.arpRequests[dstIP]; !requested </span><span class="cov0" title="0">{
                        alert := nad.createAlert("arp_spoofing", "high",
                                "Unsolicited ARP reply detected",
                                srcIP, srcMAC, dstIP, "",
                                map[string]interface{}{
                                        "type": "unsolicited_reply",
                                })
                        alerts = append(alerts, alert)
                        nad.stats.ArpSpoofing++
                }</span>
                
                // Update ARP table
                <span class="cov0" title="0">nad.arpTable[srcIP] = ARPEntry{
                        IP:          srcIP,
                        MAC:         srcMAC,
                        LastUpdated: time.Now(),
                }</span>
        }
        
        // Check for ARP spoofing patterns
        <span class="cov0" title="0">if arp.Operation == layers.ARPReply </span><span class="cov0" title="0">{
                // Multiple IPs claiming same MAC
                ipCount := 0
                for ip, entry := range nad.arpTable </span><span class="cov0" title="0">{
                        if entry.MAC == srcMAC &amp;&amp; ip != srcIP </span><span class="cov0" title="0">{
                                ipCount++
                        }</span>
                }
                
                <span class="cov0" title="0">if ipCount &gt; 0 </span><span class="cov0" title="0">{
                        alert := nad.createAlert("arp_spoofing", "high",
                                fmt.Sprintf("Multiple IPs (%d) using same MAC address", ipCount+1),
                                srcIP, srcMAC, "", "",
                                map[string]interface{}{
                                        "mac_address": srcMAC,
                                        "ip_count": ipCount + 1,
                                })
                        alerts = append(alerts, alert)
                        nad.stats.ArpSpoofing++
                }</span>
        }
        
        <span class="cov0" title="0">return alerts</span>
}

// DHCP Attack Detection

func (nad *NetworkAttackDetector) analyzeDHCP(packet gopacket.Packet) []AttackAlert <span class="cov0" title="0">{
        var alerts []AttackAlert
        
        // Extract DHCP data from packet payload
        appLayer := packet.ApplicationLayer()
        if appLayer == nil </span><span class="cov0" title="0">{
                return alerts
        }</span>
        
        <span class="cov0" title="0">payload := appLayer.Payload()
        if len(payload) &lt; 240 </span><span class="cov0" title="0">{ // Minimum DHCP packet size
                return alerts
        }</span>
        
        // Simple DHCP message type detection
        <span class="cov0" title="0">msgType := nad.getDHCPMessageType(payload)
        
        netLayer := packet.NetworkLayer()
        ethLayer := packet.Layer(layers.LayerTypeEthernet)
        
        if netLayer == nil || ethLayer == nil </span><span class="cov0" title="0">{
                return alerts
        }</span>
        
        <span class="cov0" title="0">eth := ethLayer.(*layers.Ethernet)
        srcIP := netLayer.NetworkFlow().Src().String()
        srcMAC := eth.SrcMAC.String()
        
        switch msgType </span>{
        case 1:<span class="cov0" title="0"> // DHCP Discover
                // Track DHCP requests for starvation attack
                nad.dhcpRequests[srcMAC] = append(nad.dhcpRequests[srcMAC], time.Now())
                
                // Check for DHCP starvation
                if len(nad.dhcpRequests[srcMAC]) &gt; 5 </span><span class="cov0" title="0">{
                        cutoff := time.Now().Add(-30 * time.Second)
                        var recent []time.Time
                        for _, t := range nad.dhcpRequests[srcMAC] </span><span class="cov0" title="0">{
                                if t.After(cutoff) </span><span class="cov0" title="0">{
                                        recent = append(recent, t)
                                }</span>
                        }
                        <span class="cov0" title="0">nad.dhcpRequests[srcMAC] = recent
                        
                        if len(recent) &gt; 5 </span><span class="cov0" title="0">{
                                alert := nad.createAlert("dhcp_starvation", "high",
                                        "DHCP starvation attack detected",
                                        srcIP, srcMAC, "", "",
                                        map[string]interface{}{
                                                "request_count": len(recent),
                                                "time_window": "30s",
                                        })
                                alerts = append(alerts, alert)
                                nad.stats.DhcpAttacks++
                        }</span>
                }
                
        case 2:<span class="cov0" title="0"> // DHCP Offer
                // Track DHCP servers
                if server, exists := nad.dhcpServers[srcIP]; exists </span><span class="cov0" title="0">{
                        server.LastSeen = time.Now()
                        server.OffersCount++
                        nad.dhcpServers[srcIP] = server
                }</span> else<span class="cov0" title="0"> {
                        nad.dhcpServers[srcIP] = DHCPServer{
                                IP:          srcIP,
                                MAC:         srcMAC,
                                FirstSeen:   time.Now(),
                                LastSeen:    time.Now(),
                                OffersCount: 1,
                                Legitimate:  nad.isLegitDHCPServer(srcIP),
                        }
                }</span>
                
                // Check for rogue DHCP server
                <span class="cov0" title="0">if !nad.isLegitDHCPServer(srcIP) </span><span class="cov0" title="0">{
                        alert := nad.createAlert("rogue_dhcp_server", "critical",
                                "Rogue DHCP server detected",
                                srcIP, srcMAC, "", "",
                                map[string]interface{}{
                                        "server_ip": srcIP,
                                        "server_mac": srcMAC,
                                })
                        alerts = append(alerts, alert)
                        nad.stats.DhcpAttacks++
                }</span>
                
                // Check for multiple DHCP servers
                <span class="cov0" title="0">activeServers := 0
                for _, server := range nad.dhcpServers </span><span class="cov0" title="0">{
                        if time.Since(server.LastSeen) &lt; 5*time.Minute </span><span class="cov0" title="0">{
                                activeServers++
                        }</span>
                }
                
                <span class="cov0" title="0">if activeServers &gt; 1 </span><span class="cov0" title="0">{
                        alert := nad.createAlert("multiple_dhcp_servers", "medium",
                                fmt.Sprintf("Multiple DHCP servers detected (%d active)", activeServers),
                                srcIP, srcMAC, "", "",
                                map[string]interface{}{
                                        "server_count": activeServers,
                                })
                        alerts = append(alerts, alert)
                }</span>
        }
        
        <span class="cov0" title="0">return alerts</span>
}

func (nad *NetworkAttackDetector) getDHCPMessageType(payload []byte) byte <span class="cov0" title="0">{
        // Simple DHCP option parsing
        if len(payload) &lt; 240 </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        // Skip to options (after 240 bytes of fixed fields)
        <span class="cov0" title="0">options := payload[240:]
        
        for i := 0; i &lt; len(options)-2; i++ </span><span class="cov0" title="0">{
                if options[i] == 53 </span><span class="cov0" title="0">{ // DHCP Message Type option
                        return options[i+2]
                }</span>
        }
        
        <span class="cov0" title="0">return 0</span>
}

func (nad *NetworkAttackDetector) isLegitDHCPServer(ip string) bool <span class="cov0" title="0">{
        // In production, this would check against a whitelist
        // For now, assume router IPs are legitimate
        return ip == "192.168.1.1" || ip == "192.168.0.1" || ip == "10.0.0.1"
}</span>

// DNS Hijacking Detection

func (nad *NetworkAttackDetector) analyzeDNS(dns *layers.DNS, packet gopacket.Packet) []AttackAlert <span class="cov0" title="0">{
        var alerts []AttackAlert
        
        netLayer := packet.NetworkLayer()
        if netLayer == nil </span><span class="cov0" title="0">{
                return alerts
        }</span>
        
        <span class="cov0" title="0">srcIP := netLayer.NetworkFlow().Src().String()
        dstIP := netLayer.NetworkFlow().Dst().String()
        
        if dns.QR </span><span class="cov0" title="0">{ // DNS Response
                // Track DNS servers
                if server, exists := nad.dnsServers[srcIP]; exists </span><span class="cov0" title="0">{
                        server.LastSeen = time.Now()
                        server.ResponseCount++
                        nad.dnsServers[srcIP] = server
                }</span> else<span class="cov0" title="0"> {
                        nad.dnsServers[srcIP] = DNSServer{
                                IP:            srcIP,
                                FirstSeen:     time.Now(),
                                LastSeen:      time.Now(),
                                ResponseCount: 1,
                                Legitimate:    nad.isLegitDNSServer(srcIP),
                        }
                }</span>
                
                // Check for DNS hijacking indicators
                <span class="cov0" title="0">if !nad.isLegitDNSServer(srcIP) </span><span class="cov0" title="0">{
                        alert := nad.createAlert("dns_hijacking", "high",
                                "DNS response from unauthorized server",
                                srcIP, "", dstIP, "",
                                map[string]interface{}{
                                        "dns_server": srcIP,
                                        "query_id": dns.ID,
                                })
                        alerts = append(alerts, alert)
                        nad.stats.DnsHijacking++
                }</span>
                
                // Check for cache poisoning attempts
                <span class="cov0" title="0">queryKey := fmt.Sprintf("%s:%d", dstIP, dns.ID)
                if queries, exists := nad.dnsQueries[queryKey]; exists &amp;&amp; len(queries) &gt; 0 </span><span class="cov0" title="0">{
                        // Valid response to a query
                        response := DNSResponse{
                                Timestamp: time.Now(),
                                QueryID:   dns.ID,
                                ServerIP:  srcIP,
                                ClientIP:  dstIP,
                                Answers:   make([]string, 0),
                        }
                        
                        // Extract answers
                        for _, answer := range dns.Answers </span><span class="cov0" title="0">{
                                if answer.Type == layers.DNSTypeA </span><span class="cov0" title="0">{
                                        response.Answers = append(response.Answers, answer.IP.String())
                                }</span>
                        }
                        
                        // Check for suspicious responses
                        <span class="cov0" title="0">if nad.isSuspiciousDNSResponse(response) </span><span class="cov0" title="0">{
                                response.Suspicious = true
                                alert := nad.createAlert("dns_hijacking", "high",
                                        "Suspicious DNS response detected",
                                        srcIP, "", dstIP, "",
                                        map[string]interface{}{
                                                "answers": response.Answers,
                                                "query_id": dns.ID,
                                        })
                                alerts = append(alerts, alert)
                                nad.stats.DnsHijacking++
                        }</span>
                        
                        <span class="cov0" title="0">nad.dnsResponses[queryKey] = append(nad.dnsResponses[queryKey], response)</span>
                } else<span class="cov0" title="0"> {
                        // Unsolicited DNS response
                        alert := nad.createAlert("dns_cache_poisoning", "critical",
                                "Unsolicited DNS response - possible cache poisoning",
                                srcIP, "", dstIP, "",
                                map[string]interface{}{
                                        "query_id": dns.ID,
                                        "response_code": dns.ResponseCode.String(),
                                })
                        alerts = append(alerts, alert)
                        nad.stats.DnsHijacking++
                }</span>
        } else<span class="cov0" title="0"> { // DNS Query
                for _, question := range dns.Questions </span><span class="cov0" title="0">{
                        query := DNSQuery{
                                Timestamp: time.Now(),
                                QueryID:   dns.ID,
                                ClientIP:  srcIP,
                                ServerIP:  dstIP,
                                QueryName: string(question.Name),
                                QueryType: question.Type.String(),
                        }
                        
                        queryKey := fmt.Sprintf("%s:%d", srcIP, dns.ID)
                        nad.dnsQueries[queryKey] = append(nad.dnsQueries[queryKey], query)
                        
                        // Cleanup old queries
                        if len(nad.dnsQueries[queryKey]) &gt; 10 </span><span class="cov0" title="0">{
                                nad.dnsQueries[queryKey] = nad.dnsQueries[queryKey][len(nad.dnsQueries[queryKey])-10:]
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return alerts</span>
}

func (nad *NetworkAttackDetector) isLegitDNSServer(ip string) bool <span class="cov0" title="0">{
        // Check against known DNS servers
        legitServers := []string{
                "8.8.8.8", "8.8.4.4", // Google
                "1.1.1.1", "1.0.0.1", // Cloudflare
                "9.9.9.9",            // Quad9
                "208.67.222.222",     // OpenDNS
                "192.168.1.1",        // Common router
                "192.168.0.1",
                "10.0.0.1",
        }
        
        for _, server := range legitServers </span><span class="cov0" title="0">{
                if ip == server </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

func (nad *NetworkAttackDetector) isSuspiciousDNSResponse(response DNSResponse) bool <span class="cov0" title="0">{
        // Check for known malicious IPs in responses
        maliciousIPs := []string{
                "0.0.0.0",
                "127.0.0.1", // Localhost redirect
                "::1",       // IPv6 localhost
        }
        
        for _, answer := range response.Answers </span><span class="cov0" title="0">{
                for _, malIP := range maliciousIPs </span><span class="cov0" title="0">{
                        if answer == malIP </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return false</span>
}

// WiFi Attack Detection

func (nad *NetworkAttackDetector) analyzeWiFi(packet gopacket.Packet) []AttackAlert <span class="cov0" title="0">{
        var alerts []AttackAlert
        
        dot11 := packet.Layer(layers.LayerTypeDot11).(*layers.Dot11)
        
        // Deauthentication attack detection
        if dot11.Type == layers.Dot11TypeMgmtDeauthentication </span><span class="cov0" title="0">{
                deauth := DeauthEvent{
                        Timestamp: time.Now(),
                        SourceMAC: dot11.Address2.String(),
                        DestMAC:   dot11.Address1.String(),
                        BSSID:     dot11.Address3.String(),
                }
                
                nad.deauthPackets = append(nad.deauthPackets, deauth)
                
                // Check for deauth flood
                recentDeauths := 0
                cutoff := time.Now().Add(-10 * time.Second)
                for _, d := range nad.deauthPackets </span><span class="cov0" title="0">{
                        if d.Timestamp.After(cutoff) &amp;&amp; d.BSSID == deauth.BSSID </span><span class="cov0" title="0">{
                                recentDeauths++
                        }</span>
                }
                
                <span class="cov0" title="0">if recentDeauths &gt; 10 </span><span class="cov0" title="0">{
                        alert := nad.createAlert("wifi_deauth_attack", "high",
                                "WiFi deauthentication attack detected",
                                "", deauth.SourceMAC, "", deauth.DestMAC,
                                map[string]interface{}{
                                        "bssid": deauth.BSSID,
                                        "deauth_count": recentDeauths,
                                        "time_window": "10s",
                                })
                        alerts = append(alerts, alert)
                        nad.stats.WiFiAttacks++
                }</span>
        }
        
        // Beacon frame analysis for Evil Twin detection
        <span class="cov0" title="0">if dot11.Type == layers.Dot11TypeMgmtBeacon </span><span class="cov0" title="0">{
                if mgmtLayer := packet.Layer(layers.LayerTypeDot11MgmtBeacon); mgmtLayer != nil </span><span class="cov0" title="0">{
                        beacon := BeaconFrame{
                                Timestamp: time.Now(),
                                BSSID:     dot11.Address3.String(),
                        }
                        
                        // Extract SSID and other info
                        // (Simplified - would need proper IE parsing)
                        
                        bssid := beacon.BSSID
                        nad.beacons[bssid] = append(nad.beacons[bssid], beacon)
                        
                        // Check for Evil Twin (duplicate SSID with different BSSID)
                        for otherBSSID, otherBeacons := range nad.beacons </span><span class="cov0" title="0">{
                                if otherBSSID != bssid &amp;&amp; len(otherBeacons) &gt; 0 </span><span class="cov0" title="0">{
                                        if beacon.SSID == otherBeacons[0].SSID </span><span class="cov0" title="0">{
                                                alert := nad.createAlert("evil_twin_ap", "critical",
                                                        fmt.Sprintf("Evil Twin AP detected - duplicate SSID: %s", beacon.SSID),
                                                        "", beacon.BSSID, "", "",
                                                        map[string]interface{}{
                                                                "ssid": beacon.SSID,
                                                                "legitimate_bssid": otherBSSID,
                                                                "rogue_bssid": beacon.BSSID,
                                                        })
                                                alerts = append(alerts, alert)
                                                nad.stats.WiFiAttacks++
                                        }</span>
                                }
                        }
                }
        }
        
        // Probe request tracking
        <span class="cov0" title="0">if dot11.Type == layers.Dot11TypeMgmtProbeReq </span><span class="cov0" title="0">{
                client := nad.wifiClients[dot11.Address2.String()]
                client.MAC = dot11.Address2.String()
                client.LastSeen = time.Now()
                if client.FirstSeen.IsZero() </span><span class="cov0" title="0">{
                        client.FirstSeen = time.Now()
                }</span>
                
                // Track probe requests for client tracking
                <span class="cov0" title="0">nad.wifiClients[client.MAC] = client</span>
        }
        
        <span class="cov0" title="0">return alerts</span>
}

// VLAN Attack Detection

func (nad *NetworkAttackDetector) analyzeVLAN(vlan *layers.Dot1Q, packet gopacket.Packet) <span class="cov0" title="0">{
        vlanID := vlan.VLANIdentifier
        
        stats, exists := nad.vlanTraffic[vlanID]
        if !exists </span><span class="cov0" title="0">{
                stats = VLANStats{
                        ID:        vlanID,
                        FirstSeen: time.Now(),
                }
        }</span>
        
        <span class="cov0" title="0">stats.PacketCount++
        stats.ByteCount += int64(len(packet.Data()))
        stats.LastSeen = time.Now()
        
        // Check for double tagging (VLAN hopping attack)
        if nextVLAN := packet.Layer(layers.LayerTypeDot1Q); nextVLAN != nil &amp;&amp; nextVLAN != vlan </span><span class="cov0" title="0">{
                stats.DoubleTagged = true
                
                alert := nad.createAlert("vlan_hopping", "high",
                        fmt.Sprintf("VLAN hopping attack detected - double tagged packet on VLAN %d", vlanID),
                        "", "", "", "",
                        map[string]interface{}{
                                "outer_vlan": vlanID,
                                "technique": "double_tagging",
                        })
                nad.alerts = append(nad.alerts, alert)
                nad.stats.VlanAttacks++
        }</span>
        
        <span class="cov0" title="0">nad.vlanTraffic[vlanID] = stats</span>
}

// Monitor Mode Detection

func (nad *NetworkAttackDetector) detectMonitorMode(packet gopacket.Packet) bool <span class="cov0" title="0">{
        // Check for RadioTap header (indicates monitor mode capture)
        if packet.Layer(layers.LayerTypeRadioTap) != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Check for malformed packets that might indicate promiscuous mode
        <span class="cov0" title="0">if packet.ErrorLayer() != nil </span><span class="cov0" title="0">{
                // High number of malformed packets might indicate monitor mode
                return false // Need more sophisticated detection
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

// Helper functions

func (nad *NetworkAttackDetector) createAlert(attackType, severity, description, srcIP, srcMAC, dstIP, dstMAC string, details map[string]interface{}) AttackAlert <span class="cov0" title="0">{
        return AttackAlert{
                Timestamp:   time.Now(),
                Type:        attackType,
                Severity:    severity,
                Description: description,
                SourceIP:    srcIP,
                SourceMAC:   srcMAC,
                DestIP:      dstIP,
                DestMAC:     dstMAC,
                Details:     details,
        }
}</span>

// Getters

func (nad *NetworkAttackDetector) GetAlerts() []AttackAlert <span class="cov0" title="0">{
        nad.mu.RLock()
        defer nad.mu.RUnlock()
        
        return append([]AttackAlert{}, nad.alerts...)
}</span>

func (nad *NetworkAttackDetector) GetStats() AttackStats <span class="cov0" title="0">{
        nad.mu.RLock()
        defer nad.mu.RUnlock()
        
        return nad.stats
}</span>

func (nad *NetworkAttackDetector) GetMACChanges() []MACChangeEvent <span class="cov0" title="0">{
        nad.mu.RLock()
        defer nad.mu.RUnlock()
        
        return append([]MACChangeEvent{}, nad.macChangeLog...)
}</span>

// Cleanup

func (nad *NetworkAttackDetector) Cleanup() <span class="cov0" title="0">{
        nad.mu.Lock()
        defer nad.mu.Unlock()
        
        // Clean old entries
        cutoff := time.Now().Add(-1 * time.Hour)
        
        // Clean MAC entries
        for ip, entry := range nad.ipMacMap </span><span class="cov0" title="0">{
                if entry.LastSeen.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(nad.ipMacMap, ip)
                }</span>
        }
        
        // Clean ARP entries
        <span class="cov0" title="0">for ip, entry := range nad.arpTable </span><span class="cov0" title="0">{
                if entry.LastUpdated.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(nad.arpTable, ip)
                }</span>
        }
        
        // Clean DNS queries
        <span class="cov0" title="0">for key, queries := range nad.dnsQueries </span><span class="cov0" title="0">{
                if len(queries) &gt; 0 &amp;&amp; queries[len(queries)-1].Timestamp.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(nad.dnsQueries, key)
                }</span>
        }
        
        // Limit alert history
        <span class="cov0" title="0">if len(nad.alerts) &gt; 10000 </span><span class="cov0" title="0">{
                nad.alerts = nad.alerts[len(nad.alerts)-10000:]
        }</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package security

import (
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
        "gopkg.in/yaml.v3"
)

// SigmaEngine implements Sigma rule processing for generic SIEM detection
type SigmaEngine struct {
        rules    []SigmaRule
        alerts   []SigmaAlert
        stats    SigmaStats
        fieldMap map[string]string // Maps Sigma fields to packet fields
}

type SigmaRule struct {
        Title         string                            `yaml:"title"`
        ID            string                            `yaml:"id"`
        Status        string                            `yaml:"status"`
        Description   string                            `yaml:"description"`
        Author        string                            `yaml:"author"`
        Date          string                            `yaml:"date"`
        Modified      string                            `yaml:"modified"`
        References    []string                          `yaml:"references"`
        Tags          []string                          `yaml:"tags"`
        LogSource     SigmaLogSource                    `yaml:"logsource"`
        Detection     SigmaDetection                    `yaml:"detection"`
        Fields        []string                          `yaml:"fields"`
        FalsePositives []string                         `yaml:"falsepositives"`
        Level         string                            `yaml:"level"`
        Compiled      *CompiledSigmaRule                `yaml:"-"`
}

type SigmaLogSource struct {
        Category   string `yaml:"category"`
        Product    string `yaml:"product"`
        Service    string `yaml:"service"`
        Definition string `yaml:"definition"`
}

type SigmaDetection struct {
        Selection  map[string]interface{} `yaml:"selection"`
        Condition  string                 `yaml:"condition"`
        Timeframe  string                 `yaml:"timeframe"`
        Filters    []map[string]interface{} `yaml:"filter"`
}

type CompiledSigmaRule struct {
        Matchers  []FieldMatcher
        Condition *ConditionEvaluator
        Timeframe time.Duration
}

type FieldMatcher struct {
        Field     string
        Operator  string // "equals", "contains", "startswith", "endswith", "regex", "gt", "lt", "gte", "lte"
        Value     interface{}
        Modifiers []string // "all", "ignorecase"
}

type ConditionEvaluator struct {
        Expression string
        Type       string // "and", "or", "not", "near", "sequence"
        Operands   []*ConditionEvaluator
}

type SigmaAlert struct {
        Timestamp  time.Time              `json:"timestamp"`
        RuleID     string                 `json:"rule_id"`
        RuleTitle  string                 `json:"rule_title"`
        Level      string                 `json:"level"`
        Tags       []string               `json:"tags"`
        Message    string                 `json:"message"`
        MatchedFields map[string]interface{} `json:"matched_fields"`
        PacketInfo map[string]interface{} `json:"packet_info"`
        References []string               `json:"references"`
}

type SigmaStats struct {
        TotalPackets   uint64
        TotalAlerts    uint64
        AlertsByRule   map[string]uint64
        AlertsByLevel  map[string]uint64
        AlertsByTag    map[string]uint64
}

func NewSigmaEngine() *SigmaEngine <span class="cov1" title="1">{
        engine := &amp;SigmaEngine{
                rules:  make([]SigmaRule, 0),
                alerts: make([]SigmaAlert, 0),
                stats: SigmaStats{
                        AlertsByRule:  make(map[string]uint64),
                        AlertsByLevel: make(map[string]uint64),
                        AlertsByTag:   make(map[string]uint64),
                },
                fieldMap: make(map[string]string),
        }
        
        engine.initFieldMapping()
        engine.loadDefaultRules()
        
        return engine
}</span>

func (se *SigmaEngine) initFieldMapping() <span class="cov1" title="1">{
        // Map Sigma field names to packet fields
        se.fieldMap = map[string]string{
                // Network fields
                "source.ip":        "src_ip",
                "destination.ip":   "dst_ip",
                "source.port":      "src_port",
                "destination.port": "dst_port",
                "network.protocol": "protocol",
                "network.transport": "transport",
                
                // DNS fields
                "dns.question.name": "dns_query",
                "dns.question.type": "dns_query_type",
                "dns.response_code": "dns_response_code",
                
                // HTTP fields
                "http.request.method": "http_method",
                "http.request.url": "http_url",
                "http.request.body.content": "http_body",
                "http.response.status_code": "http_status",
                "user_agent": "http_user_agent",
                
                // Process fields (for endpoint detection)
                "process.command_line": "command_line",
                "process.name": "process_name",
                "process.parent.name": "parent_process",
                
                // File fields
                "file.path": "file_path",
                "file.name": "file_name",
                "file.hash.md5": "file_md5",
                "file.hash.sha256": "file_sha256",
                
                // Event fields
                "event.category": "event_category",
                "event.type": "event_type",
                "event.action": "event_action",
        }
}</span>

func (se *SigmaEngine) loadDefaultRules() <span class="cov1" title="1">{
        // Load default Sigma rules for network detection
        defaultRules := []SigmaRule{
                {
                        Title:       "Suspicious Network Scanning Activity",
                        ID:          "sigma-net-001",
                        Status:      "stable",
                        Description: "Detects potential network scanning based on connection patterns",
                        Author:      "NetMon Security",
                        Level:       "medium",
                        Tags:        []string{"attack.discovery", "attack.t1046"},
                        LogSource: SigmaLogSource{
                                Category: "network",
                                Product:  "netmon",
                        },
                        Detection: SigmaDetection{
                                Selection: map[string]interface{}{
                                        "destination.port|count|gte": 20,
                                        "source.ip|grouped": true,
                                        "timeframe": "60s",
                                },
                                Condition: "selection",
                        },
                },
                {
                        Title:       "Potential SQL Injection Attack",
                        ID:          "sigma-web-001", 
                        Status:      "stable",
                        Description: "Detects potential SQL injection attempts in web traffic",
                        Author:      "NetMon Security",
                        Level:       "high",
                        Tags:        []string{"attack.initial_access", "attack.t1190"},
                        LogSource: SigmaLogSource{
                                Category: "webserver",
                                Product:  "netmon",
                        },
                        Detection: SigmaDetection{
                                Selection: map[string]interface{}{
                                        "http.request.url|contains|all": []string{"UNION", "SELECT"},
                                        "http.request.method": "GET",
                                },
                                Condition: "selection",
                        },
                        FalsePositives: []string{"Legitimate database administration tools"},
                },
                {
                        Title:       "DNS Tunneling Detection",
                        ID:          "sigma-dns-001",
                        Status:      "experimental",
                        Description: "Detects potential DNS tunneling based on query characteristics",
                        Author:      "NetMon Security",
                        Level:       "medium",
                        Tags:        []string{"attack.exfiltration", "attack.t1048"},
                        LogSource: SigmaLogSource{
                                Category: "dns",
                                Product:  "netmon",
                        },
                        Detection: SigmaDetection{
                                Selection: map[string]interface{}{
                                        "dns.question.name|regex": "[a-zA-Z0-9]{50,}\\.",
                                        "dns.question.type": "TXT",
                                },
                                Condition: "selection",
                        },
                },
                {
                        Title:       "Suspicious Outbound SMTP Traffic",
                        ID:          "sigma-email-001",
                        Status:      "stable",
                        Description: "Detects unusual SMTP traffic that may indicate spam or malware",
                        Author:      "NetMon Security",
                        Level:       "medium",
                        Tags:        []string{"attack.collection", "attack.t1114"},
                        LogSource: SigmaLogSource{
                                Category: "network",
                                Product:  "netmon",
                        },
                        Detection: SigmaDetection{
                                Selection: map[string]interface{}{
                                        "destination.port": 25,
                                        "source.ip|private": false,
                                        "destination.ip|count|gt": 5,
                                },
                                Condition: "selection",
                                Timeframe: "5m",
                        },
                },
                {
                        Title:       "Potential Brute Force Attack",
                        ID:          "sigma-auth-001",
                        Status:      "stable",
                        Description: "Detects multiple failed authentication attempts",
                        Author:      "NetMon Security",
                        Level:       "high",
                        Tags:        []string{"attack.credential_access", "attack.t1110"},
                        LogSource: SigmaLogSource{
                                Category: "authentication",
                                Product:  "netmon",
                        },
                        Detection: SigmaDetection{
                                Selection: map[string]interface{}{
                                        "event.action": "logon_failed",
                                        "source.ip|count|gte": 5,
                                },
                                Condition: "selection",
                                Timeframe: "5m",
                        },
                },
                {
                        Title:       "Data Exfiltration via HTTP POST",
                        ID:          "sigma-exfil-001",
                        Status:      "experimental",
                        Description: "Detects potential data exfiltration using HTTP POST requests",
                        Author:      "NetMon Security",
                        Level:       "high",
                        Tags:        []string{"attack.exfiltration", "attack.t1041"},
                        LogSource: SigmaLogSource{
                                Category: "webserver",
                                Product:  "netmon",
                        },
                        Detection: SigmaDetection{
                                Selection: map[string]interface{}{
                                        "http.request.method": "POST",
                                        "http.request.body.bytes|gt": 1048576, // 1MB
                                        "destination.ip|public": true,
                                },
                                Condition: "selection",
                        },
                },
                {
                        Title:       "Suspicious PowerShell Download",
                        ID:          "sigma-ps-001",
                        Status:      "stable",
                        Description: "Detects PowerShell downloading content from the internet",
                        Author:      "NetMon Security",
                        Level:       "high",
                        Tags:        []string{"attack.execution", "attack.t1059.001"},
                        LogSource: SigmaLogSource{
                                Category: "network",
                                Product:  "netmon",
                        },
                        Detection: SigmaDetection{
                                Selection: map[string]interface{}{
                                        "user_agent|contains": "PowerShell",
                                        "http.request.method": []string{"GET", "POST"},
                                },
                                Condition: "selection",
                        },
                },
                {
                        Title:       "Cryptocurrency Mining Pool Connection",
                        ID:          "sigma-crypto-001",
                        Status:      "stable",
                        Description: "Detects connections to known cryptocurrency mining pools",
                        Author:      "NetMon Security",
                        Level:       "high",
                        Tags:        []string{"attack.impact", "attack.t1496"},
                        LogSource: SigmaLogSource{
                                Category: "network",
                                Product:  "netmon",
                        },
                        Detection: SigmaDetection{
                                Selection: map[string]interface{}{
                                        "destination.port": []int{3333, 4444, 8333, 8888, 9999},
                                        "network.protocol": "tcp",
                                        "network.bytes|gt": 1000,
                                },
                                Condition: "selection",
                        },
                },
                {
                        Title:       "IRC Botnet Communication",
                        ID:          "sigma-irc-001",
                        Status:      "experimental",
                        Description: "Detects potential IRC botnet command and control communication",
                        Author:      "NetMon Security",
                        Level:       "high",
                        Tags:        []string{"attack.command_and_control", "attack.t1071"},
                        LogSource: SigmaLogSource{
                                Category: "network",
                                Product:  "netmon",
                        },
                        Detection: SigmaDetection{
                                Selection: map[string]interface{}{
                                        "destination.port": []int{6666, 6667, 6668, 6669, 7000},
                                        "network.protocol": "tcp",
                                        "payload|contains|any": []string{"PRIVMSG", "JOIN", "NICK"},
                                },
                                Condition: "selection",
                        },
                },
                {
                        Title:       "Log4j Exploitation Attempt",
                        ID:          "sigma-log4j-001",
                        Status:      "stable",
                        Description: "Detects Log4j vulnerability exploitation attempts (CVE-2021-44228)",
                        Author:      "NetMon Security",
                        Level:       "critical",
                        Tags:        []string{"attack.initial_access", "cve.2021.44228"},
                        References:  []string{"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228"},
                        LogSource: SigmaLogSource{
                                Category: "webserver",
                                Product:  "netmon",
                        },
                        Detection: SigmaDetection{
                                Selection: map[string]interface{}{
                                        "payload|contains": "${jndi:",
                                        "payload|contains|any": []string{"ldap://", "ldaps://", "rmi://", "dns://"},
                                },
                                Condition: "selection",
                        },
                },
        }
        
        // Compile rules
        for i := range defaultRules </span><span class="cov7" title="10">{
                se.compileRule(&amp;defaultRules[i])
                se.rules = append(se.rules, defaultRules[i])
        }</span>
}

func (se *SigmaEngine) compileRule(rule *SigmaRule) error <span class="cov7" title="10">{
        compiled := &amp;CompiledSigmaRule{
                Matchers: make([]FieldMatcher, 0),
        }
        
        // Parse selection criteria
        for field, value := range rule.Detection.Selection </span><span class="cov10" title="25">{
                matcher := se.parseFieldMatcher(field, value)
                if matcher != nil </span><span class="cov10" title="25">{
                        compiled.Matchers = append(compiled.Matchers, *matcher)
                }</span>
        }
        
        // Parse timeframe
        <span class="cov7" title="10">if rule.Detection.Timeframe != "" </span><span class="cov2" title="2">{
                duration, err := se.parseTimeframe(rule.Detection.Timeframe)
                if err == nil </span><span class="cov2" title="2">{
                        compiled.Timeframe = duration
                }</span>
        }
        
        // Parse condition
        <span class="cov7" title="10">compiled.Condition = se.parseCondition(rule.Detection.Condition)
        
        rule.Compiled = compiled
        return nil</span>
}

func (se *SigmaEngine) parseFieldMatcher(field string, value interface{}) *FieldMatcher <span class="cov10" title="25">{
        matcher := &amp;FieldMatcher{
                Value: value,
        }
        
        // Parse field with modifiers
        parts := strings.Split(field, "|")
        matcher.Field = se.mapField(parts[0])
        
        if len(parts) &gt; 1 </span><span class="cov8" title="14">{
                for i := 1; i &lt; len(parts); i++ </span><span class="cov9" title="20">{
                        modifier := strings.ToLower(parts[i])
                        switch modifier </span>{
                        case "contains", "startswith", "endswith", "regex", "equals":<span class="cov6" title="6">
                                matcher.Operator = modifier</span>
                        case "gt", "lt", "gte", "lte":<span class="cov5" title="5">
                                matcher.Operator = modifier</span>
                        case "count":<span class="cov4" title="3">
                                matcher.Operator = "count"</span>
                        case "all", "any", "ignorecase":<span class="cov4" title="3">
                                matcher.Modifiers = append(matcher.Modifiers, modifier)</span>
                        }
                }
        }
        
        <span class="cov10" title="25">if matcher.Operator == "" </span><span class="cov8" title="14">{
                matcher.Operator = "equals"
        }</span>
        
        <span class="cov10" title="25">return matcher</span>
}

func (se *SigmaEngine) mapField(sigmaField string) string <span class="cov10" title="25">{
        if mapped, ok := se.fieldMap[sigmaField]; ok </span><span class="cov9" title="19">{
                return mapped
        }</span>
        <span class="cov6" title="6">return sigmaField</span>
}

func (se *SigmaEngine) parseTimeframe(timeframe string) (time.Duration, error) <span class="cov2" title="2">{
        // Parse Sigma timeframe format (e.g., "5m", "1h", "60s")
        return time.ParseDuration(timeframe)
}</span>

func (se *SigmaEngine) parseCondition(condition string) *ConditionEvaluator <span class="cov7" title="10">{
        // Simple condition parser
        condition = strings.TrimSpace(condition)
        
        if condition == "selection" </span><span class="cov7" title="10">{
                return &amp;ConditionEvaluator{
                        Expression: "selection",
                        Type:       "selection",
                }
        }</span>
        
        // Handle more complex conditions (simplified)
        <span class="cov0" title="0">if strings.Contains(condition, " and ") </span><span class="cov0" title="0">{
                return &amp;ConditionEvaluator{
                        Expression: condition,
                        Type:       "and",
                }
        }</span>
        
        <span class="cov0" title="0">if strings.Contains(condition, " or ") </span><span class="cov0" title="0">{
                return &amp;ConditionEvaluator{
                        Expression: condition,
                        Type:       "or",
                }
        }</span>
        
        <span class="cov0" title="0">return &amp;ConditionEvaluator{
                Expression: condition,
                Type:       "simple",
        }</span>
}

func (se *SigmaEngine) ProcessPacket(packet gopacket.Packet) []SigmaAlert <span class="cov0" title="0">{
        se.stats.TotalPackets++
        
        // Extract packet data into fields
        packetData := se.extractPacketData(packet)
        
        var alerts []SigmaAlert
        
        // Check each rule
        for _, rule := range se.rules </span><span class="cov0" title="0">{
                if se.matchRule(rule, packetData) </span><span class="cov0" title="0">{
                        alert := se.createAlert(rule, packetData)
                        alerts = append(alerts, alert)
                        se.alerts = append(se.alerts, alert)
                        
                        se.stats.TotalAlerts++
                        se.stats.AlertsByRule[rule.ID]++
                        se.stats.AlertsByLevel[rule.Level]++
                        
                        for _, tag := range rule.Tags </span><span class="cov0" title="0">{
                                se.stats.AlertsByTag[tag]++
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return alerts</span>
}

func (se *SigmaEngine) extractPacketData(packet gopacket.Packet) map[string]interface{} <span class="cov0" title="0">{
        data := make(map[string]interface{})
        
        // Network layer
        if netLayer := packet.NetworkLayer(); netLayer != nil </span><span class="cov0" title="0">{
                data["src_ip"] = netLayer.NetworkFlow().Src().String()
                data["dst_ip"] = netLayer.NetworkFlow().Dst().String()
                
                // Check if IPs are private/public
                srcIP := netLayer.NetworkFlow().Src().String()
                dstIP := netLayer.NetworkFlow().Dst().String()
                data["src_ip_private"] = se.isPrivateIP(srcIP)
                data["dst_ip_private"] = se.isPrivateIP(dstIP)
                data["src_ip_public"] = !se.isPrivateIP(srcIP)
                data["dst_ip_public"] = !se.isPrivateIP(dstIP)
        }</span>
        
        // Transport layer
        <span class="cov0" title="0">if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                tcp := tcpLayer.(*layers.TCP)
                data["src_port"] = int(tcp.SrcPort)
                data["dst_port"] = int(tcp.DstPort)
                data["protocol"] = "tcp"
                data["transport"] = "tcp"
        }</span> else<span class="cov0" title="0"> if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil </span><span class="cov0" title="0">{
                udp := udpLayer.(*layers.UDP)
                data["src_port"] = int(udp.SrcPort)
                data["dst_port"] = int(udp.DstPort)
                data["protocol"] = "udp"
                data["transport"] = "udp"
        }</span>
        
        // Application layer
        <span class="cov0" title="0">if app := packet.ApplicationLayer(); app != nil </span><span class="cov0" title="0">{
                payload := app.Payload()
                data["payload"] = string(payload)
                data["payload_bytes"] = len(payload)
                
                // Try to parse HTTP
                if httpData := se.parseHTTP(payload); httpData != nil </span><span class="cov0" title="0">{
                        for k, v := range httpData </span><span class="cov0" title="0">{
                                data[k] = v
                        }</span>
                }
                
                // DNS layer
                <span class="cov0" title="0">if dnsLayer := packet.Layer(layers.LayerTypeDNS); dnsLayer != nil </span><span class="cov0" title="0">{
                        dns := dnsLayer.(*layers.DNS)
                        if len(dns.Questions) &gt; 0 </span><span class="cov0" title="0">{
                                data["dns_query"] = string(dns.Questions[0].Name)
                                data["dns_query_type"] = dns.Questions[0].Type.String()
                        }</span>
                }
        }
        
        <span class="cov0" title="0">data["timestamp"] = time.Now()
        data["packet_size"] = len(packet.Data())
        
        return data</span>
}

func (se *SigmaEngine) parseHTTP(payload []byte) map[string]interface{} <span class="cov0" title="0">{
        payloadStr := string(payload)
        if !strings.Contains(payloadStr, "HTTP/") </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">httpData := make(map[string]interface{})
        lines := strings.Split(payloadStr, "\r\n")
        
        if len(lines) &gt; 0 </span><span class="cov0" title="0">{
                // Parse request line
                parts := strings.Fields(lines[0])
                if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                        if strings.HasPrefix(parts[2], "HTTP/") </span><span class="cov0" title="0">{
                                // Request
                                httpData["http_method"] = parts[0]
                                httpData["http_url"] = parts[1]
                                httpData["http_version"] = parts[2]
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(parts[0], "HTTP/") </span><span class="cov0" title="0">{
                                // Response
                                httpData["http_version"] = parts[0]
                                httpData["http_status"] = parts[1]
                        }</span>
                }
                
                // Parse headers
                <span class="cov0" title="0">for i := 1; i &lt; len(lines); i++ </span><span class="cov0" title="0">{
                        if lines[i] == "" </span><span class="cov0" title="0">{
                                // Body starts after empty line
                                if i+1 &lt; len(lines) </span><span class="cov0" title="0">{
                                        body := strings.Join(lines[i+1:], "\r\n")
                                        httpData["http_body"] = body
                                        httpData["http_body_bytes"] = len(body)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                        
                        <span class="cov0" title="0">headerParts := strings.SplitN(lines[i], ":", 2)
                        if len(headerParts) == 2 </span><span class="cov0" title="0">{
                                headerName := strings.TrimSpace(headerParts[0])
                                headerValue := strings.TrimSpace(headerParts[1])
                                
                                if strings.ToLower(headerName) == "user-agent" </span><span class="cov0" title="0">{
                                        httpData["http_user_agent"] = headerValue
                                }</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return httpData</span>
}

func (se *SigmaEngine) isPrivateIP(ip string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(ip, "192.168.") ||
                strings.HasPrefix(ip, "10.") ||
                strings.HasPrefix(ip, "172.16.") ||
                strings.HasPrefix(ip, "172.17.") ||
                strings.HasPrefix(ip, "172.18.") ||
                strings.HasPrefix(ip, "172.19.") ||
                strings.HasPrefix(ip, "172.20.") ||
                strings.HasPrefix(ip, "172.21.") ||
                strings.HasPrefix(ip, "172.22.") ||
                strings.HasPrefix(ip, "172.23.") ||
                strings.HasPrefix(ip, "172.24.") ||
                strings.HasPrefix(ip, "172.25.") ||
                strings.HasPrefix(ip, "172.26.") ||
                strings.HasPrefix(ip, "172.27.") ||
                strings.HasPrefix(ip, "172.28.") ||
                strings.HasPrefix(ip, "172.29.") ||
                strings.HasPrefix(ip, "172.30.") ||
                strings.HasPrefix(ip, "172.31.")
}</span>

func (se *SigmaEngine) matchRule(rule SigmaRule, data map[string]interface{}) bool <span class="cov0" title="0">{
        if rule.Compiled == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check log source first
        <span class="cov0" title="0">if !se.matchLogSource(rule.LogSource, data) </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Evaluate matchers
        <span class="cov0" title="0">matchResults := make(map[string]bool)
        
        for _, matcher := range rule.Compiled.Matchers </span><span class="cov0" title="0">{
                result := se.evaluateMatcher(matcher, data)
                matchResults[matcher.Field] = result
        }</span>
        
        // Evaluate condition
        <span class="cov0" title="0">return se.evaluateCondition(rule.Compiled.Condition, matchResults)</span>
}

func (se *SigmaEngine) matchLogSource(logSource SigmaLogSource, data map[string]interface{}) bool <span class="cov0" title="0">{
        // Simple log source matching
        switch logSource.Category </span>{
        case "network":<span class="cov0" title="0">
                return true</span> // All packets are network
        case "webserver":<span class="cov0" title="0">
                // Check if it's HTTP traffic
                _, hasMethod := data["http_method"]
                _, hasURL := data["http_url"]
                return hasMethod || hasURL</span>
        case "dns":<span class="cov0" title="0">
                _, hasDNS := data["dns_query"]
                return hasDNS</span>
        case "authentication":<span class="cov0" title="0">
                // Would need auth event data
                _, hasAuth := data["event_action"]
                return hasAuth</span>
        }
        
        <span class="cov0" title="0">return true</span>
}

func (se *SigmaEngine) evaluateMatcher(matcher FieldMatcher, data map[string]interface{}) bool <span class="cov0" title="0">{
        fieldValue, exists := data[matcher.Field]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">switch matcher.Operator </span>{
        case "equals":<span class="cov0" title="0">
                return se.matchEquals(fieldValue, matcher.Value, matcher.Modifiers)</span>
        case "contains":<span class="cov0" title="0">
                return se.matchContains(fieldValue, matcher.Value, matcher.Modifiers)</span>
        case "startswith":<span class="cov0" title="0">
                return se.matchStartsWith(fieldValue, matcher.Value, matcher.Modifiers)</span>
        case "endswith":<span class="cov0" title="0">
                return se.matchEndsWith(fieldValue, matcher.Value, matcher.Modifiers)</span>
        case "regex":<span class="cov0" title="0">
                return se.matchRegex(fieldValue, matcher.Value)</span>
        case "gt":<span class="cov0" title="0">
                return se.matchGreaterThan(fieldValue, matcher.Value)</span>
        case "lt":<span class="cov0" title="0">
                return se.matchLessThan(fieldValue, matcher.Value)</span>
        case "gte":<span class="cov0" title="0">
                return se.matchGreaterThanOrEqual(fieldValue, matcher.Value)</span>
        case "lte":<span class="cov0" title="0">
                return se.matchLessThanOrEqual(fieldValue, matcher.Value)</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

func (se *SigmaEngine) matchEquals(fieldValue, matchValue interface{}, modifiers []string) bool <span class="cov0" title="0">{
        ignoreCase := se.hasModifier(modifiers, "ignorecase")
        
        // Handle different types
        switch fv := fieldValue.(type) </span>{
        case string:<span class="cov0" title="0">
                mv, ok := matchValue.(string)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">if ignoreCase </span><span class="cov0" title="0">{
                        return strings.EqualFold(fv, mv)
                }</span>
                <span class="cov0" title="0">return fv == mv</span>
                
        case int:<span class="cov0" title="0">
                switch mv := matchValue.(type) </span>{
                case int:<span class="cov0" title="0">
                        return fv == mv</span>
                case []int:<span class="cov0" title="0">
                        for _, v := range mv </span><span class="cov0" title="0">{
                                if fv == v </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
                
        case []string:<span class="cov0" title="0">
                mv, ok := matchValue.(string)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">for _, v := range fv </span><span class="cov0" title="0">{
                        if ignoreCase &amp;&amp; strings.EqualFold(v, mv) </span><span class="cov0" title="0">{
                                return true
                        }</span> else<span class="cov0" title="0"> if v == mv </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return false</span>
}

func (se *SigmaEngine) matchContains(fieldValue, matchValue interface{}, modifiers []string) bool <span class="cov0" title="0">{
        fvStr, ok1 := fieldValue.(string)
        mvStr, ok2 := matchValue.(string)
        
        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">ignoreCase := se.hasModifier(modifiers, "ignorecase")
        all := se.hasModifier(modifiers, "all")
        any := se.hasModifier(modifiers, "any")
        
        if ignoreCase </span><span class="cov0" title="0">{
                fvStr = strings.ToLower(fvStr)
                mvStr = strings.ToLower(mvStr)
        }</span>
        
        // Handle array of values
        <span class="cov0" title="0">if mvSlice, ok := matchValue.([]string); ok </span><span class="cov0" title="0">{
                if all </span><span class="cov0" title="0">{
                        for _, v := range mvSlice </span><span class="cov0" title="0">{
                                if ignoreCase </span><span class="cov0" title="0">{
                                        v = strings.ToLower(v)
                                }</span>
                                <span class="cov0" title="0">if !strings.Contains(fvStr, v) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                        <span class="cov0" title="0">return true</span>
                } else<span class="cov0" title="0"> if any </span><span class="cov0" title="0">{
                        for _, v := range mvSlice </span><span class="cov0" title="0">{
                                if ignoreCase </span><span class="cov0" title="0">{
                                        v = strings.ToLower(v)
                                }</span>
                                <span class="cov0" title="0">if strings.Contains(fvStr, v) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                        <span class="cov0" title="0">return false</span>
                }
        }
        
        <span class="cov0" title="0">return strings.Contains(fvStr, mvStr)</span>
}

func (se *SigmaEngine) matchStartsWith(fieldValue, matchValue interface{}, modifiers []string) bool <span class="cov0" title="0">{
        fvStr, ok1 := fieldValue.(string)
        mvStr, ok2 := matchValue.(string)
        
        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">if se.hasModifier(modifiers, "ignorecase") </span><span class="cov0" title="0">{
                return strings.HasPrefix(strings.ToLower(fvStr), strings.ToLower(mvStr))
        }</span>
        
        <span class="cov0" title="0">return strings.HasPrefix(fvStr, mvStr)</span>
}

func (se *SigmaEngine) matchEndsWith(fieldValue, matchValue interface{}, modifiers []string) bool <span class="cov0" title="0">{
        fvStr, ok1 := fieldValue.(string)
        mvStr, ok2 := matchValue.(string)
        
        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">if se.hasModifier(modifiers, "ignorecase") </span><span class="cov0" title="0">{
                return strings.HasSuffix(strings.ToLower(fvStr), strings.ToLower(mvStr))
        }</span>
        
        <span class="cov0" title="0">return strings.HasSuffix(fvStr, mvStr)</span>
}

func (se *SigmaEngine) matchRegex(fieldValue, matchValue interface{}) bool <span class="cov0" title="0">{
        fvStr, ok1 := fieldValue.(string)
        mvStr, ok2 := matchValue.(string)
        
        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">re, err := regexp.Compile(mvStr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">return re.MatchString(fvStr)</span>
}

func (se *SigmaEngine) matchGreaterThan(fieldValue, matchValue interface{}) bool <span class="cov0" title="0">{
        fvInt, ok1 := se.toInt(fieldValue)
        mvInt, ok2 := se.toInt(matchValue)
        
        if ok1 &amp;&amp; ok2 </span><span class="cov0" title="0">{
                return fvInt &gt; mvInt
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

func (se *SigmaEngine) matchLessThan(fieldValue, matchValue interface{}) bool <span class="cov0" title="0">{
        fvInt, ok1 := se.toInt(fieldValue)
        mvInt, ok2 := se.toInt(matchValue)
        
        if ok1 &amp;&amp; ok2 </span><span class="cov0" title="0">{
                return fvInt &lt; mvInt
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

func (se *SigmaEngine) matchGreaterThanOrEqual(fieldValue, matchValue interface{}) bool <span class="cov0" title="0">{
        fvInt, ok1 := se.toInt(fieldValue)
        mvInt, ok2 := se.toInt(matchValue)
        
        if ok1 &amp;&amp; ok2 </span><span class="cov0" title="0">{
                return fvInt &gt;= mvInt
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

func (se *SigmaEngine) matchLessThanOrEqual(fieldValue, matchValue interface{}) bool <span class="cov0" title="0">{
        fvInt, ok1 := se.toInt(fieldValue)
        mvInt, ok2 := se.toInt(matchValue)
        
        if ok1 &amp;&amp; ok2 </span><span class="cov0" title="0">{
                return fvInt &lt;= mvInt
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

func (se *SigmaEngine) toInt(value interface{}) (int, bool) <span class="cov0" title="0">{
        switch v := value.(type) </span>{
        case int:<span class="cov0" title="0">
                return v, true</span>
        case int64:<span class="cov0" title="0">
                return int(v), true</span>
        case float64:<span class="cov0" title="0">
                return int(v), true</span>
        }
        <span class="cov0" title="0">return 0, false</span>
}

func (se *SigmaEngine) hasModifier(modifiers []string, modifier string) bool <span class="cov0" title="0">{
        for _, m := range modifiers </span><span class="cov0" title="0">{
                if m == modifier </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (se *SigmaEngine) evaluateCondition(condition *ConditionEvaluator, results map[string]bool) bool <span class="cov0" title="0">{
        if condition == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        
        <span class="cov0" title="0">switch condition.Type </span>{
        case "selection":<span class="cov0" title="0">
                // All matchers must be true
                for _, result := range results </span><span class="cov0" title="0">{
                        if !result </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
                
        case "and":<span class="cov0" title="0">
                // All operands must be true
                for _, result := range results </span><span class="cov0" title="0">{
                        if !result </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
                
        case "or":<span class="cov0" title="0">
                // Any operand must be true
                for _, result := range results </span><span class="cov0" title="0">{
                        if result </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
                
        case "not":<span class="cov0" title="0">
                // Invert the result
                for _, result := range results </span><span class="cov0" title="0">{
                        if result </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
        
        <span class="cov0" title="0">return true</span>
}

func (se *SigmaEngine) createAlert(rule SigmaRule, data map[string]interface{}) SigmaAlert <span class="cov0" title="0">{
        alert := SigmaAlert{
                Timestamp:     time.Now(),
                RuleID:        rule.ID,
                RuleTitle:     rule.Title,
                Level:         rule.Level,
                Tags:          rule.Tags,
                Message:       fmt.Sprintf("%s - %s", rule.Title, rule.Description),
                MatchedFields: make(map[string]interface{}),
                PacketInfo:    data,
                References:    rule.References,
        }
        
        // Extract matched fields
        for _, matcher := range rule.Compiled.Matchers </span><span class="cov0" title="0">{
                if value, exists := data[matcher.Field]; exists </span><span class="cov0" title="0">{
                        alert.MatchedFields[matcher.Field] = value
                }</span>
        }
        
        <span class="cov0" title="0">return alert</span>
}

// Rule management

func (se *SigmaEngine) AddRule(rule SigmaRule) error <span class="cov0" title="0">{
        if err := se.compileRule(&amp;rule); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">se.rules = append(se.rules, rule)
        return nil</span>
}

func (se *SigmaEngine) LoadRuleFromYAML(yamlContent string) error <span class="cov0" title="0">{
        var rule SigmaRule
        if err := yaml.Unmarshal([]byte(yamlContent), &amp;rule); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return se.AddRule(rule)</span>
}

// Getters

func (se *SigmaEngine) GetAlerts() []SigmaAlert <span class="cov0" title="0">{
        return se.alerts
}</span>

func (se *SigmaEngine) GetAlertsByRule(ruleID string) []SigmaAlert <span class="cov0" title="0">{
        var ruleAlerts []SigmaAlert
        for _, alert := range se.alerts </span><span class="cov0" title="0">{
                if alert.RuleID == ruleID </span><span class="cov0" title="0">{
                        ruleAlerts = append(ruleAlerts, alert)
                }</span>
        }
        <span class="cov0" title="0">return ruleAlerts</span>
}

func (se *SigmaEngine) GetAlertsByLevel(level string) []SigmaAlert <span class="cov0" title="0">{
        var levelAlerts []SigmaAlert
        for _, alert := range se.alerts </span><span class="cov0" title="0">{
                if alert.Level == level </span><span class="cov0" title="0">{
                        levelAlerts = append(levelAlerts, alert)
                }</span>
        }
        <span class="cov0" title="0">return levelAlerts</span>
}

func (se *SigmaEngine) GetStats() interface{} <span class="cov0" title="0">{
        return se.stats
}</span>

func (se *SigmaEngine) GetRules() []SigmaRule <span class="cov0" title="0">{
        return se.rules
}</span>

// Cleanup

func (se *SigmaEngine) ClearAlerts() <span class="cov0" title="0">{
        se.alerts = make([]SigmaAlert, 0)
}</span>

func (se *SigmaEngine) GetRecentAlerts(duration time.Duration) []SigmaAlert <span class="cov0" title="0">{
        cutoff := time.Now().Add(-duration)
        var recent []SigmaAlert
        
        for _, alert := range se.alerts </span><span class="cov0" title="0">{
                if alert.Timestamp.After(cutoff) </span><span class="cov0" title="0">{
                        recent = append(recent, alert)
                }</span>
        }
        
        <span class="cov0" title="0">return recent</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package security

import (
        "fmt"
        "net"
        "strconv"
        "strings"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
)

type SnortEngine struct {
        rules         []SnortRule
        rulesByAction map[string][]SnortRule
        alerts        []SnortAlert
        stats         SnortStats
}

type SnortRule struct {
        ID          int
        Action      string // alert, log, pass, drop, reject
        Protocol    string // tcp, udp, icmp, ip
        SrcIP       string
        SrcPort     string
        Direction   string // -&gt; or &lt;&gt;
        DstIP       string
        DstPort     string
        Options     map[string]string
        Message     string
        Classtype   string
        Priority    int
        SID         int
        Rev         int
        Raw         string
}

type SnortAlert struct {
        Timestamp   time.Time
        RuleID      int
        SID         int
        Message     string
        Protocol    string
        SrcIP       string
        SrcPort     int
        DstIP       string
        DstPort     int
        Priority    int
        Classtype   string
        PacketData  []byte
        Details     map[string]interface{}
}

type SnortStats struct {
        TotalPackets   uint64
        TotalAlerts    uint64
        AlertsByRule   map[int]uint64
        AlertsByType   map[string]uint64
        LastAlert      time.Time
}

func NewSnortEngine() *SnortEngine <span class="cov1" title="1">{
        engine := &amp;SnortEngine{
                rules:         make([]SnortRule, 0),
                rulesByAction: make(map[string][]SnortRule),
                alerts:        make([]SnortAlert, 0),
                stats: SnortStats{
                        AlertsByRule: make(map[int]uint64),
                        AlertsByType: make(map[string]uint64),
                },
        }
        
        // Load default rules
        engine.loadDefaultRules()
        
        return engine
}</span>

func (se *SnortEngine) loadDefaultRules() <span class="cov1" title="1">{
        defaultRules := []string{
                // Malware and exploits
                `alert tcp any any -&gt; any any (msg:"MALWARE Generic backdoor command"; content:"sh"; content:"rm -rf"; sid:1000001; classtype:trojan-activity; priority:1;)`,
                `alert tcp any any -&gt; any any (msg:"EXPLOIT SQL injection attempt"; content:"union select"; nocase; sid:1000002; classtype:web-application-attack; priority:2;)`,
                `alert tcp any any -&gt; any any (msg:"EXPLOIT XSS attempt"; content:"&lt;script&gt;"; nocase; sid:1000003; classtype:web-application-attack; priority:2;)`,
                
                // Port scanning and reconnaissance
                `alert tcp any any -&gt; any any (msg:"SCAN Port scan detected"; flags:S; threshold:type both, track by_src, count 20, seconds 60; sid:1000004; classtype:attempted-recon; priority:3;)`,
                `alert icmp any any -&gt; any any (msg:"SCAN ICMP ping sweep"; itype:8; threshold:type both, track by_src, count 10, seconds 60; sid:1000005; classtype:attempted-recon; priority:3;)`,
                
                // Brute force attacks
                `alert tcp any any -&gt; any 22 (msg:"ATTACK SSH brute force attempt"; content:"SSH"; threshold:type both, track by_src, count 5, seconds 60; sid:1000006; classtype:attempted-user; priority:2;)`,
                `alert tcp any any -&gt; any 21 (msg:"ATTACK FTP brute force attempt"; content:"530"; threshold:type both, track by_src, count 5, seconds 60; sid:1000007; classtype:attempted-user; priority:2;)`,
                `alert tcp any any -&gt; any 3389 (msg:"ATTACK RDP brute force attempt"; threshold:type both, track by_src, count 5, seconds 300; sid:1000008; classtype:attempted-user; priority:2;)`,
                
                // Suspicious network activity
                `alert tcp any any -&gt; any any (msg:"SUSPICIOUS Large file transfer"; dsize:&gt;1000000; sid:1000009; classtype:policy-violation; priority:3;)`,
                `alert udp any any -&gt; any 53 (msg:"SUSPICIOUS DNS tunneling"; dsize:&gt;512; sid:1000010; classtype:policy-violation; priority:3;)`,
                `alert tcp any any -&gt; any any (msg:"SUSPICIOUS Base64 encoded data"; content:"base64"; nocase; sid:1000011; classtype:policy-violation; priority:3;)`,
                
                // Protocol-specific attacks
                `alert tcp any any -&gt; any 80 (msg:"WEB-ATTACKS Directory traversal"; content:"../"; sid:1000012; classtype:web-application-attack; priority:2;)`,
                `alert tcp any any -&gt; any 443 (msg:"SSL Certificate anomaly"; content:"certificate"; sid:1000013; classtype:protocol-command-decode; priority:3;)`,
                `alert tcp any any -&gt; any 25 (msg:"SMTP Command injection"; content:"RCPT TO:"; content:"|"; sid:1000014; classtype:attempted-user; priority:2;)`,
                
                // Data exfiltration
                `alert tcp any any -&gt; any any (msg:"POLICY Data exfiltration via HTTP POST"; content:"POST"; content:"password"; sid:1000015; classtype:policy-violation; priority:2;)`,
                `alert tcp any any -&gt; any any (msg:"POLICY Sensitive file access"; content:".key"; content:".pem"; sid:1000016; classtype:policy-violation; priority:2;)`,
                
                // Botnet and C2 communication
                `alert tcp any any -&gt; any any (msg:"MALWARE Botnet beacon"; content:"bot"; content:"cmd"; sid:1000017; classtype:trojan-activity; priority:1;)`,
                `alert tcp any any -&gt; any any (msg:"MALWARE IRC bot communication"; content:"PRIVMSG"; content:"!"; sid:1000018; classtype:trojan-activity; priority:1;)`,
        }
        
        for _, ruleStr := range defaultRules </span><span class="cov4" title="18">{
                if rule := se.parseRule(ruleStr); rule != nil </span><span class="cov4" title="18">{
                        se.AddRule(*rule)
                }</span>
        }
}

func (se *SnortEngine) parseRule(ruleStr string) *SnortRule <span class="cov4" title="18">{
        // Parse Snort rule format: action protocol src_ip src_port direction dst_ip dst_port (options)
        ruleStr = strings.TrimSpace(ruleStr)
        if ruleStr == "" || strings.HasPrefix(ruleStr, "#") </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Split into header and options
        <span class="cov4" title="18">parts := strings.SplitN(ruleStr, "(", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov4" title="18">header := strings.TrimSpace(parts[0])
        optionsStr := strings.TrimSuffix(strings.TrimSpace(parts[1]), ")")
        
        // Parse header
        headerParts := strings.Fields(header)
        if len(headerParts) &lt; 7 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov4" title="18">rule := &amp;SnortRule{
                Action:    headerParts[0],
                Protocol:  headerParts[1],
                SrcIP:     headerParts[2],
                SrcPort:   headerParts[3],
                Direction: headerParts[4],
                DstIP:     headerParts[5],
                DstPort:   headerParts[6],
                Options:   make(map[string]string),
                Raw:       ruleStr,
        }
        
        // Parse options
        se.parseOptions(rule, optionsStr)
        
        return rule</span>
}

func (se *SnortEngine) parseOptions(rule *SnortRule, optionsStr string) <span class="cov4" title="18">{
        // Split options by semicolon, but handle quoted strings
        options := se.splitOptions(optionsStr)
        
        for _, option := range options </span><span class="cov6" title="103">{
                option = strings.TrimSpace(option)
                if option == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov6" title="103">if strings.Contains(option, ":") </span><span class="cov6" title="100">{
                        parts := strings.SplitN(option, ":", 2)
                        key := strings.TrimSpace(parts[0])
                        value := strings.Trim(strings.TrimSpace(parts[1]), `"`)
                        rule.Options[key] = value
                        
                        // Handle special options
                        switch key </span>{
                        case "msg":<span class="cov4" title="18">
                                rule.Message = value</span>
                        case "classtype":<span class="cov4" title="18">
                                rule.Classtype = value</span>
                        case "sid":<span class="cov4" title="18">
                                if sid, err := strconv.Atoi(value); err == nil </span><span class="cov4" title="18">{
                                        rule.SID = sid
                                }</span>
                        case "priority":<span class="cov4" title="18">
                                if priority, err := strconv.Atoi(value); err == nil </span><span class="cov4" title="18">{
                                        rule.Priority = priority
                                }</span>
                        case "rev":<span class="cov0" title="0">
                                if rev, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                        rule.Rev = rev
                                }</span>
                        }
                } else<span class="cov2" title="3"> {
                        // Standalone options (like nocase, flags)
                        rule.Options[option] = ""
                }</span>
        }
}

func (se *SnortEngine) splitOptions(optionsStr string) []string <span class="cov4" title="18">{
        var options []string
        var current strings.Builder
        inQuotes := false
        
        for _, char := range optionsStr </span><span class="cov10" title="2259">{
                switch char </span>{
                case '"':<span class="cov6" title="74">
                        inQuotes = !inQuotes
                        current.WriteRune(char)</span>
                case ';':<span class="cov6" title="103">
                        if !inQuotes </span><span class="cov6" title="103">{
                                options = append(options, current.String())
                                current.Reset()
                        }</span> else<span class="cov0" title="0"> {
                                current.WriteRune(char)
                        }</span>
                default:<span class="cov9" title="2082">
                        current.WriteRune(char)</span>
                }
        }
        
        <span class="cov4" title="18">if current.Len() &gt; 0 </span><span class="cov0" title="0">{
                options = append(options, current.String())
        }</span>
        
        <span class="cov4" title="18">return options</span>
}

func (se *SnortEngine) AddRule(rule SnortRule) <span class="cov4" title="18">{
        rule.ID = len(se.rules)
        se.rules = append(se.rules, rule)
        se.rulesByAction[rule.Action] = append(se.rulesByAction[rule.Action], rule)
}</span>

func (se *SnortEngine) LoadRulesFromFile(filename string) error <span class="cov0" title="0">{
        // Implementation would read rules from file
        return fmt.Errorf("file loading not implemented")
}</span>

func (se *SnortEngine) ProcessPacket(packet gopacket.Packet) []SnortAlert <span class="cov0" title="0">{
        se.stats.TotalPackets++
        
        var alerts []SnortAlert
        
        for _, rule := range se.rules </span><span class="cov0" title="0">{
                if se.matchRule(rule, packet) </span><span class="cov0" title="0">{
                        alert := se.createAlert(rule, packet)
                        alerts = append(alerts, alert)
                        se.alerts = append(se.alerts, alert)
                        
                        se.stats.TotalAlerts++
                        se.stats.AlertsByRule[rule.ID]++
                        se.stats.AlertsByType[rule.Classtype]++
                        se.stats.LastAlert = time.Now()
                }</span>
        }
        
        <span class="cov0" title="0">return alerts</span>
}

func (se *SnortEngine) matchRule(rule SnortRule, packet gopacket.Packet) bool <span class="cov0" title="0">{
        // Check protocol
        if !se.matchProtocol(rule.Protocol, packet) </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check IP addresses and ports
        <span class="cov0" title="0">if !se.matchNetwork(rule, packet) </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check content and other options
        <span class="cov0" title="0">return se.matchOptions(rule, packet)</span>
}

func (se *SnortEngine) matchProtocol(protocol string, packet gopacket.Packet) bool <span class="cov0" title="0">{
        switch strings.ToLower(protocol) </span>{
        case "tcp":<span class="cov0" title="0">
                return packet.Layer(layers.LayerTypeTCP) != nil</span>
        case "udp":<span class="cov0" title="0">
                return packet.Layer(layers.LayerTypeUDP) != nil</span>
        case "icmp":<span class="cov0" title="0">
                return packet.Layer(layers.LayerTypeICMPv4) != nil</span>
        case "ip":<span class="cov0" title="0">
                return packet.NetworkLayer() != nil</span>
        default:<span class="cov0" title="0">
                return true</span> // "any"
        }
}

func (se *SnortEngine) matchNetwork(rule SnortRule, packet gopacket.Packet) bool <span class="cov0" title="0">{
        netLayer := packet.NetworkLayer()
        if netLayer == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">srcIP := netLayer.NetworkFlow().Src().String()
        dstIP := netLayer.NetworkFlow().Dst().String()
        
        var srcPort, dstPort int
        
        if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                tcp := tcpLayer.(*layers.TCP)
                srcPort = int(tcp.SrcPort)
                dstPort = int(tcp.DstPort)
        }</span> else<span class="cov0" title="0"> if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil </span><span class="cov0" title="0">{
                udp := udpLayer.(*layers.UDP)
                srcPort = int(udp.SrcPort)
                dstPort = int(udp.DstPort)
        }</span>
        
        // Match source
        <span class="cov0" title="0">if !se.matchIPAddress(rule.SrcIP, srcIP) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !se.matchPort(rule.SrcPort, srcPort) </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Match destination
        <span class="cov0" title="0">if !se.matchIPAddress(rule.DstIP, dstIP) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if !se.matchPort(rule.DstPort, dstPort) </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">return true</span>
}

func (se *SnortEngine) matchIPAddress(ruleIP, packetIP string) bool <span class="cov0" title="0">{
        if ruleIP == "any" </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Handle CIDR notation
        <span class="cov0" title="0">if strings.Contains(ruleIP, "/") </span><span class="cov0" title="0">{
                _, network, err := net.ParseCIDR(ruleIP)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">ip := net.ParseIP(packetIP)
                return network.Contains(ip)</span>
        }
        
        <span class="cov0" title="0">return ruleIP == packetIP</span>
}

func (se *SnortEngine) matchPort(rulePort string, packetPort int) bool <span class="cov0" title="0">{
        if rulePort == "any" </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Handle port ranges
        <span class="cov0" title="0">if strings.Contains(rulePort, ":") </span><span class="cov0" title="0">{
                parts := strings.Split(rulePort, ":")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        start, _ := strconv.Atoi(parts[0])
                        end, _ := strconv.Atoi(parts[1])
                        return packetPort &gt;= start &amp;&amp; packetPort &lt;= end
                }</span>
        }
        
        <span class="cov0" title="0">port, err := strconv.Atoi(rulePort)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">return port == packetPort</span>
}

func (se *SnortEngine) matchOptions(rule SnortRule, packet gopacket.Packet) bool <span class="cov0" title="0">{
        payload := se.getPacketPayload(packet)
        
        for option, value := range rule.Options </span><span class="cov0" title="0">{
                switch option </span>{
                case "content":<span class="cov0" title="0">
                        if !se.matchContent(value, payload, rule.Options) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case "dsize":<span class="cov0" title="0">
                        if !se.matchDataSize(value, len(payload)) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case "flags":<span class="cov0" title="0">
                        if !se.matchTCPFlags(value, packet) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case "itype":<span class="cov0" title="0">
                        if !se.matchICMPType(value, packet) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return true</span>
}

func (se *SnortEngine) matchContent(content string, payload []byte, options map[string]string) bool <span class="cov0" title="0">{
        payloadStr := string(payload)
        
        // Check for nocase option
        if _, nocase := options["nocase"]; nocase </span><span class="cov0" title="0">{
                return strings.Contains(strings.ToLower(payloadStr), strings.ToLower(content))
        }</span>
        
        <span class="cov0" title="0">return strings.Contains(payloadStr, content)</span>
}

func (se *SnortEngine) matchDataSize(sizeRule string, actualSize int) bool <span class="cov0" title="0">{
        if strings.HasPrefix(sizeRule, "&gt;") </span><span class="cov0" title="0">{
                threshold, _ := strconv.Atoi(sizeRule[1:])
                return actualSize &gt; threshold
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(sizeRule, "&lt;") </span><span class="cov0" title="0">{
                threshold, _ := strconv.Atoi(sizeRule[1:])
                return actualSize &lt; threshold
        }</span>
        
        <span class="cov0" title="0">exactSize, _ := strconv.Atoi(sizeRule)
        return actualSize == exactSize</span>
}

func (se *SnortEngine) matchTCPFlags(flagsRule string, packet gopacket.Packet) bool <span class="cov0" title="0">{
        tcpLayer := packet.Layer(layers.LayerTypeTCP)
        if tcpLayer == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">tcp := tcpLayer.(*layers.TCP)
        
        // Simple flag matching (S for SYN, A for ACK, etc.)
        switch flagsRule </span>{
        case "S":<span class="cov0" title="0">
                return tcp.SYN</span>
        case "A":<span class="cov0" title="0">
                return tcp.ACK</span>
        case "F":<span class="cov0" title="0">
                return tcp.FIN</span>
        case "R":<span class="cov0" title="0">
                return tcp.RST</span>
        case "P":<span class="cov0" title="0">
                return tcp.PSH</span>
        case "U":<span class="cov0" title="0">
                return tcp.URG</span>
        }
        
        <span class="cov0" title="0">return false</span>
}

func (se *SnortEngine) matchICMPType(typeRule string, packet gopacket.Packet) bool <span class="cov0" title="0">{
        icmpLayer := packet.Layer(layers.LayerTypeICMPv4)
        if icmpLayer == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">icmp := icmpLayer.(*layers.ICMPv4)
        expectedType, _ := strconv.Atoi(typeRule)
        
        return int(icmp.TypeCode.Type()) == expectedType</span>
}

func (se *SnortEngine) getPacketPayload(packet gopacket.Packet) []byte <span class="cov0" title="0">{
        if app := packet.ApplicationLayer(); app != nil </span><span class="cov0" title="0">{
                return app.Payload()
        }</span>
        <span class="cov0" title="0">if transport := packet.TransportLayer(); transport != nil </span><span class="cov0" title="0">{
                return transport.LayerPayload()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (se *SnortEngine) createAlert(rule SnortRule, packet gopacket.Packet) SnortAlert <span class="cov0" title="0">{
        netLayer := packet.NetworkLayer()
        srcIP := netLayer.NetworkFlow().Src().String()
        dstIP := netLayer.NetworkFlow().Dst().String()
        
        var srcPort, dstPort int
        var protocol string
        
        if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                tcp := tcpLayer.(*layers.TCP)
                srcPort = int(tcp.SrcPort)
                dstPort = int(tcp.DstPort)
                protocol = "TCP"
        }</span> else<span class="cov0" title="0"> if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil </span><span class="cov0" title="0">{
                udp := udpLayer.(*layers.UDP)
                srcPort = int(udp.SrcPort)
                dstPort = int(udp.DstPort)
                protocol = "UDP"
        }</span> else<span class="cov0" title="0"> if packet.Layer(layers.LayerTypeICMPv4) != nil </span><span class="cov0" title="0">{
                protocol = "ICMP"
        }</span>
        
        <span class="cov0" title="0">return SnortAlert{
                Timestamp:  time.Now(),
                RuleID:     rule.ID,
                SID:        rule.SID,
                Message:    rule.Message,
                Protocol:   protocol,
                SrcIP:      srcIP,
                SrcPort:    srcPort,
                DstIP:      dstIP,
                DstPort:    dstPort,
                Priority:   rule.Priority,
                Classtype:  rule.Classtype,
                PacketData: se.getPacketPayload(packet),
                Details: map[string]interface{}{
                        "rule_action": rule.Action,
                        "packet_size": len(se.getPacketPayload(packet)),
                },
        }</span>
}

func (se *SnortEngine) GetAlerts() []SnortAlert <span class="cov0" title="0">{
        return se.alerts
}</span>

func (se *SnortEngine) GetStats() interface{} <span class="cov0" title="0">{
        return se.stats
}</span>

func (se *SnortEngine) GetRules() []SnortRule <span class="cov0" title="0">{
        return se.rules
}</span>

func (se *SnortEngine) ClearAlerts() <span class="cov0" title="0">{
        se.alerts = make([]SnortAlert, 0)
}</span>

func (se *SnortEngine) GetRecentAlerts(duration time.Duration) []SnortAlert <span class="cov0" title="0">{
        cutoff := time.Now().Add(-duration)
        var recent []SnortAlert
        
        for _, alert := range se.alerts </span><span class="cov0" title="0">{
                if alert.Timestamp.After(cutoff) </span><span class="cov0" title="0">{
                        recent = append(recent, alert)
                }</span>
        }
        
        <span class="cov0" title="0">return recent</span>
}</pre>
		
		<pre class="file" id="file13" style="display: none">package security

import (
        "encoding/json"
        "fmt"
        "net"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
)

// SuricataEngine implements Suricata IDS rule processing
type SuricataEngine struct {
        rules      []SuricataRule
        alerts     []SuricataAlert
        stats      SuricataStats
        flowTable  map[string]*FlowState
        eveFormat  bool // Output in EVE JSON format
}

type SuricataRule struct {
        ID           int
        Action       string // alert, pass, drop, reject, rejectsrc, rejectdst, rejectboth
        Protocol     string
        SrcIP        string
        SrcPort      string
        Direction    string // -&gt;, &lt;&gt;, &lt;-
        DstIP        string
        DstPort      string
        Options      map[string][]string // Suricata supports multiple values per option
        Message      string
        Classtype    string
        Priority     int
        SID          int
        Rev          int
        GID          int
        Metadata     []string
        Reference    []string
        FlowBits     []string
        Threshold    *ThresholdConfig
        Detection    *DetectionConfig
        Raw          string
}

type ThresholdConfig struct {
        Type     string // threshold, limit, both
        Track    string // by_src, by_dst
        Count    int
        Seconds  int
}

type DetectionConfig struct {
        FastPattern  bool
        Nocase       bool
        Depth        int
        Offset       int
        Distance     int
        Within       int
        HTTPModifier string // http_uri, http_header, http_cookie, etc.
}

type FlowState struct {
        ID           string
        Protocol     string
        SrcIP        net.IP
        DstIP        net.IP
        SrcPort      uint16
        DstPort      uint16
        State        string
        Packets      int
        Bytes        int64
        StartTime    time.Time
        LastActivity time.Time
        FlowBits     map[string]bool
}

type SuricataAlert struct {
        Timestamp    time.Time              `json:"timestamp"`
        FlowID       string                 `json:"flow_id,omitempty"`
        EventType    string                 `json:"event_type"`
        SrcIP        string                 `json:"src_ip"`
        SrcPort      int                    `json:"src_port"`
        DstIP        string                 `json:"dest_ip"`
        DstPort      int                    `json:"dest_port"`
        Protocol     string                 `json:"proto"`
        Alert        *AlertInfo             `json:"alert"`
        Flow         *FlowInfo              `json:"flow,omitempty"`
        PacketInfo   *SuricataPacketInfo            `json:"packet_info,omitempty"`
        HTTP         map[string]interface{} `json:"http,omitempty"`
        DNS          map[string]interface{} `json:"dns,omitempty"`
        TLS          map[string]interface{} `json:"tls,omitempty"`
}

type AlertInfo struct {
        Action      string   `json:"action"`
        GID         int      `json:"gid"`
        SignatureID int      `json:"signature_id"`
        Rev         int      `json:"rev"`
        Signature   string   `json:"signature"`
        Category    string   `json:"category"`
        Severity    int      `json:"severity"`
        Metadata    []string `json:"metadata,omitempty"`
}

type FlowInfo struct {
        PktsToServer int    `json:"pkts_toserver"`
        PktsToClient int    `json:"pkts_toclient"`
        BytesToServer int64 `json:"bytes_toserver"`
        BytesToClient int64 `json:"bytes_toclient"`
        Start        string `json:"start"`
        Duration     int    `json:"duration"`
        State        string `json:"state"`
}

type SuricataPacketInfo struct {
        Linktype  int `json:"linktype"`
        Direction string `json:"direction"`
}

type SuricataStats struct {
        TotalPackets     uint64
        TotalAlerts      uint64
        TotalFlows       uint64
        ActiveFlows      uint64
        ClosedFlows      uint64
        AlertsByRule     map[int]uint64
        AlertsBySeverity map[int]uint64
        ProtocolStats    map[string]uint64
}

func NewSuricataEngine(eveFormat bool) *SuricataEngine <span class="cov1" title="1">{
        engine := &amp;SuricataEngine{
                rules:     make([]SuricataRule, 0),
                alerts:    make([]SuricataAlert, 0),
                flowTable: make(map[string]*FlowState),
                eveFormat: eveFormat,
                stats: SuricataStats{
                        AlertsByRule:     make(map[int]uint64),
                        AlertsBySeverity: make(map[int]uint64),
                        ProtocolStats:    make(map[string]uint64),
                },
        }
        
        engine.loadDefaultRules()
        return engine
}</span>

func (se *SuricataEngine) loadDefaultRules() <span class="cov1" title="1">{
        defaultRules := []string{
                // Emerging Threats style rules
                `alert http $EXTERNAL_NET any -&gt; $HOME_NET any (msg:"ET MALWARE Suspicious User-Agent"; content:"User-Agent|3a 20|"; http_header; content:"bot"; http_header; fast_pattern; classtype:trojan-activity; sid:2000001; rev:1;)`,
                `alert tcp $EXTERNAL_NET any -&gt; $HOME_NET 445 (msg:"ET EXPLOIT SMB EternalBlue Exploit"; content:"|ff|SMB"; depth:4; offset:4; content:"|00 00 00 00|"; within:4; flow:to_server,established; classtype:attempted-admin; sid:2000002; rev:1;)`,
                
                // Protocol anomaly detection
                `alert tcp any any -&gt; any any (msg:"SURICATA TCP invalid flags"; flags:FPU; classtype:protocol-command-decode; sid:2000003; rev:1;)`,
                `alert dns any any -&gt; any any (msg:"SURICATA DNS malformed query"; dns_query; content:"|00 00|"; depth:2; classtype:protocol-command-decode; sid:2000004; rev:1;)`,
                
                // Application layer detection
                `alert http any any -&gt; any any (msg:"SURICATA HTTP POST without Content-Length"; flow:established,to_server; content:"POST"; http_method; http_header_names; content:!"Content-Length"; classtype:protocol-command-decode; sid:2000005; rev:1;)`,
                `alert tls any any -&gt; any any (msg:"SURICATA TLS invalid version"; tls.version:!"1.0","1.1","1.2","1.3"; classtype:protocol-command-decode; sid:2000006; rev:1;)`,
                
                // File extraction and analysis
                `alert http any any -&gt; any any (msg:"SURICATA Executable file download"; flow:established,to_client; content:"MZ"; depth:2; http_server_body; file_data; classtype:policy-violation; sid:2000007; rev:1;)`,
                `alert smtp any any -&gt; any any (msg:"SURICATA SMTP suspicious attachment"; flow:established; content:"filename="; content:".exe"; within:20; classtype:policy-violation; sid:2000008; rev:1;)`,
                
                // Advanced flow tracking
                `alert tcp any any -&gt; any any (msg:"SURICATA Port scan detected"; flow:stateless; flags:S; threshold:type both, track by_src, count 20, seconds 60; classtype:attempted-recon; sid:2000009; rev:1;)`,
                `alert tcp any any -&gt; any 22 (msg:"SURICATA SSH brute force"; flow:to_server,established; content:"SSH-"; depth:4; threshold:type both, track by_src, count 5, seconds 300; classtype:attempted-user; sid:2000010; rev:1;)`,
                
                // Lua script integration examples
                `alert http any any -&gt; any any (msg:"SURICATA Complex HTTP attack"; flow:established,to_server; content:"eval("; http_uri; lua:complex_http_check.lua; classtype:web-application-attack; sid:2000011; rev:1;)`,
                
                // Stream reassembly detection
                `alert tcp any any -&gt; any any (msg:"SURICATA Large data transfer"; flow:established; stream_size:server,&gt;,10485760; classtype:policy-violation; sid:2000012; rev:1;)`,
                
                // IP reputation and geoip
                `alert ip any any -&gt; any any (msg:"SURICATA Blacklisted IP"; iprep:src,blacklist,&gt;,80; classtype:misc-attack; sid:2000013; rev:1;)`,
                
                // Dataset lookups
                `alert dns any any -&gt; any any (msg:"SURICATA DNS query to malicious domain"; dns_query; dataset:isset,malicious-domains,type string,state dns.query; classtype:trojan-activity; sid:2000014; rev:1;)`,
        }
        
        for _, ruleStr := range defaultRules </span><span class="cov4" title="14">{
                if rule := se.parseRule(ruleStr); rule != nil </span><span class="cov4" title="14">{
                        se.AddRule(*rule)
                }</span>
        }
}

func (se *SuricataEngine) parseRule(ruleStr string) *SuricataRule <span class="cov4" title="14">{
        ruleStr = strings.TrimSpace(ruleStr)
        if ruleStr == "" || strings.HasPrefix(ruleStr, "#") </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Split into header and options
        <span class="cov4" title="14">parts := strings.SplitN(ruleStr, "(", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov4" title="14">header := strings.TrimSpace(parts[0])
        optionsStr := strings.TrimSuffix(strings.TrimSpace(parts[1]), ")")
        
        // Parse header
        headerParts := strings.Fields(header)
        if len(headerParts) &lt; 7 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov4" title="14">rule := &amp;SuricataRule{
                Action:    headerParts[0],
                Protocol:  headerParts[1],
                SrcIP:     headerParts[2],
                SrcPort:   headerParts[3],
                Direction: headerParts[4],
                DstIP:     headerParts[5],
                DstPort:   headerParts[6],
                Options:   make(map[string][]string),
                Raw:       ruleStr,
                GID:       1, // Default generator ID
        }
        
        // Parse options (Suricata has more complex option syntax)
        se.parseSuricataOptions(rule, optionsStr)
        
        return rule</span>
}

func (se *SuricataEngine) parseSuricataOptions(rule *SuricataRule, optionsStr string) <span class="cov4" title="14">{
        options := se.splitOptions(optionsStr)
        
        for _, option := range options </span><span class="cov6" title="102">{
                option = strings.TrimSpace(option)
                if option == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov6" title="102">if strings.Contains(option, ":") </span><span class="cov6" title="92">{
                        parts := strings.SplitN(option, ":", 2)
                        key := strings.TrimSpace(parts[0])
                        value := strings.Trim(strings.TrimSpace(parts[1]), `"`)
                        
                        // Handle multi-value options
                        if existing, ok := rule.Options[key]; ok </span><span class="cov2" title="4">{
                                rule.Options[key] = append(existing, value)
                        }</span> else<span class="cov6" title="88"> {
                                rule.Options[key] = []string{value}
                        }</span>
                        
                        // Handle special options
                        <span class="cov6" title="92">switch key </span>{
                        case "msg":<span class="cov4" title="14">
                                rule.Message = value</span>
                        case "classtype":<span class="cov4" title="14">
                                rule.Classtype = value</span>
                        case "sid":<span class="cov4" title="14">
                                if sid, err := strconv.Atoi(value); err == nil </span><span class="cov4" title="14">{
                                        rule.SID = sid
                                }</span>
                        case "priority":<span class="cov0" title="0">
                                if priority, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                        rule.Priority = priority
                                }</span>
                        case "rev":<span class="cov4" title="14">
                                if rev, err := strconv.Atoi(value); err == nil </span><span class="cov4" title="14">{
                                        rule.Rev = rev
                                }</span>
                        case "gid":<span class="cov0" title="0">
                                if gid, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                                        rule.GID = gid
                                }</span>
                        case "metadata":<span class="cov0" title="0">
                                rule.Metadata = strings.Split(value, ",")</span>
                        case "reference":<span class="cov0" title="0">
                                rule.Reference = append(rule.Reference, value)</span>
                        case "threshold":<span class="cov1" title="2">
                                se.parseThreshold(rule, value)</span>
                        }
                } else<span class="cov3" title="10"> {
                        // Standalone options
                        rule.Options[option] = []string{""}
                }</span>
        }
}

func (se *SuricataEngine) parseThreshold(rule *SuricataRule, value string) <span class="cov1" title="2">{
        threshold := &amp;ThresholdConfig{}
        parts := strings.Split(value, ",")
        
        for _, part := range parts </span><span class="cov3" title="8">{
                part = strings.TrimSpace(part)
                if strings.Contains(part, " ") </span><span class="cov3" title="8">{
                        kv := strings.SplitN(part, " ", 2)
                        switch kv[0] </span>{
                        case "type":<span class="cov1" title="2">
                                threshold.Type = kv[1]</span>
                        case "track":<span class="cov1" title="2">
                                threshold.Track = kv[1]</span>
                        case "count":<span class="cov1" title="2">
                                threshold.Count, _ = strconv.Atoi(kv[1])</span>
                        case "seconds":<span class="cov1" title="2">
                                threshold.Seconds, _ = strconv.Atoi(kv[1])</span>
                        }
                }
        }
        
        <span class="cov1" title="2">rule.Threshold = threshold</span>
}

func (se *SuricataEngine) splitOptions(optionsStr string) []string <span class="cov4" title="14">{
        var options []string
        var current strings.Builder
        inQuotes := false
        depth := 0
        
        for _, char := range optionsStr </span><span class="cov10" title="2162">{
                switch char </span>{
                case '"':<span class="cov5" title="60">
                        inQuotes = !inQuotes
                        current.WriteRune(char)</span>
                case '(':<span class="cov1" title="1">
                        if !inQuotes </span><span class="cov0" title="0">{
                                depth++
                        }</span>
                        <span class="cov1" title="1">current.WriteRune(char)</span>
                case ')':<span class="cov0" title="0">
                        if !inQuotes </span><span class="cov0" title="0">{
                                depth--
                        }</span>
                        <span class="cov0" title="0">current.WriteRune(char)</span>
                case ';':<span class="cov6" title="102">
                        if !inQuotes &amp;&amp; depth == 0 </span><span class="cov6" title="102">{
                                options = append(options, current.String())
                                current.Reset()
                        }</span> else<span class="cov0" title="0"> {
                                current.WriteRune(char)
                        }</span>
                default:<span class="cov9" title="1999">
                        current.WriteRune(char)</span>
                }
        }
        
        <span class="cov4" title="14">if current.Len() &gt; 0 </span><span class="cov0" title="0">{
                options = append(options, current.String())
        }</span>
        
        <span class="cov4" title="14">return options</span>
}

func (se *SuricataEngine) AddRule(rule SuricataRule) <span class="cov4" title="14">{
        rule.ID = len(se.rules)
        se.rules = append(se.rules, rule)
}</span>

func (se *SuricataEngine) ProcessPacket(packet gopacket.Packet) []SuricataAlert <span class="cov0" title="0">{
        se.stats.TotalPackets++
        
        // Update flow state
        flow := se.updateFlowState(packet)
        
        var alerts []SuricataAlert
        
        for _, rule := range se.rules </span><span class="cov0" title="0">{
                if se.matchRule(rule, packet, flow) </span><span class="cov0" title="0">{
                        alert := se.createAlert(rule, packet, flow)
                        alerts = append(alerts, alert)
                        se.alerts = append(se.alerts, alert)
                        
                        se.stats.TotalAlerts++
                        se.stats.AlertsByRule[rule.SID]++
                        se.stats.AlertsBySeverity[rule.Priority]++
                }</span>
        }
        
        <span class="cov0" title="0">return alerts</span>
}

func (se *SuricataEngine) updateFlowState(packet gopacket.Packet) *FlowState <span class="cov0" title="0">{
        flowID := se.getFlowID(packet)
        if flowID == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">flow, exists := se.flowTable[flowID]
        if !exists </span><span class="cov0" title="0">{
                flow = se.createNewFlow(flowID, packet)
                se.flowTable[flowID] = flow
                se.stats.TotalFlows++
                se.stats.ActiveFlows++
        }</span>
        
        <span class="cov0" title="0">flow.Packets++
        flow.LastActivity = time.Now()
        
        // Update protocol stats
        se.stats.ProtocolStats[flow.Protocol]++
        
        // Calculate packet size
        if netLayer := packet.NetworkLayer(); netLayer != nil </span><span class="cov0" title="0">{
                flow.Bytes += int64(len(netLayer.LayerPayload()))
        }</span>
        
        <span class="cov0" title="0">return flow</span>
}

func (se *SuricataEngine) getFlowID(packet gopacket.Packet) string <span class="cov0" title="0">{
        netLayer := packet.NetworkLayer()
        if netLayer == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">src := netLayer.NetworkFlow().Src().String()
        dst := netLayer.NetworkFlow().Dst().String()
        
        var srcPort, dstPort uint16
        var protocol string
        
        if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                tcp := tcpLayer.(*layers.TCP)
                srcPort = uint16(tcp.SrcPort)
                dstPort = uint16(tcp.DstPort)
                protocol = "tcp"
        }</span> else<span class="cov0" title="0"> if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil </span><span class="cov0" title="0">{
                udp := udpLayer.(*layers.UDP)
                srcPort = uint16(udp.SrcPort)
                dstPort = uint16(udp.DstPort)
                protocol = "udp"
        }</span> else<span class="cov0" title="0"> {
                protocol = "other"
        }</span>
        
        // Create bidirectional flow ID
        <span class="cov0" title="0">if src &lt; dst || (src == dst &amp;&amp; srcPort &lt; dstPort) </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:%s:%d:%s:%d", protocol, src, srcPort, dst, dstPort)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s:%s:%d:%s:%d", protocol, dst, dstPort, src, srcPort)</span>
}

func (se *SuricataEngine) createNewFlow(flowID string, packet gopacket.Packet) *FlowState <span class="cov0" title="0">{
        netLayer := packet.NetworkLayer()
        
        flow := &amp;FlowState{
                ID:        flowID,
                SrcIP:     net.ParseIP(netLayer.NetworkFlow().Src().String()),
                DstIP:     net.ParseIP(netLayer.NetworkFlow().Dst().String()),
                StartTime: time.Now(),
                FlowBits:  make(map[string]bool),
                State:     "new",
        }
        
        if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                tcp := tcpLayer.(*layers.TCP)
                flow.Protocol = "tcp"
                flow.SrcPort = uint16(tcp.SrcPort)
                flow.DstPort = uint16(tcp.DstPort)
                
                // Track TCP state
                if tcp.SYN &amp;&amp; !tcp.ACK </span><span class="cov0" title="0">{
                        flow.State = "syn_sent"
                }</span> else<span class="cov0" title="0"> if tcp.SYN &amp;&amp; tcp.ACK </span><span class="cov0" title="0">{
                        flow.State = "syn_ack"
                }</span> else<span class="cov0" title="0"> if tcp.ACK </span><span class="cov0" title="0">{
                        flow.State = "established"
                }</span>
        } else<span class="cov0" title="0"> if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil </span><span class="cov0" title="0">{
                udp := udpLayer.(*layers.UDP)
                flow.Protocol = "udp"
                flow.SrcPort = uint16(udp.SrcPort)
                flow.DstPort = uint16(udp.DstPort)
                flow.State = "active"
        }</span>
        
        <span class="cov0" title="0">return flow</span>
}

func (se *SuricataEngine) matchRule(rule SuricataRule, packet gopacket.Packet, flow *FlowState) bool <span class="cov0" title="0">{
        // Check protocol
        if !se.matchProtocol(rule.Protocol, packet) </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check network conditions
        <span class="cov0" title="0">if !se.matchNetwork(rule, packet) </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check Suricata-specific options
        <span class="cov0" title="0">return se.matchSuricataOptions(rule, packet, flow)</span>
}

func (se *SuricataEngine) matchProtocol(protocol string, packet gopacket.Packet) bool <span class="cov0" title="0">{
        switch strings.ToLower(protocol) </span>{
        case "tcp":<span class="cov0" title="0">
                return packet.Layer(layers.LayerTypeTCP) != nil</span>
        case "udp":<span class="cov0" title="0">
                return packet.Layer(layers.LayerTypeUDP) != nil</span>
        case "icmp":<span class="cov0" title="0">
                return packet.Layer(layers.LayerTypeICMPv4) != nil</span>
        case "http":<span class="cov0" title="0">
                // Check for HTTP traffic on common ports
                if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                        tcp := tcpLayer.(*layers.TCP)
                        return tcp.DstPort == 80 || tcp.SrcPort == 80 || 
                               tcp.DstPort == 8080 || tcp.SrcPort == 8080
                }</span>
                <span class="cov0" title="0">return false</span>
        case "tls":<span class="cov0" title="0">
                // Check for TLS/HTTPS traffic
                if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                        tcp := tcpLayer.(*layers.TCP)
                        return tcp.DstPort == 443 || tcp.SrcPort == 443
                }</span>
                <span class="cov0" title="0">return false</span>
        case "dns":<span class="cov0" title="0">
                // Check for DNS traffic
                return packet.Layer(layers.LayerTypeDNS) != nil</span>
        case "smtp":<span class="cov0" title="0">
                // Check for SMTP traffic
                if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                        tcp := tcpLayer.(*layers.TCP)
                        return tcp.DstPort == 25 || tcp.SrcPort == 25 ||
                               tcp.DstPort == 587 || tcp.SrcPort == 587
                }</span>
                <span class="cov0" title="0">return false</span>
        case "ip":<span class="cov0" title="0">
                return packet.NetworkLayer() != nil</span>
        default:<span class="cov0" title="0">
                return true</span>
        }
}

func (se *SuricataEngine) matchNetwork(rule SuricataRule, packet gopacket.Packet) bool <span class="cov0" title="0">{
        netLayer := packet.NetworkLayer()
        if netLayer == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">srcIP := netLayer.NetworkFlow().Src().String()
        dstIP := netLayer.NetworkFlow().Dst().String()
        
        // Handle Suricata variables
        srcIPMatch := se.matchIPWithVariables(rule.SrcIP, srcIP)
        dstIPMatch := se.matchIPWithVariables(rule.DstIP, dstIP)
        
        // Handle bidirectional rules
        if rule.Direction == "&lt;&gt;" </span><span class="cov0" title="0">{
                return (srcIPMatch &amp;&amp; dstIPMatch) || (se.matchIPWithVariables(rule.SrcIP, dstIP) &amp;&amp; se.matchIPWithVariables(rule.DstIP, srcIP))
        }</span>
        
        <span class="cov0" title="0">return srcIPMatch &amp;&amp; dstIPMatch</span>
}

func (se *SuricataEngine) matchIPWithVariables(ruleIP, packetIP string) bool <span class="cov0" title="0">{
        // Handle Suricata variables
        switch ruleIP </span>{
        case "any":<span class="cov0" title="0">
                return true</span>
        case "$HOME_NET":<span class="cov0" title="0">
                // Check if IP is in home network (simplified)
                return strings.HasPrefix(packetIP, "192.168.") || 
                       strings.HasPrefix(packetIP, "10.") ||
                       strings.HasPrefix(packetIP, "172.")</span>
        case "$EXTERNAL_NET":<span class="cov0" title="0">
                // Check if IP is external
                return !strings.HasPrefix(packetIP, "192.168.") &amp;&amp; 
                       !strings.HasPrefix(packetIP, "10.") &amp;&amp;
                       !strings.HasPrefix(packetIP, "172.")</span>
        default:<span class="cov0" title="0">
                // Handle CIDR and regular IPs
                if strings.Contains(ruleIP, "/") </span><span class="cov0" title="0">{
                        _, network, err := net.ParseCIDR(ruleIP)
                        if err != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">ip := net.ParseIP(packetIP)
                        return network.Contains(ip)</span>
                }
                <span class="cov0" title="0">return ruleIP == packetIP</span>
        }
}

func (se *SuricataEngine) matchSuricataOptions(rule SuricataRule, packet gopacket.Packet, flow *FlowState) bool <span class="cov0" title="0">{
        payload := se.getPacketPayload(packet)
        
        // Check flow options first
        if flowOpts, ok := rule.Options["flow"]; ok </span><span class="cov0" title="0">{
                if !se.matchFlowOptions(flowOpts, flow) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        // Check content matches
        <span class="cov0" title="0">contentMatched := true
        for option, values := range rule.Options </span><span class="cov0" title="0">{
                switch option </span>{
                case "content":<span class="cov0" title="0">
                        for _, content := range values </span><span class="cov0" title="0">{
                                if !se.matchContent(content, payload, rule.Options) </span><span class="cov0" title="0">{
                                        contentMatched = false
                                        break</span>
                                }
                        }
                case "pcre":<span class="cov0" title="0">
                        for _, pattern := range values </span><span class="cov0" title="0">{
                                if !se.matchPCRE(pattern, payload) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                case "dsize":<span class="cov0" title="0">
                        for _, size := range values </span><span class="cov0" title="0">{
                                if !se.matchDataSize(size, len(payload)) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                case "flags":<span class="cov0" title="0">
                        for _, flags := range values </span><span class="cov0" title="0">{
                                if !se.matchTCPFlags(flags, packet) </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }
                case "http_header":<span class="cov0" title="0">
                        if !se.matchHTTPHeader(values, payload) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case "tls.version":<span class="cov0" title="0">
                        if !se.matchTLSVersion(values, payload) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return contentMatched</span>
}

func (se *SuricataEngine) matchFlowOptions(flowOpts []string, flow *FlowState) bool <span class="cov0" title="0">{
        if flow == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">for _, opt := range flowOpts </span><span class="cov0" title="0">{
                parts := strings.Split(opt, ",")
                for _, part := range parts </span><span class="cov0" title="0">{
                        part = strings.TrimSpace(part)
                        switch part </span>{
                        case "established":<span class="cov0" title="0">
                                if flow.State != "established" </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        case "to_server":<span class="cov0" title="0">
                                // Simplified check
                                if flow.DstPort &gt;= 1024 &amp;&amp; flow.SrcPort &lt; 1024 </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        case "to_client":<span class="cov0" title="0">
                                // Simplified check
                                if flow.SrcPort &gt;= 1024 &amp;&amp; flow.DstPort &lt; 1024 </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        case "stateless":<span class="cov0" title="0">
                                // Always match for stateless
                                continue</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return true</span>
}

func (se *SuricataEngine) matchContent(content string, payload []byte, options map[string][]string) bool <span class="cov0" title="0">{
        // Handle hex content
        if strings.Contains(content, "|") </span><span class="cov0" title="0">{
                content = se.parseHexContent(content)
        }</span>
        
        <span class="cov0" title="0">payloadStr := string(payload)
        
        // Check for nocase option
        if _, nocase := options["nocase"]; nocase </span><span class="cov0" title="0">{
                return strings.Contains(strings.ToLower(payloadStr), strings.ToLower(content))
        }</span>
        
        // Check depth and offset
        <span class="cov0" title="0">if depthVals, ok := options["depth"]; ok &amp;&amp; len(depthVals) &gt; 0 </span><span class="cov0" title="0">{
                depth, _ := strconv.Atoi(depthVals[0])
                if len(payload) &gt; depth </span><span class="cov0" title="0">{
                        payload = payload[:depth]
                }</span>
        }
        
        <span class="cov0" title="0">if offsetVals, ok := options["offset"]; ok &amp;&amp; len(offsetVals) &gt; 0 </span><span class="cov0" title="0">{
                offset, _ := strconv.Atoi(offsetVals[0])
                if offset &lt; len(payload) </span><span class="cov0" title="0">{
                        payload = payload[offset:]
                }</span>
        }
        
        <span class="cov0" title="0">return strings.Contains(string(payload), content)</span>
}

func (se *SuricataEngine) parseHexContent(content string) string <span class="cov0" title="0">{
        // Simple hex content parser
        re := regexp.MustCompile(`\|([0-9a-fA-F\s]+)\|`)
        return re.ReplaceAllStringFunc(content, func(match string) string </span><span class="cov0" title="0">{
                hex := strings.Trim(match, "|")
                hex = strings.ReplaceAll(hex, " ", "")
                result := ""
                for i := 0; i &lt; len(hex); i += 2 </span><span class="cov0" title="0">{
                        if i+1 &lt; len(hex) </span><span class="cov0" title="0">{
                                val, _ := strconv.ParseInt(hex[i:i+2], 16, 8)
                                result += string(byte(val))
                        }</span>
                }
                <span class="cov0" title="0">return result</span>
        })
}

func (se *SuricataEngine) matchPCRE(pattern string, payload []byte) bool <span class="cov0" title="0">{
        // Remove PCRE delimiters and flags
        if len(pattern) &gt;= 2 &amp;&amp; pattern[0] == '/' </span><span class="cov0" title="0">{
                endIdx := strings.LastIndex(pattern[1:], "/")
                if endIdx &gt; 0 </span><span class="cov0" title="0">{
                        pattern = pattern[1:endIdx+1]
                }</span>
        }
        
        <span class="cov0" title="0">re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">return re.Match(payload)</span>
}

func (se *SuricataEngine) matchHTTPHeader(values []string, payload []byte) bool <span class="cov0" title="0">{
        // Simple HTTP header check
        payloadStr := string(payload)
        return strings.Contains(payloadStr, "HTTP/") &amp;&amp; strings.Contains(payloadStr, "\r\n")
}</span>

func (se *SuricataEngine) matchTLSVersion(versions []string, payload []byte) bool <span class="cov0" title="0">{
        // Simple TLS version check (would need proper TLS parsing in production)
        if len(payload) &lt; 6 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check for TLS handshake
        <span class="cov0" title="0">if payload[0] == 0x16 &amp;&amp; payload[1] == 0x03 </span><span class="cov0" title="0">{
                tlsVersion := fmt.Sprintf("%d.%d", payload[1]-2, payload[2])
                for _, v := range versions </span><span class="cov0" title="0">{
                        if v == tlsVersion </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return false</span>
}

func (se *SuricataEngine) matchDataSize(sizeRule string, actualSize int) bool <span class="cov0" title="0">{
        // Handle operators: &gt;, &lt;, =
        if strings.HasPrefix(sizeRule, "&gt;") </span><span class="cov0" title="0">{
                threshold, _ := strconv.Atoi(sizeRule[1:])
                return actualSize &gt; threshold
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(sizeRule, "&lt;") </span><span class="cov0" title="0">{
                threshold, _ := strconv.Atoi(sizeRule[1:])
                return actualSize &lt; threshold
        }</span>
        
        <span class="cov0" title="0">exactSize, _ := strconv.Atoi(sizeRule)
        return actualSize == exactSize</span>
}

func (se *SuricataEngine) matchTCPFlags(flagsRule string, packet gopacket.Packet) bool <span class="cov0" title="0">{
        tcpLayer := packet.Layer(layers.LayerTypeTCP)
        if tcpLayer == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">tcp := tcpLayer.(*layers.TCP)
        
        // Parse flag combinations (e.g., "S", "SA", "FPU")
        for _, flag := range flagsRule </span><span class="cov0" title="0">{
                switch flag </span>{
                case 'S':<span class="cov0" title="0">
                        if !tcp.SYN </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case 'A':<span class="cov0" title="0">
                        if !tcp.ACK </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case 'F':<span class="cov0" title="0">
                        if !tcp.FIN </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case 'R':<span class="cov0" title="0">
                        if !tcp.RST </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case 'P':<span class="cov0" title="0">
                        if !tcp.PSH </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case 'U':<span class="cov0" title="0">
                        if !tcp.URG </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return true</span>
}

func (se *SuricataEngine) getPacketPayload(packet gopacket.Packet) []byte <span class="cov0" title="0">{
        if app := packet.ApplicationLayer(); app != nil </span><span class="cov0" title="0">{
                return app.Payload()
        }</span>
        <span class="cov0" title="0">if transport := packet.TransportLayer(); transport != nil </span><span class="cov0" title="0">{
                return transport.LayerPayload()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (se *SuricataEngine) createAlert(rule SuricataRule, packet gopacket.Packet, flow *FlowState) SuricataAlert <span class="cov0" title="0">{
        netLayer := packet.NetworkLayer()
        srcIP := netLayer.NetworkFlow().Src().String()
        dstIP := netLayer.NetworkFlow().Dst().String()
        
        var srcPort, dstPort int
        var protocol string
        
        if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                tcp := tcpLayer.(*layers.TCP)
                srcPort = int(tcp.SrcPort)
                dstPort = int(tcp.DstPort)
                protocol = "TCP"
        }</span> else<span class="cov0" title="0"> if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil </span><span class="cov0" title="0">{
                udp := udpLayer.(*layers.UDP)
                srcPort = int(udp.SrcPort)
                dstPort = int(udp.DstPort)
                protocol = "UDP"
        }</span> else<span class="cov0" title="0"> if packet.Layer(layers.LayerTypeICMPv4) != nil </span><span class="cov0" title="0">{
                protocol = "ICMP"
        }</span>
        
        <span class="cov0" title="0">alert := SuricataAlert{
                Timestamp: time.Now(),
                EventType: "alert",
                SrcIP:     srcIP,
                SrcPort:   srcPort,
                DstIP:     dstIP,
                DstPort:   dstPort,
                Protocol:  protocol,
                Alert: &amp;AlertInfo{
                        Action:      rule.Action,
                        GID:         rule.GID,
                        SignatureID: rule.SID,
                        Rev:         rule.Rev,
                        Signature:   rule.Message,
                        Category:    rule.Classtype,
                        Severity:    se.getSeverity(rule.Priority),
                        Metadata:    rule.Metadata,
                },
        }
        
        // Add flow information
        if flow != nil </span><span class="cov0" title="0">{
                alert.FlowID = flow.ID
                alert.Flow = &amp;FlowInfo{
                        PktsToServer:  flow.Packets / 2, // Simplified
                        PktsToClient:  flow.Packets / 2,
                        BytesToServer: flow.Bytes / 2,
                        BytesToClient: flow.Bytes / 2,
                        Start:         flow.StartTime.Format(time.RFC3339),
                        Duration:      int(time.Since(flow.StartTime).Seconds()),
                        State:         flow.State,
                }
        }</span>
        
        // Add packet info
        <span class="cov0" title="0">alert.PacketInfo = &amp;SuricataPacketInfo{
                Linktype:  1, // Ethernet
                Direction: "to_server", // Simplified
        }
        
        return alert</span>
}

func (se *SuricataEngine) getSeverity(priority int) int <span class="cov0" title="0">{
        // Convert priority to severity (1-4 scale)
        switch priority </span>{
        case 1:<span class="cov0" title="0">
                return 1</span> // Critical
        case 2:<span class="cov0" title="0">
                return 2</span> // High
        case 3:<span class="cov0" title="0">
                return 3</span> // Medium
        default:<span class="cov0" title="0">
                return 4</span> // Low
        }
}

func (se *SuricataEngine) GetAlerts() []SuricataAlert <span class="cov0" title="0">{
        return se.alerts
}</span>

func (se *SuricataEngine) GetAlertsAsJSON() ([]byte, error) <span class="cov0" title="0">{
        if se.eveFormat </span><span class="cov0" title="0">{
                // EVE JSON format (one JSON object per line)
                var output strings.Builder
                for _, alert := range se.alerts </span><span class="cov0" title="0">{
                        data, err := json.Marshal(alert)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">output.Write(data)
                        output.WriteString("\n")</span>
                }
                <span class="cov0" title="0">return []byte(output.String()), nil</span>
        }
        
        // Standard JSON array
        <span class="cov0" title="0">return json.MarshalIndent(se.alerts, "", "  ")</span>
}

func (se *SuricataEngine) GetStats() interface{} <span class="cov0" title="0">{
        return se.stats
}</span>

func (se *SuricataEngine) GetRules() []SuricataRule <span class="cov0" title="0">{
        return se.rules
}</span>

func (se *SuricataEngine) ClearAlerts() <span class="cov0" title="0">{
        se.alerts = make([]SuricataAlert, 0)
}</span>

func (se *SuricataEngine) CleanupFlows() <span class="cov0" title="0">{
        cutoff := time.Now().Add(-5 * time.Minute)
        for id, flow := range se.flowTable </span><span class="cov0" title="0">{
                if flow.LastActivity.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(se.flowTable, id)
                        se.stats.ActiveFlows--
                        se.stats.ClosedFlows++
                }</span>
        }
}</pre>
		
		<pre class="file" id="file14" style="display: none">package security

import (
        "bytes"
        "encoding/hex"
        "fmt"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
)

// YARAEngine implements YARA rule matching for network traffic
type YARAEngine struct {
        rules   []YARARule
        matches []YARAMatch
        stats   YARAStats
        mu      sync.Mutex
}

type YARARule struct {
        ID          string
        Name        string
        Tags        []string
        Meta        map[string]string
        Strings     []YARAString
        Condition   string
        Imports     []string
        Description string
        Author      string
        Date        string
        Version     string
        ThreatLevel string
}

type YARAString struct {
        ID         string
        Value      string
        Type       string // "text", "hex", "regex"
        Modifiers  []string // "nocase", "wide", "ascii", "fullword", etc.
        Offset     int
        References []string
}

type YARAMatch struct {
        Timestamp   time.Time
        RuleID      string
        RuleName    string
        Tags        []string
        Strings     []StringMatch
        PacketInfo  PacketDetails
        ThreatLevel string
        Meta        map[string]string
}

type StringMatch struct {
        StringID string
        Offset   int
        Length   int
        Data     string
}

type PacketDetails struct {
        SrcIP     string
        DstIP     string
        SrcPort   int
        DstPort   int
        Protocol  string
        Direction string
        Size      int
        Payload   []byte
}

type YARAStats struct {
        TotalPackets    uint64
        TotalMatches    uint64
        MatchesByRule   map[string]uint64
        MatchesByTag    map[string]uint64
        MatchesByThreat map[string]uint64
}

func NewYARAEngine() *YARAEngine <span class="cov8" title="1">{
        engine := &amp;YARAEngine{
                rules:   make([]YARARule, 0),
                matches: make([]YARAMatch, 0),
                stats: YARAStats{
                        MatchesByRule:   make(map[string]uint64),
                        MatchesByTag:    make(map[string]uint64),
                        MatchesByThreat: make(map[string]uint64),
                },
        }
        
        engine.loadDefaultRules()
        return engine
}</span>

func (ye *YARAEngine) loadDefaultRules() <span class="cov8" title="1">{
        // Load default YARA rules for network traffic analysis
        defaultRules := []YARARule{
                {
                        ID:          "malware_generic_backdoor",
                        Name:        "Generic_Backdoor_Commands",
                        Tags:        []string{"backdoor", "malware"},
                        ThreatLevel: "high",
                        Meta: map[string]string{
                                "author":      "NetMon Security",
                                "description": "Detects generic backdoor commands",
                                "date":        "2024-01-01",
                        },
                        Strings: []YARAString{
                                {ID: "$cmd1", Value: "cmd.exe", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$cmd2", Value: "/bin/sh", Type: "text"},
                                {ID: "$cmd3", Value: "powershell", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$reverse", Value: "reverse", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$shell", Value: "shell", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$connect", Value: "connect", Type: "text", Modifiers: []string{"nocase"}},
                        },
                        Condition: "any of ($cmd*) and ($reverse or $shell) and $connect",
                },
                {
                        ID:          "exploit_sql_injection",
                        Name:        "SQL_Injection_Patterns",
                        Tags:        []string{"sqli", "exploit", "web"},
                        ThreatLevel: "high",
                        Meta: map[string]string{
                                "author":      "NetMon Security",
                                "description": "Detects SQL injection attempts",
                        },
                        Strings: []YARAString{
                                {ID: "$union", Value: "union select", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$sqli1", Value: "' or '1'='1", Type: "text"},
                                {ID: "$sqli2", Value: "\" or \"1\"=\"1", Type: "text"},
                                {ID: "$sqli3", Value: "'; drop table", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$sqli4", Value: "--", Type: "text"},
                                {ID: "$sqli5", Value: "/**/", Type: "text"},
                                {ID: "$sqli6", Value: "0x[0-9a-fA-F]+", Type: "regex"},
                        },
                        Condition: "$union or any of ($sqli*)",
                },
                {
                        ID:          "exploit_xss",
                        Name:        "XSS_Attack_Patterns",
                        Tags:        []string{"xss", "exploit", "web"},
                        ThreatLevel: "medium",
                        Meta: map[string]string{
                                "author":      "NetMon Security",
                                "description": "Detects XSS attack patterns",
                        },
                        Strings: []YARAString{
                                {ID: "$script1", Value: "&lt;script", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$script2", Value: "javascript:", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$onerror", Value: "onerror=", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$onload", Value: "onload=", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$alert", Value: "alert(", Type: "text"},
                                {ID: "$eval", Value: "eval(", Type: "text"},
                        },
                        Condition: "any of them",
                },
                {
                        ID:          "malware_cryptominer",
                        Name:        "Cryptocurrency_Miner",
                        Tags:        []string{"cryptominer", "malware"},
                        ThreatLevel: "medium",
                        Meta: map[string]string{
                                "author":      "NetMon Security",
                                "description": "Detects cryptocurrency mining activity",
                        },
                        Strings: []YARAString{
                                {ID: "$stratum", Value: "stratum+tcp://", Type: "text"},
                                {ID: "$pool1", Value: "pool.minergate", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$pool2", Value: "xmrpool", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$worker", Value: "\"worker\"", Type: "text"},
                                {ID: "$monero", Value: "monero", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$coinhive", Value: "coinhive", Type: "text", Modifiers: []string{"nocase"}},
                        },
                        Condition: "$stratum or (any of ($pool*) and $worker) or $coinhive",
                },
                {
                        ID:          "malware_ransomware",
                        Name:        "Ransomware_Indicators",
                        Tags:        []string{"ransomware", "malware"},
                        ThreatLevel: "critical",
                        Meta: map[string]string{
                                "author":      "NetMon Security",
                                "description": "Detects ransomware indicators",
                        },
                        Strings: []YARAString{
                                {ID: "$ransom1", Value: "Your files have been encrypted", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$ransom2", Value: "bitcoin", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$ransom3", Value: "decrypt", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$ransom4", Value: ".locked", Type: "text"},
                                {ID: "$ransom5", Value: ".encrypted", Type: "text"},
                                {ID: "$aes", Value: "AES", Type: "text"},
                                {ID: "$rsa", Value: "RSA", Type: "text"},
                        },
                        Condition: "$ransom1 or ($ransom2 and $ransom3) or (2 of ($ransom*))",
                },
                {
                        ID:          "protocol_anomaly_dns",
                        Name:        "DNS_Tunneling_Detection",
                        Tags:        []string{"dns", "tunneling", "anomaly"},
                        ThreatLevel: "medium",
                        Meta: map[string]string{
                                "author":      "NetMon Security",
                                "description": "Detects potential DNS tunneling",
                        },
                        Strings: []YARAString{
                                {ID: "$dns_header", Value: "00000100", Type: "hex"},
                                {ID: "$long_domain", Value: "[a-zA-Z0-9]{50,}", Type: "regex"},
                                {ID: "$base64", Value: "[A-Za-z0-9+/]{20,}={0,2}", Type: "regex"},
                                {ID: "$txt_query", Value: "0010", Type: "hex"},
                        },
                        Condition: "$dns_header and ($long_domain or $base64)",
                },
                {
                        ID:          "malware_webshell",
                        Name:        "Webshell_Detection",
                        Tags:        []string{"webshell", "backdoor"},
                        ThreatLevel: "high",
                        Meta: map[string]string{
                                "author":      "NetMon Security",
                                "description": "Detects webshell patterns",
                        },
                        Strings: []YARAString{
                                {ID: "$eval", Value: "eval(", Type: "text"},
                                {ID: "$base64", Value: "base64_decode", Type: "text"},
                                {ID: "$system", Value: "system(", Type: "text"},
                                {ID: "$exec", Value: "exec(", Type: "text"},
                                {ID: "$passthru", Value: "passthru(", Type: "text"},
                                {ID: "$cmd", Value: "$_REQUEST", Type: "text"},
                                {ID: "$post", Value: "$_POST", Type: "text"},
                        },
                        Condition: "($eval or $base64) and any of ($system, $exec, $passthru) and any of ($cmd, $post)",
                },
                {
                        ID:          "exploit_log4j",
                        Name:        "Log4j_Exploit_Attempt",
                        Tags:        []string{"log4j", "exploit", "cve-2021-44228"},
                        ThreatLevel: "critical",
                        Meta: map[string]string{
                                "author":      "NetMon Security",
                                "description": "Detects Log4j exploit attempts",
                                "reference":   "CVE-2021-44228",
                        },
                        Strings: []YARAString{
                                {ID: "$jndi", Value: "${jndi:", Type: "text"},
                                {ID: "$ldap", Value: "ldap://", Type: "text"},
                                {ID: "$rmi", Value: "rmi://", Type: "text"},
                                {ID: "$dns", Value: "dns://", Type: "text"},
                                {ID: "$lower", Value: "${lower:", Type: "text"},
                                {ID: "$upper", Value: "${upper:", Type: "text"},
                        },
                        Condition: "$jndi and any of ($ldap, $rmi, $dns)",
                },
                {
                        ID:          "malware_c2_communication",
                        Name:        "C2_Communication_Patterns",
                        Tags:        []string{"c2", "malware", "communication"},
                        ThreatLevel: "high",
                        Meta: map[string]string{
                                "author":      "NetMon Security",
                                "description": "Detects command and control communication",
                        },
                        Strings: []YARAString{
                                {ID: "$beacon", Value: "beacon", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$checkin", Value: "check-in", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$agent", Value: "agent", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$bot_id", Value: "bot_id", Type: "text"},
                                {ID: "$command", Value: "command", Type: "text"},
                                {ID: "$base64", Value: "[A-Za-z0-9+/]{100,}={0,2}", Type: "regex"},
                        },
                        Condition: "2 of them",
                },
                {
                        ID:          "data_exfiltration",
                        Name:        "Data_Exfiltration_Patterns",
                        Tags:        []string{"exfiltration", "data_theft"},
                        ThreatLevel: "high",
                        Meta: map[string]string{
                                "author":      "NetMon Security",
                                "description": "Detects potential data exfiltration",
                        },
                        Strings: []YARAString{
                                {ID: "$zip_header", Value: "PK", Type: "text"},
                                {ID: "$rar_header", Value: "Rar!", Type: "text"},
                                {ID: "$7z_header", Value: "377abcaf271c", Type: "hex"},
                                {ID: "$password", Value: "password", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$credential", Value: "credential", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$secret", Value: "secret", Type: "text", Modifiers: []string{"nocase"}},
                                {ID: "$api_key", Value: "api_key", Type: "text", Modifiers: []string{"nocase"}},
                        },
                        Condition: "any of ($*_header) and any of ($password, $credential, $secret, $api_key)",
                },
        }
        
        ye.rules = defaultRules
}</span>

func (ye *YARAEngine) ProcessPacket(packet gopacket.Packet) []YARAMatch <span class="cov0" title="0">{
        ye.stats.TotalPackets++
        
        // Extract packet details
        details := ye.extractPacketDetails(packet)
        if details.Payload == nil || len(details.Payload) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">var matches []YARAMatch
        
        // Check each rule against the packet
        for _, rule := range ye.rules </span><span class="cov0" title="0">{
                if match := ye.matchRule(rule, details); match != nil </span><span class="cov0" title="0">{
                        matches = append(matches, *match)
                        ye.matches = append(ye.matches, *match)
                        
                        ye.stats.TotalMatches++
                        ye.stats.MatchesByRule[rule.ID]++
                        
                        for _, tag := range rule.Tags </span><span class="cov0" title="0">{
                                ye.stats.MatchesByTag[tag]++
                        }</span>
                        
                        <span class="cov0" title="0">ye.stats.MatchesByThreat[rule.ThreatLevel]++</span>
                }
        }
        
        <span class="cov0" title="0">return matches</span>
}

func (ye *YARAEngine) extractPacketDetails(packet gopacket.Packet) PacketDetails <span class="cov0" title="0">{
        details := PacketDetails{
                Size: len(packet.Data()),
        }
        
        // Extract network layer info
        if netLayer := packet.NetworkLayer(); netLayer != nil </span><span class="cov0" title="0">{
                details.SrcIP = netLayer.NetworkFlow().Src().String()
                details.DstIP = netLayer.NetworkFlow().Dst().String()
        }</span>
        
        // Extract transport layer info
        <span class="cov0" title="0">if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                tcp := tcpLayer.(*layers.TCP)
                details.SrcPort = int(tcp.SrcPort)
                details.DstPort = int(tcp.DstPort)
                details.Protocol = "TCP"
        }</span> else<span class="cov0" title="0"> if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil </span><span class="cov0" title="0">{
                udp := udpLayer.(*layers.UDP)
                details.SrcPort = int(udp.SrcPort)
                details.DstPort = int(udp.DstPort)
                details.Protocol = "UDP"
        }</span>
        
        // Extract payload
        <span class="cov0" title="0">if app := packet.ApplicationLayer(); app != nil </span><span class="cov0" title="0">{
                details.Payload = app.Payload()
        }</span> else<span class="cov0" title="0"> if transport := packet.TransportLayer(); transport != nil </span><span class="cov0" title="0">{
                details.Payload = transport.LayerPayload()
        }</span>
        
        // Determine direction (simplified)
        <span class="cov0" title="0">if details.DstPort &lt; 1024 </span><span class="cov0" title="0">{
                details.Direction = "to_server"
        }</span> else<span class="cov0" title="0"> {
                details.Direction = "to_client"
        }</span>
        
        <span class="cov0" title="0">return details</span>
}

func (ye *YARAEngine) matchRule(rule YARARule, details PacketDetails) *YARAMatch <span class="cov0" title="0">{
        stringMatches := make(map[string][]StringMatch)
        
        // Check each string in the rule
        for _, str := range rule.Strings </span><span class="cov0" title="0">{
                if matches := ye.matchString(str, details.Payload); len(matches) &gt; 0 </span><span class="cov0" title="0">{
                        stringMatches[str.ID] = matches
                }</span>
        }
        
        // Evaluate condition
        <span class="cov0" title="0">if ye.evaluateCondition(rule.Condition, stringMatches, rule.Strings) </span><span class="cov0" title="0">{
                match := &amp;YARAMatch{
                        Timestamp:   time.Now(),
                        RuleID:      rule.ID,
                        RuleName:    rule.Name,
                        Tags:        rule.Tags,
                        Strings:     ye.flattenMatches(stringMatches),
                        PacketInfo:  details,
                        ThreatLevel: rule.ThreatLevel,
                        Meta:        rule.Meta,
                }
                
                return match
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

func (ye *YARAEngine) matchString(str YARAString, payload []byte) []StringMatch <span class="cov0" title="0">{
        var matches []StringMatch
        
        switch str.Type </span>{
        case "text":<span class="cov0" title="0">
                matches = ye.matchTextString(str, payload)</span>
        case "hex":<span class="cov0" title="0">
                matches = ye.matchHexString(str, payload)</span>
        case "regex":<span class="cov0" title="0">
                matches = ye.matchRegexString(str, payload)</span>
        }
        
        <span class="cov0" title="0">return matches</span>
}

func (ye *YARAEngine) matchTextString(str YARAString, payload []byte) []StringMatch <span class="cov0" title="0">{
        var matches []StringMatch
        searchStr := str.Value
        payloadStr := string(payload)
        
        // Apply modifiers
        nocase := false
        fullword := false
        for _, mod := range str.Modifiers </span><span class="cov0" title="0">{
                switch mod </span>{
                case "nocase":<span class="cov0" title="0">
                        nocase = true</span>
                case "fullword":<span class="cov0" title="0">
                        fullword = true</span>
                }
        }
        
        <span class="cov0" title="0">if nocase </span><span class="cov0" title="0">{
                searchStr = strings.ToLower(searchStr)
                payloadStr = strings.ToLower(payloadStr)
        }</span>
        
        // Find all occurrences
        <span class="cov0" title="0">start := 0
        for </span><span class="cov0" title="0">{
                index := strings.Index(payloadStr[start:], searchStr)
                if index == -1 </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">actualIndex := start + index
                
                // Check fullword modifier
                if fullword </span><span class="cov0" title="0">{
                        if actualIndex &gt; 0 &amp;&amp; isWordChar(payloadStr[actualIndex-1]) </span><span class="cov0" title="0">{
                                start = actualIndex + 1
                                continue</span>
                        }
                        <span class="cov0" title="0">if actualIndex+len(searchStr) &lt; len(payloadStr) &amp;&amp; isWordChar(payloadStr[actualIndex+len(searchStr)]) </span><span class="cov0" title="0">{
                                start = actualIndex + 1
                                continue</span>
                        }
                }
                
                <span class="cov0" title="0">match := StringMatch{
                        StringID: str.ID,
                        Offset:   actualIndex,
                        Length:   len(str.Value),
                        Data:     str.Value,
                }
                matches = append(matches, match)
                
                start = actualIndex + 1</span>
        }
        
        <span class="cov0" title="0">return matches</span>
}

func (ye *YARAEngine) matchHexString(str YARAString, payload []byte) []StringMatch <span class="cov0" title="0">{
        var matches []StringMatch
        
        // Parse hex string
        hexBytes, err := ye.parseHexString(str.Value)
        if err != nil </span><span class="cov0" title="0">{
                return matches
        }</span>
        
        // Find all occurrences
        <span class="cov0" title="0">for i := 0; i &lt;= len(payload)-len(hexBytes); i++ </span><span class="cov0" title="0">{
                if bytes.Equal(payload[i:i+len(hexBytes)], hexBytes) </span><span class="cov0" title="0">{
                        match := StringMatch{
                                StringID: str.ID,
                                Offset:   i,
                                Length:   len(hexBytes),
                                Data:     hex.EncodeToString(hexBytes),
                        }
                        matches = append(matches, match)
                }</span>
        }
        
        <span class="cov0" title="0">return matches</span>
}

func (ye *YARAEngine) matchRegexString(str YARAString, payload []byte) []StringMatch <span class="cov0" title="0">{
        var matches []StringMatch
        
        re, err := regexp.Compile(str.Value)
        if err != nil </span><span class="cov0" title="0">{
                return matches
        }</span>
        
        <span class="cov0" title="0">allMatches := re.FindAllIndex(payload, -1)
        for _, match := range allMatches </span><span class="cov0" title="0">{
                stringMatch := StringMatch{
                        StringID: str.ID,
                        Offset:   match[0],
                        Length:   match[1] - match[0],
                        Data:     string(payload[match[0]:match[1]]),
                }
                matches = append(matches, stringMatch)
        }</span>
        
        <span class="cov0" title="0">return matches</span>
}

func (ye *YARAEngine) evaluateCondition(condition string, matches map[string][]StringMatch, yaraStrings []YARAString) bool <span class="cov0" title="0">{
        // Simplified condition evaluation
        condition = strings.TrimSpace(condition)
        
        // Handle "any of them"
        if condition == "any of them" </span><span class="cov0" title="0">{
                return len(matches) &gt; 0
        }</span>
        
        // Handle "all of them"
        <span class="cov0" title="0">if condition == "all of them" </span><span class="cov0" title="0">{
                return len(matches) == len(yaraStrings)
        }</span>
        
        // Handle "n of them"
        <span class="cov0" title="0">if strings.HasPrefix(condition, "2 of them") </span><span class="cov0" title="0">{
                return len(matches) &gt;= 2
        }</span>
        
        // Handle specific string references
        <span class="cov0" title="0">if strings.Contains(condition, " or ") </span><span class="cov0" title="0">{
                parts := strings.Split(condition, " or ")
                for _, part := range parts </span><span class="cov0" title="0">{
                        part = strings.TrimSpace(part)
                        if ye.evaluateSimpleCondition(part, matches) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
        
        <span class="cov0" title="0">if strings.Contains(condition, " and ") </span><span class="cov0" title="0">{
                parts := strings.Split(condition, " and ")
                for _, part := range parts </span><span class="cov0" title="0">{
                        part = strings.TrimSpace(part)
                        if !ye.evaluateSimpleCondition(part, matches) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        }
        
        // Single condition
        <span class="cov0" title="0">return ye.evaluateSimpleCondition(condition, matches)</span>
}

func (ye *YARAEngine) evaluateSimpleCondition(condition string, matches map[string][]StringMatch) bool <span class="cov0" title="0">{
        // Handle wildcards like ($cmd*)
        if strings.Contains(condition, "*") </span><span class="cov0" title="0">{
                // Extract pattern
                pattern := strings.Trim(condition, "()")
                prefix := strings.TrimSuffix(pattern, "*")
                
                if strings.HasPrefix(condition, "any of") </span><span class="cov0" title="0">{
                        // "any of ($cmd*)"
                        for stringID := range matches </span><span class="cov0" title="0">{
                                if strings.HasPrefix(stringID, prefix) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                        <span class="cov0" title="0">return false</span>
                }
                
                // Count matches
                <span class="cov0" title="0">count := 0
                for stringID := range matches </span><span class="cov0" title="0">{
                        if strings.HasPrefix(stringID, prefix) </span><span class="cov0" title="0">{
                                count++
                        }</span>
                }
                
                // Check if we have a numeric requirement
                <span class="cov0" title="0">if strings.Contains(condition, "2 of") </span><span class="cov0" title="0">{
                        return count &gt;= 2
                }</span>
                
                <span class="cov0" title="0">return count &gt; 0</span>
        }
        
        // Direct string reference
        <span class="cov0" title="0">stringID := strings.TrimSpace(condition)
        _, found := matches[stringID]
        return found</span>
}

func (ye *YARAEngine) parseHexString(hexStr string) ([]byte, error) <span class="cov0" title="0">{
        // Remove brackets and spaces
        hexStr = strings.Trim(hexStr, "{}")
        hexStr = strings.ReplaceAll(hexStr, " ", "")
        hexStr = strings.ReplaceAll(hexStr, "0x", "")
        hexStr = strings.ReplaceAll(hexStr, ",", "")
        
        return hex.DecodeString(hexStr)
}</span>

func (ye *YARAEngine) flattenMatches(stringMatches map[string][]StringMatch) []StringMatch <span class="cov0" title="0">{
        var flattened []StringMatch
        for _, matches := range stringMatches </span><span class="cov0" title="0">{
                flattened = append(flattened, matches...)
        }</span>
        <span class="cov0" title="0">return flattened</span>
}

func isWordChar(c byte) bool <span class="cov0" title="0">{
        return (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') || c == '_'
}</span>

// Rule management

func (ye *YARAEngine) AddRule(rule YARARule) <span class="cov0" title="0">{
        ye.rules = append(ye.rules, rule)
}</span>

func (ye *YARAEngine) LoadRulesFromString(rulesStr string) error <span class="cov0" title="0">{
        // Parse YARA rules from string (simplified)
        // In a real implementation, this would use a proper YARA parser
        return fmt.Errorf("YARA rule parsing not implemented")
}</span>

// Getters

func (ye *YARAEngine) GetMatches() []YARAMatch <span class="cov0" title="0">{
        return ye.matches
}</span>

func (ye *YARAEngine) GetMatchesByRule(ruleID string) []YARAMatch <span class="cov0" title="0">{
        var ruleMatches []YARAMatch
        for _, match := range ye.matches </span><span class="cov0" title="0">{
                if match.RuleID == ruleID </span><span class="cov0" title="0">{
                        ruleMatches = append(ruleMatches, match)
                }</span>
        }
        <span class="cov0" title="0">return ruleMatches</span>
}

func (ye *YARAEngine) GetMatchesByTag(tag string) []YARAMatch <span class="cov0" title="0">{
        var tagMatches []YARAMatch
        for _, match := range ye.matches </span><span class="cov0" title="0">{
                for _, t := range match.Tags </span><span class="cov0" title="0">{
                        if t == tag </span><span class="cov0" title="0">{
                                tagMatches = append(tagMatches, match)
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">return tagMatches</span>
}

func (ye *YARAEngine) GetMatchesByThreatLevel(level string) []YARAMatch <span class="cov0" title="0">{
        var threatMatches []YARAMatch
        for _, match := range ye.matches </span><span class="cov0" title="0">{
                if match.ThreatLevel == level </span><span class="cov0" title="0">{
                        threatMatches = append(threatMatches, match)
                }</span>
        }
        <span class="cov0" title="0">return threatMatches</span>
}

func (ye *YARAEngine) GetStats() interface{} <span class="cov0" title="0">{
        return ye.stats
}</span>

func (ye *YARAEngine) ClearAlerts() <span class="cov0" title="0">{
        ye.mu.Lock()
        defer ye.mu.Unlock()
        ye.matches = make([]YARAMatch, 0)
}</span>

func (ye *YARAEngine) GetRules() []YARARule <span class="cov0" title="0">{
        return ye.rules
}</span>

// Cleanup

func (ye *YARAEngine) ClearMatches() <span class="cov0" title="0">{
        ye.matches = make([]YARAMatch, 0)
}</span>

func (ye *YARAEngine) GetRecentMatches(duration time.Duration) []YARAMatch <span class="cov0" title="0">{
        cutoff := time.Now().Add(-duration)
        var recent []YARAMatch
        
        for _, match := range ye.matches </span><span class="cov0" title="0">{
                if match.Timestamp.After(cutoff) </span><span class="cov0" title="0">{
                        recent = append(recent, match)
                }</span>
        }
        
        <span class="cov0" title="0">return recent</span>
}</pre>
		
		<pre class="file" id="file15" style="display: none">package security

import (
        "fmt"
        "strings"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
)

// ZeekEngine implements Zeek (formerly Bro) network analysis
type ZeekEngine struct {
        scripts      []ZeekScript
        events       []ZeekEvent
        connections  map[string]*ZeekConnection
        files        map[string]*ZeekFile
        notices      []ZeekNotice
        stats        ZeekStats
        eventHandler *ZeekEventHandler
}

type ZeekScript struct {
        ID          string
        Name        string
        Description string
        Events      []string // Events this script handles
        Code        string   // Simplified script representation
        Enabled     bool
}

type ZeekEvent struct {
        Timestamp   time.Time              `json:"ts"`
        UID         string                 `json:"uid"`
        Type        string                 `json:"event_type"`
        Connection  *ZeekConnection        `json:"conn,omitempty"`
        Details     map[string]interface{} `json:"details"`
}

type ZeekConnection struct {
        TS          time.Time `json:"ts"`
        UID         string    `json:"uid"`
        OrigH       string    `json:"id.orig_h"`
        OrigP       int       `json:"id.orig_p"`
        RespH       string    `json:"id.resp_h"`
        RespP       int       `json:"id.resp_p"`
        Proto       string    `json:"proto"`
        Service     string    `json:"service,omitempty"`
        Duration    float64   `json:"duration,omitempty"`
        OrigBytes   int64     `json:"orig_bytes"`
        RespBytes   int64     `json:"resp_bytes"`
        ConnState   string    `json:"conn_state"`
        LocalOrig   bool      `json:"local_orig"`
        LocalResp   bool      `json:"local_resp"`
        MissedBytes int64     `json:"missed_bytes"`
        History     string    `json:"history"`
        OrigPkts    int       `json:"orig_pkts"`
        RespPkts    int       `json:"resp_pkts"`
        OrigIPBytes int64     `json:"orig_ip_bytes"`
        RespIPBytes int64     `json:"resp_ip_bytes"`
        TunnelParents []string `json:"tunnel_parents,omitempty"`
}

type ZeekFile struct {
        TS            time.Time `json:"ts"`
        FUID          string    `json:"fuid"`
        TxHosts       []string  `json:"tx_hosts"`
        RxHosts       []string  `json:"rx_hosts"`
        ConnUIDs      []string  `json:"conn_uids"`
        Source        string    `json:"source"`
        Depth         int       `json:"depth"`
        Analyzers     []string  `json:"analyzers"`
        MimeType      string    `json:"mime_type,omitempty"`
        Filename      string    `json:"filename,omitempty"`
        Duration      float64   `json:"duration"`
        LocalOrig     bool      `json:"local_orig"`
        IsOrig        bool      `json:"is_orig"`
        SeenBytes     int64     `json:"seen_bytes"`
        TotalBytes    int64     `json:"total_bytes,omitempty"`
        MissingBytes  int64     `json:"missing_bytes"`
        OverflowBytes int64     `json:"overflow_bytes"`
        Timedout      bool      `json:"timedout"`
        MD5           string    `json:"md5,omitempty"`
        SHA1          string    `json:"sha1,omitempty"`
        SHA256        string    `json:"sha256,omitempty"`
        Extracted     string    `json:"extracted,omitempty"`
}

type ZeekNotice struct {
        TS             time.Time              `json:"ts"`
        UID            string                 `json:"uid,omitempty"`
        ID             *ZeekConnID            `json:"id,omitempty"`
        FUID           string                 `json:"fuid,omitempty"`
        MimeType       string                 `json:"mime_type,omitempty"`
        Note           string                 `json:"note"`
        Msg            string                 `json:"msg"`
        Sub            string                 `json:"sub,omitempty"`
        Src            string                 `json:"src,omitempty"`
        Dst            string                 `json:"dst,omitempty"`
        P              int                    `json:"p,omitempty"`
        Actions        []string               `json:"actions"`
        EmailTo        []string               `json:"email_to,omitempty"`
        SuppressFor    float64                `json:"suppress_for,omitempty"`
        Dropped        bool                   `json:"dropped"`
        RemoteLocation map[string]interface{} `json:"remote_location,omitempty"`
}

type ZeekConnID struct {
        OrigH string `json:"orig_h"`
        OrigP int    `json:"orig_p"`
        RespH string `json:"resp_h"`
        RespP int    `json:"resp_p"`
}

type ZeekStats struct {
        TotalPackets     uint64
        TotalConnections uint64
        TotalFiles       uint64
        TotalNotices     uint64
        TotalEvents      uint64
        EventsByType     map[string]uint64
        ServiceStats     map[string]uint64
        ProtocolStats    map[string]uint64
}

type ZeekEventHandler struct {
        handlers map[string]func(*ZeekEngine, gopacket.Packet, *ZeekConnection)
}

func NewZeekEngine() *ZeekEngine <span class="cov8" title="1">{
        engine := &amp;ZeekEngine{
                scripts:     make([]ZeekScript, 0),
                events:      make([]ZeekEvent, 0),
                connections: make(map[string]*ZeekConnection),
                files:       make(map[string]*ZeekFile),
                notices:     make([]ZeekNotice, 0),
                stats: ZeekStats{
                        EventsByType:  make(map[string]uint64),
                        ServiceStats:  make(map[string]uint64),
                        ProtocolStats: make(map[string]uint64),
                },
                eventHandler: &amp;ZeekEventHandler{
                        handlers: make(map[string]func(*ZeekEngine, gopacket.Packet, *ZeekConnection)),
                },
        }
        
        engine.loadDefaultScripts()
        engine.registerEventHandlers()
        
        return engine
}</span>

func (ze *ZeekEngine) loadDefaultScripts() <span class="cov8" title="1">{
        // Load default Zeek-style detection scripts
        defaultScripts := []ZeekScript{
                {
                        ID:          "scan_detection",
                        Name:        "Port Scan Detection",
                        Description: "Detects various types of port scanning",
                        Events:      []string{"connection_established", "connection_rejected"},
                        Code: `
                                # Detect port scans
                                if (conn$resp_p &lt; 1024 &amp;&amp; conn$state == "REJ") {
                                        local scanner = conn$id$orig_h;
                                        if (++scan_attempts[scanner] &gt; 20) {
                                                NOTICE([$note=Port_Scan,
                                                        $conn=conn,
                                                        $msg=fmt("%s is scanning ports", scanner)]);
                                        }
                                }
                        `,
                        Enabled: true,
                },
                {
                        ID:          "ssh_bruteforce",
                        Name:        "SSH Brute Force Detection",
                        Description: "Detects SSH brute force attacks",
                        Events:      []string{"ssh_auth_failed", "ssh_auth_successful"},
                        Code: `
                                # Track failed SSH attempts
                                if (event == "ssh_auth_failed") {
                                        local attacker = conn$id$orig_h;
                                        if (++ssh_failures[attacker] &gt; 5) {
                                                NOTICE([$note=SSH_Bruteforce,
                                                        $conn=conn,
                                                        $msg=fmt("SSH brute force from %s", attacker)]);
                                        }
                                }
                        `,
                        Enabled: true,
                },
                {
                        ID:          "file_extraction",
                        Name:        "File Extraction and Analysis",
                        Description: "Extracts and analyzes transferred files",
                        Events:      []string{"file_new", "file_over_new_connection", "file_hash"},
                        Code: `
                                # Extract executable files
                                if (f$mime_type in executable_mime_types) {
                                        Files::add_analyzer(f, Files::ANALYZER_EXTRACT);
                                        Files::add_analyzer(f, Files::ANALYZER_MD5);
                                        Files::add_analyzer(f, Files::ANALYZER_SHA256);
                                }
                        `,
                        Enabled: true,
                },
                {
                        ID:          "dns_tunneling",
                        Name:        "DNS Tunneling Detection",
                        Description: "Detects potential DNS tunneling",
                        Events:      []string{"dns_request", "dns_response"},
                        Code: `
                                # Detect suspicious DNS queries
                                if (|dns$query| &gt; 50 || dns$query_type == "TXT") {
                                        if (++dns_suspicious[conn$id$orig_h] &gt; 10) {
                                                NOTICE([$note=DNS_Tunneling,
                                                        $msg="Potential DNS tunneling detected"]);
                                        }
                                }
                        `,
                        Enabled: true,
                },
                {
                        ID:          "http_malware",
                        Name:        "HTTP Malware Detection",
                        Description: "Detects malware behavior over HTTP",
                        Events:      []string{"http_request", "http_header", "http_entity_data"},
                        Code: `
                                # Check for suspicious User-Agents and URLs
                                if (http$user_agent in suspicious_agents ||
                                    /malware|exploit|shell/ in http$uri) {
                                        NOTICE([$note=HTTP_Malware,
                                                $msg="Suspicious HTTP activity detected"]);
                                }
                        `,
                        Enabled: true,
                },
                {
                        ID:          "ssl_anomaly",
                        Name:        "SSL/TLS Anomaly Detection",
                        Description: "Detects SSL/TLS anomalies and weak configurations",
                        Events:      []string{"ssl_established", "ssl_alert", "x509_certificate"},
                        Code: `
                                # Check for weak SSL/TLS configurations
                                if (ssl$version &lt; 0x0303) { # TLS 1.2
                                        NOTICE([$note=SSL_Weak_Version,
                                                $msg="Weak SSL/TLS version detected"]);
                                }
                        `,
                        Enabled: true,
                },
                {
                        ID:          "intel_matching",
                        Name:        "Threat Intelligence Matching",
                        Description: "Matches network traffic against threat intel",
                        Events:      []string{"connection_established", "dns_request", "http_request"},
                        Code: `
                                # Check against threat intelligence
                                if (conn$id$resp_h in malicious_ips ||
                                    dns$query in malicious_domains) {
                                        NOTICE([$note=Intel_Hit,
                                                $msg="Traffic to known malicious host"]);
                                }
                        `,
                        Enabled: true,
                },
        }
        
        ze.scripts = defaultScripts
}</span>

func (ze *ZeekEngine) registerEventHandlers() <span class="cov8" title="1">{
        // Register event handlers for different packet types
        ze.eventHandler.handlers["new_connection"] = ze.handleNewConnection
        ze.eventHandler.handlers["tcp_packet"] = ze.handleTCPPacket
        ze.eventHandler.handlers["udp_packet"] = ze.handleUDPPacket
        ze.eventHandler.handlers["dns_packet"] = ze.handleDNSPacket
        ze.eventHandler.handlers["http_packet"] = ze.handleHTTPPacket
}</span>

func (ze *ZeekEngine) ProcessPacket(packet gopacket.Packet) []ZeekEvent <span class="cov0" title="0">{
        ze.stats.TotalPackets++
        
        // Get or create connection
        conn := ze.trackConnection(packet)
        if conn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">var events []ZeekEvent
        
        // Process packet based on type
        if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                if handler, ok := ze.eventHandler.handlers["tcp_packet"]; ok </span><span class="cov0" title="0">{
                        handler(ze, packet, conn)
                }</span>
        } else<span class="cov0" title="0"> if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil </span><span class="cov0" title="0">{
                if handler, ok := ze.eventHandler.handlers["udp_packet"]; ok </span><span class="cov0" title="0">{
                        handler(ze, packet, conn)
                }</span>
        }
        
        // Process application layer
        <span class="cov0" title="0">if dnsLayer := packet.Layer(layers.LayerTypeDNS); dnsLayer != nil </span><span class="cov0" title="0">{
                if handler, ok := ze.eventHandler.handlers["dns_packet"]; ok </span><span class="cov0" title="0">{
                        handler(ze, packet, conn)
                }</span>
        }
        
        // Check for security events
        <span class="cov0" title="0">ze.runSecurityAnalysis(conn, packet)
        
        // Get recent events
        for i := len(ze.events) - 5; i &lt; len(ze.events); i++ </span><span class="cov0" title="0">{
                if i &gt;= 0 </span><span class="cov0" title="0">{
                        events = append(events, ze.events[i])
                }</span>
        }
        
        <span class="cov0" title="0">return events</span>
}

func (ze *ZeekEngine) trackConnection(packet gopacket.Packet) *ZeekConnection <span class="cov0" title="0">{
        connID := ze.getConnectionID(packet)
        if connID == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">conn, exists := ze.connections[connID]
        if !exists </span><span class="cov0" title="0">{
                conn = ze.createNewConnection(packet)
                if conn != nil </span><span class="cov0" title="0">{
                        ze.connections[connID] = conn
                        ze.stats.TotalConnections++
                        
                        // Fire new_connection event
                        ze.fireEvent("new_connection", conn, nil)
                }</span>
        }
        
        <span class="cov0" title="0">if conn != nil </span><span class="cov0" title="0">{
                // Update connection stats
                ze.updateConnectionStats(conn, packet)
        }</span>
        
        <span class="cov0" title="0">return conn</span>
}

func (ze *ZeekEngine) getConnectionID(packet gopacket.Packet) string <span class="cov0" title="0">{
        netLayer := packet.NetworkLayer()
        if netLayer == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">src := netLayer.NetworkFlow().Src().String()
        dst := netLayer.NetworkFlow().Dst().String()
        
        var srcPort, dstPort int
        // var proto string
        
        if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                tcp := tcpLayer.(*layers.TCP)
                srcPort = int(tcp.SrcPort)
                dstPort = int(tcp.DstPort)
                // proto = "tcp"
        }</span> else<span class="cov0" title="0"> if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil </span><span class="cov0" title="0">{
                udp := udpLayer.(*layers.UDP)
                srcPort = int(udp.SrcPort)
                dstPort = int(udp.DstPort)
                // proto = "udp"
        }</span> else <span class="cov0" title="0">{
                // proto = "other"
        }</span>
        
        // Create Zeek-style UID
        <span class="cov0" title="0">return fmt.Sprintf("C%s%d%s%d", 
                strings.ReplaceAll(src, ".", ""),
                srcPort,
                strings.ReplaceAll(dst, ".", ""),
                dstPort)</span>
}

func (ze *ZeekEngine) createNewConnection(packet gopacket.Packet) *ZeekConnection <span class="cov0" title="0">{
        netLayer := packet.NetworkLayer()
        if netLayer == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">conn := &amp;ZeekConnection{
                TS:    time.Now(),
                UID:   ze.getConnectionID(packet),
                OrigH: netLayer.NetworkFlow().Src().String(),
                RespH: netLayer.NetworkFlow().Dst().String(),
                LocalOrig: ze.isLocalIP(netLayer.NetworkFlow().Src().String()),
                LocalResp: ze.isLocalIP(netLayer.NetworkFlow().Dst().String()),
        }
        
        if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                tcp := tcpLayer.(*layers.TCP)
                conn.OrigP = int(tcp.SrcPort)
                conn.RespP = int(tcp.DstPort)
                conn.Proto = "tcp"
                conn.Service = ze.identifyService(int(tcp.DstPort), "tcp")
                
                // Set initial connection state
                if tcp.SYN &amp;&amp; !tcp.ACK </span><span class="cov0" title="0">{
                        conn.ConnState = "S0"
                }</span> else<span class="cov0" title="0"> if tcp.SYN &amp;&amp; tcp.ACK </span><span class="cov0" title="0">{
                        conn.ConnState = "S1"
                }</span>
        } else<span class="cov0" title="0"> if udpLayer := packet.Layer(layers.LayerTypeUDP); udpLayer != nil </span><span class="cov0" title="0">{
                udp := udpLayer.(*layers.UDP)
                conn.OrigP = int(udp.SrcPort)
                conn.RespP = int(udp.DstPort)
                conn.Proto = "udp"
                conn.Service = ze.identifyService(int(udp.DstPort), "udp")
                conn.ConnState = "SF" // Simplified for UDP
        }</span>
        
        <span class="cov0" title="0">ze.stats.ProtocolStats[conn.Proto]++
        if conn.Service != "" </span><span class="cov0" title="0">{
                ze.stats.ServiceStats[conn.Service]++
        }</span>
        
        <span class="cov0" title="0">return conn</span>
}

func (ze *ZeekEngine) updateConnectionStats(conn *ZeekConnection, packet gopacket.Packet) <span class="cov0" title="0">{
        // Update packet counts
        netLayer := packet.NetworkLayer()
        if netLayer.NetworkFlow().Src().String() == conn.OrigH </span><span class="cov0" title="0">{
                conn.OrigPkts++
                conn.OrigIPBytes += int64(len(packet.Data()))
                if payload := ze.getPayload(packet); payload != nil </span><span class="cov0" title="0">{
                        conn.OrigBytes += int64(len(payload))
                }</span>
        } else<span class="cov0" title="0"> {
                conn.RespPkts++
                conn.RespIPBytes += int64(len(packet.Data()))
                if payload := ze.getPayload(packet); payload != nil </span><span class="cov0" title="0">{
                        conn.RespBytes += int64(len(payload))
                }</span>
        }
        
        // Update connection state for TCP
        <span class="cov0" title="0">if tcpLayer := packet.Layer(layers.LayerTypeTCP); tcpLayer != nil </span><span class="cov0" title="0">{
                tcp := tcpLayer.(*layers.TCP)
                ze.updateTCPState(conn, tcp)
                
                // Update history string (simplified)
                if tcp.SYN </span><span class="cov0" title="0">{
                        conn.History += "S"
                }</span>
                <span class="cov0" title="0">if tcp.ACK </span><span class="cov0" title="0">{
                        conn.History += "A"
                }</span>
                <span class="cov0" title="0">if tcp.FIN </span><span class="cov0" title="0">{
                        conn.History += "F"
                }</span>
                <span class="cov0" title="0">if tcp.RST </span><span class="cov0" title="0">{
                        conn.History += "R"
                }</span>
        }
        
        // Update duration
        <span class="cov0" title="0">conn.Duration = time.Since(conn.TS).Seconds()</span>
}

func (ze *ZeekEngine) updateTCPState(conn *ZeekConnection, tcp *layers.TCP) <span class="cov0" title="0">{
        // Simplified TCP state tracking
        switch conn.ConnState </span>{
        case "S0":<span class="cov0" title="0">
                if tcp.SYN &amp;&amp; tcp.ACK </span><span class="cov0" title="0">{
                        conn.ConnState = "S1"
                }</span>
        case "S1":<span class="cov0" title="0">
                if tcp.ACK &amp;&amp; !tcp.SYN </span><span class="cov0" title="0">{
                        conn.ConnState = "SF"
                }</span>
        case "SF":<span class="cov0" title="0">
                if tcp.FIN </span><span class="cov0" title="0">{
                        conn.ConnState = "S2"
                }</span> else<span class="cov0" title="0"> if tcp.RST </span><span class="cov0" title="0">{
                        conn.ConnState = "REJ"
                }</span>
        }
}

func (ze *ZeekEngine) identifyService(port int, proto string) string <span class="cov0" title="0">{
        // Common service identification
        if proto == "tcp" </span><span class="cov0" title="0">{
                switch port </span>{
                case 21:<span class="cov0" title="0">
                        return "ftp"</span>
                case 22:<span class="cov0" title="0">
                        return "ssh"</span>
                case 23:<span class="cov0" title="0">
                        return "telnet"</span>
                case 25:<span class="cov0" title="0">
                        return "smtp"</span>
                case 80:<span class="cov0" title="0">
                        return "http"</span>
                case 110:<span class="cov0" title="0">
                        return "pop3"</span>
                case 143:<span class="cov0" title="0">
                        return "imap"</span>
                case 443:<span class="cov0" title="0">
                        return "ssl"</span>
                case 445:<span class="cov0" title="0">
                        return "smb"</span>
                case 3389:<span class="cov0" title="0">
                        return "rdp"</span>
                }
        } else<span class="cov0" title="0"> if proto == "udp" </span><span class="cov0" title="0">{
                switch port </span>{
                case 53:<span class="cov0" title="0">
                        return "dns"</span>
                case 67, 68:<span class="cov0" title="0">
                        return "dhcp"</span>
                case 69:<span class="cov0" title="0">
                        return "tftp"</span>
                case 123:<span class="cov0" title="0">
                        return "ntp"</span>
                case 161:<span class="cov0" title="0">
                        return "snmp"</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

func (ze *ZeekEngine) isLocalIP(ip string) bool <span class="cov0" title="0">{
        // Check if IP is in local network ranges
        return strings.HasPrefix(ip, "192.168.") ||
               strings.HasPrefix(ip, "10.") ||
               strings.HasPrefix(ip, "172.16.") ||
               strings.HasPrefix(ip, "172.17.") ||
               strings.HasPrefix(ip, "172.18.") ||
               strings.HasPrefix(ip, "172.19.") ||
               strings.HasPrefix(ip, "172.20.") ||
               strings.HasPrefix(ip, "172.21.") ||
               strings.HasPrefix(ip, "172.22.") ||
               strings.HasPrefix(ip, "172.23.") ||
               strings.HasPrefix(ip, "172.24.") ||
               strings.HasPrefix(ip, "172.25.") ||
               strings.HasPrefix(ip, "172.26.") ||
               strings.HasPrefix(ip, "172.27.") ||
               strings.HasPrefix(ip, "172.28.") ||
               strings.HasPrefix(ip, "172.29.") ||
               strings.HasPrefix(ip, "172.30.") ||
               strings.HasPrefix(ip, "172.31.")
}</span>

func (ze *ZeekEngine) getPayload(packet gopacket.Packet) []byte <span class="cov0" title="0">{
        if app := packet.ApplicationLayer(); app != nil </span><span class="cov0" title="0">{
                return app.Payload()
        }</span>
        <span class="cov0" title="0">if transport := packet.TransportLayer(); transport != nil </span><span class="cov0" title="0">{
                return transport.LayerPayload()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ze *ZeekEngine) fireEvent(eventType string, conn *ZeekConnection, details map[string]interface{}) <span class="cov0" title="0">{
        event := ZeekEvent{
                Timestamp:  time.Now(),
                UID:        conn.UID,
                Type:       eventType,
                Connection: conn,
                Details:    details,
        }
        
        ze.events = append(ze.events, event)
        ze.stats.TotalEvents++
        ze.stats.EventsByType[eventType]++
        
        // Keep only recent events
        if len(ze.events) &gt; 10000 </span><span class="cov0" title="0">{
                ze.events = ze.events[len(ze.events)-10000:]
        }</span>
}

// Event handlers

func (ze *ZeekEngine) handleNewConnection(engine *ZeekEngine, packet gopacket.Packet, conn *ZeekConnection) <span class="cov0" title="0">{
        // Check against scripts for new connection events
        for _, script := range engine.scripts </span><span class="cov0" title="0">{
                if !script.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">for _, event := range script.Events </span><span class="cov0" title="0">{
                        if event == "connection_established" </span><span class="cov0" title="0">{
                                // Run script logic (simplified)
                                engine.executeScript(script, conn, packet)
                        }</span>
                }
        }
}

func (ze *ZeekEngine) handleTCPPacket(engine *ZeekEngine, packet gopacket.Packet, conn *ZeekConnection) <span class="cov0" title="0">{
        tcpLayer := packet.Layer(layers.LayerTypeTCP)
        if tcpLayer == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">tcp := tcpLayer.(*layers.TCP)
        
        // Detect port scanning
        if tcp.SYN &amp;&amp; !tcp.ACK &amp;&amp; conn.ConnState == "S0" </span><span class="cov0" title="0">{
                engine.checkPortScan(conn)
        }</span>
        
        // Detect service-specific events
        <span class="cov0" title="0">switch conn.Service </span>{
        case "ssh":<span class="cov0" title="0">
                engine.analyzeSSH(packet, conn)</span>
        case "http":<span class="cov0" title="0">
                engine.analyzeHTTP(packet, conn)</span>
        case "ssl":<span class="cov0" title="0">
                engine.analyzeSSL(packet, conn)</span>
        }
}

func (ze *ZeekEngine) handleUDPPacket(engine *ZeekEngine, packet gopacket.Packet, conn *ZeekConnection) <span class="cov0" title="0">{
        // Handle UDP-specific protocols
        switch conn.Service </span>{
        case "dns":<span class="cov0" title="0">
                engine.analyzeDNS(packet, conn)</span>
        case "dhcp":<span class="cov0" title="0">
                engine.analyzeDHCP(packet, conn)</span>
        }
}

func (ze *ZeekEngine) handleDNSPacket(engine *ZeekEngine, packet gopacket.Packet, conn *ZeekConnection) <span class="cov0" title="0">{
        dnsLayer := packet.Layer(layers.LayerTypeDNS)
        if dnsLayer == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">dns := dnsLayer.(*layers.DNS)
        
        // Process DNS queries
        for _, q := range dns.Questions </span><span class="cov0" title="0">{
                details := map[string]interface{}{
                        "query":      string(q.Name),
                        "query_type": q.Type.String(),
                        "query_class": q.Class.String(),
                }
                
                engine.fireEvent("dns_request", conn, details)
                
                // Check for DNS tunneling
                if len(q.Name) &gt; 50 || q.Type == layers.DNSTypeTXT </span><span class="cov0" title="0">{
                        engine.createNotice("DNS_Tunneling", "Suspicious DNS query detected", conn)
                }</span>
        }
}

func (ze *ZeekEngine) handleHTTPPacket(engine *ZeekEngine, packet gopacket.Packet, conn *ZeekConnection) <span class="cov0" title="0">{
        payload := engine.getPayload(packet)
        if payload == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">payloadStr := string(payload)
        
        // Simple HTTP request detection
        if strings.HasPrefix(payloadStr, "GET ") || 
           strings.HasPrefix(payloadStr, "POST ") ||
           strings.HasPrefix(payloadStr, "PUT ") </span><span class="cov0" title="0">{
                
                lines := strings.Split(payloadStr, "\r\n")
                if len(lines) &gt; 0 </span><span class="cov0" title="0">{
                        requestLine := lines[0]
                        parts := strings.Fields(requestLine)
                        
                        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                                details := map[string]interface{}{
                                        "method":  parts[0],
                                        "uri":     parts[1],
                                        "version": parts[2],
                                }
                                
                                // Extract headers
                                headers := make(map[string]string)
                                for i := 1; i &lt; len(lines); i++ </span><span class="cov0" title="0">{
                                        if lines[i] == "" </span><span class="cov0" title="0">{
                                                break</span>
                                        }
                                        <span class="cov0" title="0">headerParts := strings.SplitN(lines[i], ":", 2)
                                        if len(headerParts) == 2 </span><span class="cov0" title="0">{
                                                headers[strings.TrimSpace(headerParts[0])] = strings.TrimSpace(headerParts[1])
                                        }</span>
                                }
                                <span class="cov0" title="0">details["headers"] = headers
                                
                                engine.fireEvent("http_request", conn, details)
                                
                                // Check for suspicious patterns
                                if userAgent, ok := headers["User-Agent"]; ok </span><span class="cov0" title="0">{
                                        if strings.Contains(strings.ToLower(userAgent), "bot") ||
                                           strings.Contains(strings.ToLower(userAgent), "scanner") </span><span class="cov0" title="0">{
                                                engine.createNotice("HTTP_Suspicious_UA", "Suspicious User-Agent detected", conn)
                                        }</span>
                                }
                        }
                }
        }
}

// Analysis functions

func (ze *ZeekEngine) checkPortScan(conn *ZeekConnection) <span class="cov0" title="0">{
        // Simple port scan detection
        scanner := conn.OrigH
        
        // Count connections from this source
        scanCount := 0
        for _, c := range ze.connections </span><span class="cov0" title="0">{
                if c.OrigH == scanner &amp;&amp; c.ConnState == "S0" </span><span class="cov0" title="0">{
                        scanCount++
                }</span>
        }
        
        <span class="cov0" title="0">if scanCount &gt; 20 </span><span class="cov0" title="0">{
                ze.createNotice("Port_Scan", 
                        fmt.Sprintf("%s is scanning ports (count: %d)", scanner, scanCount), 
                        conn)
        }</span>
}

func (ze *ZeekEngine) analyzeSSH(packet gopacket.Packet, conn *ZeekConnection) <span class="cov0" title="0">{
        payload := ze.getPayload(packet)
        if payload == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">payloadStr := string(payload)
        
        // Check for SSH version
        if strings.HasPrefix(payloadStr, "SSH-") </span><span class="cov0" title="0">{
                details := map[string]interface{}{
                        "version": strings.TrimSpace(payloadStr),
                }
                ze.fireEvent("ssh_server_version", conn, details)
        }</span>
        
        // Simple brute force detection (would need more sophisticated analysis)
        <span class="cov0" title="0">if conn.OrigPkts &gt; 10 &amp;&amp; conn.Duration &lt; 5.0 </span><span class="cov0" title="0">{
                ze.createNotice("SSH_Bruteforce", 
                        fmt.Sprintf("Potential SSH brute force from %s", conn.OrigH), 
                        conn)
        }</span>
}

func (ze *ZeekEngine) analyzeDNS(packet gopacket.Packet, conn *ZeekConnection) {<span class="cov0" title="0">
        // Handled in handleDNSPacket
}</span>

func (ze *ZeekEngine) analyzeDHCP(packet gopacket.Packet, conn *ZeekConnection) {<span class="cov0" title="0">
        // DHCP analysis would go here
}</span>

func (ze *ZeekEngine) analyzeHTTP(packet gopacket.Packet, conn *ZeekConnection) {<span class="cov0" title="0">
        // Handled in handleHTTPPacket
}</span>

func (ze *ZeekEngine) analyzeSSL(packet gopacket.Packet, conn *ZeekConnection) <span class="cov0" title="0">{
        payload := ze.getPayload(packet)
        if payload == nil || len(payload) &lt; 6 </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Check for TLS handshake
        <span class="cov0" title="0">if payload[0] == 0x16 </span><span class="cov0" title="0">{ // Handshake
                version := fmt.Sprintf("%d.%d", payload[1], payload[2])
                
                details := map[string]interface{}{
                        "version": version,
                }
                
                ze.fireEvent("ssl_established", conn, details)
                
                // Check for weak SSL/TLS versions
                if payload[1] == 0x03 &amp;&amp; payload[2] &lt; 0x03 </span><span class="cov0" title="0">{ // Less than TLS 1.2
                        ze.createNotice("SSL_Weak_Version",
                                fmt.Sprintf("Weak SSL/TLS version %s detected", version),
                                conn)
                }</span>
        }
}

func (ze *ZeekEngine) runSecurityAnalysis(conn *ZeekConnection, packet gopacket.Packet) <span class="cov0" title="0">{
        // Run enabled scripts
        for _, script := range ze.scripts </span><span class="cov0" title="0">{
                if !script.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">ze.executeScript(script, conn, packet)</span>
        }
}

func (ze *ZeekEngine) executeScript(script ZeekScript, conn *ZeekConnection, packet gopacket.Packet) <span class="cov0" title="0">{
        // Simplified script execution
        // In a real implementation, this would use a proper scripting engine
        
        switch script.ID </span>{
        case "scan_detection":<span class="cov0" title="0">
                if conn.ConnState == "REJ" &amp;&amp; conn.RespP &lt; 1024 </span><span class="cov0" title="0">{
                        ze.checkPortScan(conn)
                }</span>
                
        case "ssh_bruteforce":<span class="cov0" title="0">
                if conn.Service == "ssh" &amp;&amp; conn.OrigPkts &gt; 10 &amp;&amp; conn.Duration &lt; 5.0 </span><span class="cov0" title="0">{
                        ze.createNotice("SSH_Bruteforce",
                                fmt.Sprintf("SSH brute force from %s", conn.OrigH),
                                conn)
                }</span>
                
        case "dns_tunneling":<span class="cov0" title="0"></span>
                // Handled in DNS packet handler
                
        case "intel_matching":<span class="cov0" title="0">
                // Check against threat intelligence (simplified)
                maliciousIPs := []string{"10.0.0.1", "192.168.100.100"} // Example
                for _, ip := range maliciousIPs </span><span class="cov0" title="0">{
                        if conn.OrigH == ip || conn.RespH == ip </span><span class="cov0" title="0">{
                                ze.createNotice("Intel_Hit",
                                        fmt.Sprintf("Traffic to/from known malicious IP: %s", ip),
                                        conn)
                        }</span>
                }
        }
}

func (ze *ZeekEngine) createNotice(note, msg string, conn *ZeekConnection) <span class="cov0" title="0">{
        notice := ZeekNotice{
                TS:   time.Now(),
                UID:  conn.UID,
                Note: note,
                Msg:  msg,
                ID: &amp;ZeekConnID{
                        OrigH: conn.OrigH,
                        OrigP: conn.OrigP,
                        RespH: conn.RespH,
                        RespP: conn.RespP,
                },
                Actions: []string{"Notice::ACTION_LOG"},
        }
        
        ze.notices = append(ze.notices, notice)
        ze.stats.TotalNotices++
        
        // Also create an event
        ze.fireEvent("notice", conn, map[string]interface{}{
                "note": note,
                "msg":  msg,
        })
}</span>

// File tracking

func (ze *ZeekEngine) trackFile(fuid string, source string, conn *ZeekConnection) *ZeekFile <span class="cov0" title="0">{
        file := &amp;ZeekFile{
                TS:       time.Now(),
                FUID:     fuid,
                Source:   source,
                ConnUIDs: []string{conn.UID},
                TxHosts:  []string{conn.OrigH},
                RxHosts:  []string{conn.RespH},
        }
        
        ze.files[fuid] = file
        ze.stats.TotalFiles++
        
        return file
}</span>

// Getters

func (ze *ZeekEngine) GetConnections() []ZeekConnection <span class="cov0" title="0">{
        conns := make([]ZeekConnection, 0, len(ze.connections))
        for _, conn := range ze.connections </span><span class="cov0" title="0">{
                conns = append(conns, *conn)
        }</span>
        <span class="cov0" title="0">return conns</span>
}

func (ze *ZeekEngine) GetFiles() []ZeekFile <span class="cov0" title="0">{
        files := make([]ZeekFile, 0, len(ze.files))
        for _, file := range ze.files </span><span class="cov0" title="0">{
                files = append(files, *file)
        }</span>
        <span class="cov0" title="0">return files</span>
}

func (ze *ZeekEngine) GetNotices() []ZeekNotice <span class="cov0" title="0">{
        return ze.notices
}</span>

func (ze *ZeekEngine) GetEvents() []ZeekEvent <span class="cov0" title="0">{
        return ze.events
}</span>

func (ze *ZeekEngine) GetStats() interface{} <span class="cov0" title="0">{
        return ze.stats
}</span>

func (ze *ZeekEngine) ClearAlerts() <span class="cov0" title="0">{
        ze.events = make([]ZeekEvent, 0)
        ze.notices = make([]ZeekNotice, 0)
}</span>

func (ze *ZeekEngine) GetScripts() []ZeekScript <span class="cov0" title="0">{
        return ze.scripts
}</span>

// Cleanup

func (ze *ZeekEngine) CleanupOldConnections() <span class="cov0" title="0">{
        cutoff := time.Now().Add(-5 * time.Minute)
        
        for id, conn := range ze.connections </span><span class="cov0" title="0">{
                if conn.TS.Before(cutoff) </span><span class="cov0" title="0">{
                        delete(ze.connections, id)
                }</span>
        }
}

func (ze *ZeekEngine) ClearEvents() <span class="cov0" title="0">{
        ze.events = make([]ZeekEvent, 0)
}</span>

func (ze *ZeekEngine) ClearNotices() <span class="cov0" title="0">{
        ze.notices = make([]ZeekNotice, 0)
}</pre>
		
		<pre class="file" id="file16" style="display: none">package ui

import (
        "github.com/gdamore/tcell/v2"
)

// BorderAnimation defines different animation types
type BorderAnimation int

const (
        AnimationNone BorderAnimation = iota
        AnimationRainbow
        AnimationPulse
        AnimationFire
        AnimationMatrix
        AnimationWave
        AnimationSparkle
)

// AnimationNames maps animation names to types
var AnimationNames = []string{
        "None",
        "Rainbow",
        "Pulse",
        "Fire",
        "Matrix",
        "Wave",
        "Sparkle",
}

// GetAnimatedBorderColor returns the color for animated borders
func GetAnimatedBorderColor(baseColor tcell.Color, animation string, frame int) tcell.Color <span class="cov0" title="0">{
        switch animation </span>{
        case "Rainbow":<span class="cov0" title="0">
                return getRainbowColor(frame)</span>
        case "Pulse":<span class="cov0" title="0">
                return getPulseColor(baseColor, frame)</span>
        case "Fire":<span class="cov0" title="0">
                return getFireColor(frame)</span>
        case "Matrix":<span class="cov0" title="0">
                return getMatrixColor(frame)</span>
        case "Wave":<span class="cov0" title="0">
                return getWaveColor(baseColor, frame)</span>
        case "Sparkle":<span class="cov0" title="0">
                return getSparkleColor(baseColor, frame)</span>
        default:<span class="cov0" title="0">
                return baseColor</span>
        }
}

// getRainbowColor cycles through rainbow colors
func getRainbowColor(frame int) tcell.Color <span class="cov0" title="0">{
        colors := []tcell.Color{
                tcell.NewRGBColor(255, 0, 0),     // Red
                tcell.NewRGBColor(255, 127, 0),   // Orange
                tcell.NewRGBColor(255, 255, 0),   // Yellow
                tcell.NewRGBColor(0, 255, 0),     // Green
                tcell.NewRGBColor(0, 0, 255),     // Blue
                tcell.NewRGBColor(75, 0, 130),    // Indigo
                tcell.NewRGBColor(148, 0, 211),   // Violet
        }
        return colors[frame%len(colors)]
}</span>

// getPulseColor creates a pulsing effect
func getPulseColor(baseColor tcell.Color, frame int) tcell.Color <span class="cov0" title="0">{
        // Create a sine wave effect
        intensity := (frame % 20) 
        if intensity &gt; 10 </span><span class="cov0" title="0">{
                intensity = 20 - intensity
        }</span>
        
        <span class="cov0" title="0">r, g, b := baseColor.RGB()
        factor := float64(intensity) / 10.0
        
        // Brighten the color based on the pulse
        newR := int32(float64(r) * (0.5 + 0.5*factor))
        newG := int32(float64(g) * (0.5 + 0.5*factor))
        newB := int32(float64(b) * (0.5 + 0.5*factor))
        
        // Clamp values
        if newR &gt; 255 </span><span class="cov0" title="0">{ newR = 255 }</span>
        <span class="cov0" title="0">if newG &gt; 255 </span><span class="cov0" title="0">{ newG = 255 }</span>
        <span class="cov0" title="0">if newB &gt; 255 </span><span class="cov0" title="0">{ newB = 255 }</span>
        
        <span class="cov0" title="0">return tcell.NewRGBColor(newR, newG, newB)</span>
}

// getFireColor creates fire-like colors
func getFireColor(frame int) tcell.Color <span class="cov0" title="0">{
        colors := []tcell.Color{
                tcell.NewRGBColor(255, 0, 0),     // Red
                tcell.NewRGBColor(255, 69, 0),    // Orange-red
                tcell.NewRGBColor(255, 140, 0),   // Dark orange
                tcell.NewRGBColor(255, 215, 0),   // Gold
                tcell.NewRGBColor(255, 255, 0),   // Yellow
        }
        // Add some randomness to fire effect
        idx := (frame / 2) % len(colors)
        return colors[idx]
}</span>

// getMatrixColor creates matrix-like green variations
func getMatrixColor(frame int) tcell.Color <span class="cov0" title="0">{
        intensity := 100 + (frame*10)%155
        return tcell.NewRGBColor(0, int32(intensity), 0)
}</span>

// getWaveColor creates a wave effect
func getWaveColor(baseColor tcell.Color, frame int) tcell.Color <span class="cov0" title="0">{
        r, g, b := baseColor.RGB()
        
        // Create wave effect by modifying different channels at different rates
        waveR := int32(float64(r) * (0.8 + 0.2*sin(float64(frame)*0.1)))
        waveG := int32(float64(g) * (0.8 + 0.2*sin(float64(frame)*0.15)))
        waveB := int32(float64(b) * (0.8 + 0.2*sin(float64(frame)*0.2)))
        
        return tcell.NewRGBColor(waveR, waveG, waveB)
}</span>

// getSparkleColor creates random sparkles
func getSparkleColor(baseColor tcell.Color, frame int) tcell.Color <span class="cov0" title="0">{
        // Every few frames, create a bright sparkle
        if frame%7 == 0 </span><span class="cov0" title="0">{
                return tcell.ColorWhite
        }</span>
        <span class="cov0" title="0">return baseColor</span>
}

// sin approximation for wave effects
func sin(x float64) float64 <span class="cov0" title="0">{
        // Simple sine approximation
        x = x - float64(int(x/(2*3.14159)))*(2*3.14159)
        if x &lt; 0 </span><span class="cov0" title="0">{
                x = -x
        }</span>
        <span class="cov0" title="0">if x &gt; 3.14159 </span><span class="cov0" title="0">{
                x = 2*3.14159 - x
        }</span>
        // Taylor series approximation
        <span class="cov0" title="0">return x - (x*x*x)/6 + (x*x*x*x*x)/120</span>
}

// GetAnimatedBorderChar returns animated border characters for certain styles
func GetAnimatedBorderChar(style BorderChars, position string, frame int) rune <span class="cov0" title="0">{
        // For fire animation, cycle through different fire characters
        if style.TopLeft == '🔥' </span><span class="cov0" title="0">{
                fireChars := []rune{'🔥', '🔥', '🔥', '🔥'}
                return fireChars[frame%len(fireChars)]
        }</span>
        
        // For sparkle/star animations
        <span class="cov0" title="0">if style.TopLeft == '✦' </span><span class="cov0" title="0">{
                starChars := []rune{'✦', '✧', '✶', '✷', '✵'}
                return starChars[frame%len(starChars)]
        }</span>
        
        // Default: return the appropriate character for the position
        <span class="cov0" title="0">switch position </span>{
        case "TopLeft":<span class="cov0" title="0">
                return style.TopLeft</span>
        case "TopRight":<span class="cov0" title="0">
                return style.TopRight</span>
        case "BottomLeft":<span class="cov0" title="0">
                return style.BottomLeft</span>
        case "BottomRight":<span class="cov0" title="0">
                return style.BottomRight</span>
        case "Horizontal":<span class="cov0" title="0">
                return style.Horizontal</span>
        case "Vertical":<span class="cov0" title="0">
                return style.Vertical</span>
        case "Cross":<span class="cov0" title="0">
                return style.Cross</span>
        case "HorizontalDown":<span class="cov0" title="0">
                return style.HorizontalDown</span>
        case "HorizontalUp":<span class="cov0" title="0">
                return style.HorizontalUp</span>
        case "VerticalLeft":<span class="cov0" title="0">
                return style.VerticalLeft</span>
        case "VerticalRight":<span class="cov0" title="0">
                return style.VerticalRight</span>
        default:<span class="cov0" title="0">
                return style.Cross</span>
        }
}</pre>
		
		<pre class="file" id="file17" style="display: none">package ui

import "sort"

// BorderStyle represents different border drawing styles
type BorderStyle int

const (
        BorderStyleSingle BorderStyle = iota
        BorderStyleDouble
        BorderStyleRounded
        BorderStyleBold
        BorderStyleDashed
        BorderStyleDotted
        BorderStyleClassic // ASCII style
        BorderStyleMinimal
        BorderStyleBBS     // Retro BBS style
        BorderStyleNone
)

// BorderChars defines the characters used for drawing borders
type BorderChars struct {
        TopLeft     rune
        TopRight    rune
        BottomLeft  rune
        BottomRight rune
        Horizontal  rune
        Vertical    rune
        Cross       rune
        HorizontalDown rune
        HorizontalUp   rune
        VerticalLeft   rune
        VerticalRight  rune
}

// BorderStyles maps style names to their character sets
var BorderStyles = map[string]BorderChars{
        "Single": {
                TopLeft:     '┌',
                TopRight:    '┐',
                BottomLeft:  '└',
                BottomRight: '┘',
                Horizontal:  '─',
                Vertical:    '│',
                Cross:       '┼',
                HorizontalDown: '┬',
                HorizontalUp:   '┴',
                VerticalLeft:   '┤',
                VerticalRight:  '├',
        },
        "Double": {
                TopLeft:     '╔',
                TopRight:    '╗',
                BottomLeft:  '╚',
                BottomRight: '╝',
                Horizontal:  '═',
                Vertical:    '║',
                Cross:       '╬',
                HorizontalDown: '╦',
                HorizontalUp:   '╩',
                VerticalLeft:   '╣',
                VerticalRight:  '╠',
        },
        "Rounded": {
                TopLeft:     '╭',
                TopRight:    '╮',
                BottomLeft:  '╰',
                BottomRight: '╯',
                Horizontal:  '─',
                Vertical:    '│',
                Cross:       '┼',
                HorizontalDown: '┬',
                HorizontalUp:   '┴',
                VerticalLeft:   '┤',
                VerticalRight:  '├',
        },
        "Bold": {
                TopLeft:     '┏',
                TopRight:    '┓',
                BottomLeft:  '┗',
                BottomRight: '┛',
                Horizontal:  '━',
                Vertical:    '┃',
                Cross:       '╋',
                HorizontalDown: '┳',
                HorizontalUp:   '┻',
                VerticalLeft:   '┫',
                VerticalRight:  '┣',
        },
        "Dashed": {
                TopLeft:     '┌',
                TopRight:    '┐',
                BottomLeft:  '└',
                BottomRight: '┘',
                Horizontal:  '╌',
                Vertical:    '╎',
                Cross:       '┼',
                HorizontalDown: '┬',
                HorizontalUp:   '┴',
                VerticalLeft:   '┤',
                VerticalRight:  '├',
        },
        "Dotted": {
                TopLeft:     '⡏',
                TopRight:    '⢹',
                BottomLeft:  '⣇',
                BottomRight: '⣸',
                Horizontal:  '⠉',
                Vertical:    '⡇',
                Cross:       '⡇',
                HorizontalDown: '⠉',
                HorizontalUp:   '⠉',
                VerticalLeft:   '⡇',
                VerticalRight:  '⡇',
        },
        "Classic": {
                TopLeft:     '+',
                TopRight:    '+',
                BottomLeft:  '+',
                BottomRight: '+',
                Horizontal:  '-',
                Vertical:    '|',
                Cross:       '+',
                HorizontalDown: '+',
                HorizontalUp:   '+',
                VerticalLeft:   '+',
                VerticalRight:  '+',
        },
        "Minimal": {
                TopLeft:     ' ',
                TopRight:    ' ',
                BottomLeft:  ' ',
                BottomRight: ' ',
                Horizontal:  ' ',
                Vertical:    ' ',
                Cross:       ' ',
                HorizontalDown: ' ',
                HorizontalUp:   ' ',
                VerticalLeft:   ' ',
                VerticalRight:  ' ',
        },
        "BBS": {
                TopLeft:     '╓',
                TopRight:    '╖',
                BottomLeft:  '╙',
                BottomRight: '╜',
                Horizontal:  '─',
                Vertical:    '║',
                Cross:       '╫',
                HorizontalDown: '╥',
                HorizontalUp:   '╨',
                VerticalLeft:   '╢',
                VerticalRight:  '╟',
        },
        "BlockShade": {
                TopLeft:     '▛',
                TopRight:    '▜',
                BottomLeft:  '▙',
                BottomRight: '▟',
                Horizontal:  '▀',
                Vertical:    '▌',
                Cross:       '█',
                HorizontalDown: '▀',
                HorizontalUp:   '▄',
                VerticalLeft:   '▐',
                VerticalRight:  '▌',
        },
        "DoubleInside": {
                TopLeft:     '╒',
                TopRight:    '╕',
                BottomLeft:  '╘',
                BottomRight: '╛',
                Horizontal:  '═',
                Vertical:    '│',
                Cross:       '╪',
                HorizontalDown: '╤',
                HorizontalUp:   '╧',
                VerticalLeft:   '╡',
                VerticalRight:  '╞',
        },
        "Stars": {
                TopLeft:     '✦',
                TopRight:    '✦',
                BottomLeft:  '✦',
                BottomRight: '✦',
                Horizontal:  '═',
                Vertical:    '║',
                Cross:       '✦',
                HorizontalDown: '✦',
                HorizontalUp:   '✦',
                VerticalLeft:   '✦',
                VerticalRight:  '✦',
        },
        "Hearts": {
                TopLeft:     '♥',
                TopRight:    '♥',
                BottomLeft:  '♥',
                BottomRight: '♥',
                Horizontal:  '─',
                Vertical:    '│',
                Cross:       '♥',
                HorizontalDown: '♥',
                HorizontalUp:   '♥',
                VerticalLeft:   '♥',
                VerticalRight:  '♥',
        },
        "Arrows": {
                TopLeft:     '↖',
                TopRight:    '↗',
                BottomLeft:  '↙',
                BottomRight: '↘',
                Horizontal:  '↔',
                Vertical:    '↕',
                Cross:       '✚',
                HorizontalDown: '↓',
                HorizontalUp:   '↑',
                VerticalLeft:   '←',
                VerticalRight:  '→',
        },
        "Fire": {
                TopLeft:     '🔥',
                TopRight:    '🔥',
                BottomLeft:  '🔥',
                BottomRight: '🔥',
                Horizontal:  '═',
                Vertical:    '║',
                Cross:       '🔥',
                HorizontalDown: '🔥',
                HorizontalUp:   '🔥',
                VerticalLeft:   '🔥',
                VerticalRight:  '🔥',
        },
        "Tech": {
                TopLeft:     '⚡',
                TopRight:    '⚡',
                BottomLeft:  '⚡',
                BottomRight: '⚡',
                Horizontal:  '━',
                Vertical:    '┃',
                Cross:       '⚡',
                HorizontalDown: '⚡',
                HorizontalUp:   '⚡',
                VerticalLeft:   '⚡',
                VerticalRight:  '⚡',
        },
        "Matrix": {
                TopLeft:     '◢',
                TopRight:    '◣',
                BottomLeft:  '◥',
                BottomRight: '◤',
                Horizontal:  '▬',
                Vertical:    '▮',
                Cross:       '◆',
                HorizontalDown: '▼',
                HorizontalUp:   '▲',
                VerticalLeft:   '◀',
                VerticalRight:  '▶',
        },
        "Dots": {
                TopLeft:     '●',
                TopRight:    '●',
                BottomLeft:  '●',
                BottomRight: '●',
                Horizontal:  '·',
                Vertical:    '¦',
                Cross:       '●',
                HorizontalDown: '●',
                HorizontalUp:   '●',
                VerticalLeft:   '●',
                VerticalRight:  '●',
        },
        "Pipes": {
                TopLeft:     '╱',
                TopRight:    '╲',
                BottomLeft:  '╲',
                BottomRight: '╱',
                Horizontal:  '⎯',
                Vertical:    '⎪',
                Cross:       '╳',
                HorizontalDown: '⎬',
                HorizontalUp:   '⎫',
                VerticalLeft:   '⎨',
                VerticalRight:  '⎬',
        },
        "Vintage": {
                TopLeft:     '◊',
                TopRight:    '◊',
                BottomLeft:  '◊',
                BottomRight: '◊',
                Horizontal:  '~',
                Vertical:    '¦',
                Cross:       '◊',
                HorizontalDown: '◊',
                HorizontalUp:   '◊',
                VerticalLeft:   '◊',
                VerticalRight:  '◊',
        },
}

// GetBorderStyle returns the border characters for a given style name
func GetBorderStyle(styleName string) BorderChars <span class="cov10" title="10">{
        if style, ok := BorderStyles[styleName]; ok </span><span class="cov10" title="10">{
                return style
        }</span>
        // Default to single style
        <span class="cov0" title="0">return BorderStyles["Single"]</span>
}

// BorderStyleNames returns all available border style names
func BorderStyleNames() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(BorderStyles))
        for name := range BorderStyles </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        // Sort for consistent ordering
        <span class="cov0" title="0">sort.Strings(names)
        return names</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">package ui

import (
        "github.com/gdamore/tcell/v2"
        "github.com/rivo/tview"
)

// CustomBox wraps a primitive with custom border characters
type CustomBox struct {
        *tview.Box
        content  tview.Primitive
        title    string
        border   bool
        style    BorderChars
}

// NewCustomBox creates a new custom box with content
func NewCustomBox(content tview.Primitive) *CustomBox <span class="cov8" title="1">{
        return &amp;CustomBox{
                Box:     tview.NewBox(),
                content: content,
                border:  true,
                style:   GetBorderStyle("Single"),
        }
}</span>

// SetTitle sets the box title
func (c *CustomBox) SetTitle(title string) *CustomBox <span class="cov0" title="0">{
        c.title = title
        return c
}</span>

// SetBorder enables/disables the border
func (c *CustomBox) SetBorder(show bool) *CustomBox <span class="cov0" title="0">{
        c.border = show
        return c
}</span>

// SetBorderStyle sets the border style
func (c *CustomBox) SetBorderStyle(style BorderChars) *CustomBox <span class="cov0" title="0">{
        c.style = style
        return c
}</span>

// Draw draws the box with custom borders
func (c *CustomBox) Draw(screen tcell.Screen) <span class="cov0" title="0">{
        c.Box.DrawForSubclass(screen, c)
        x, y, width, height := c.GetInnerRect()
        
        if c.border &amp;&amp; width &gt; 0 &amp;&amp; height &gt; 0 </span><span class="cov0" title="0">{
                // Draw border
                borderColor := c.GetBorderColor()
                
                // Top border
                screen.SetContent(x-1, y-1, c.style.TopLeft, nil, tcell.StyleDefault.Foreground(borderColor))
                screen.SetContent(x+width, y-1, c.style.TopRight, nil, tcell.StyleDefault.Foreground(borderColor))
                for i := x; i &lt; x+width; i++ </span><span class="cov0" title="0">{
                        screen.SetContent(i, y-1, c.style.Horizontal, nil, tcell.StyleDefault.Foreground(borderColor))
                }</span>
                
                // Bottom border
                <span class="cov0" title="0">screen.SetContent(x-1, y+height, c.style.BottomLeft, nil, tcell.StyleDefault.Foreground(borderColor))
                screen.SetContent(x+width, y+height, c.style.BottomRight, nil, tcell.StyleDefault.Foreground(borderColor))
                for i := x; i &lt; x+width; i++ </span><span class="cov0" title="0">{
                        screen.SetContent(i, y+height, c.style.Horizontal, nil, tcell.StyleDefault.Foreground(borderColor))
                }</span>
                
                // Side borders
                <span class="cov0" title="0">for i := y; i &lt; y+height; i++ </span><span class="cov0" title="0">{
                        screen.SetContent(x-1, i, c.style.Vertical, nil, tcell.StyleDefault.Foreground(borderColor))
                        screen.SetContent(x+width, i, c.style.Vertical, nil, tcell.StyleDefault.Foreground(borderColor))
                }</span>
                
                // Draw title if present
                <span class="cov0" title="0">if c.title != "" &amp;&amp; width &gt; 4 </span><span class="cov0" title="0">{
                        titleColor := tcell.ColorWhite // Default title color
                        title := c.title
                        if len(title) &gt; width-4 </span><span class="cov0" title="0">{
                                title = title[:width-4] + "..."
                        }</span>
                        <span class="cov0" title="0">tview.Print(screen, " "+title+" ", x+1, y-1, width-2, tview.AlignLeft, titleColor)</span>
                }
        }
        
        // Draw content
        <span class="cov0" title="0">if c.content != nil </span><span class="cov0" title="0">{
                c.content.SetRect(x, y, width, height)
                c.content.Draw(screen)
        }</span>
}

// Focus passes focus to the content
func (c *CustomBox) Focus(delegate func(p tview.Primitive)) <span class="cov0" title="0">{
        if c.content != nil </span><span class="cov0" title="0">{
                delegate(c.content)
        }</span>
}

// HasFocus returns whether the content has focus
func (c *CustomBox) HasFocus() bool <span class="cov0" title="0">{
        if c.content != nil </span><span class="cov0" title="0">{
                return c.content.HasFocus()
        }</span>
        <span class="cov0" title="0">return false</span>
}

// InputHandler returns the handler for this primitive
func (c *CustomBox) InputHandler() func(event *tcell.EventKey, setFocus func(p tview.Primitive)) <span class="cov0" title="0">{
        return c.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p tview.Primitive)) </span><span class="cov0" title="0">{
                if c.content != nil &amp;&amp; c.content.HasFocus() </span><span class="cov0" title="0">{
                        if handler := c.content.InputHandler(); handler != nil </span><span class="cov0" title="0">{
                                handler(event, setFocus)
                        }</span>
                }
        })
}

// MouseHandler returns the mouse handler for this primitive
func (c *CustomBox) MouseHandler() func(action tview.MouseAction, event *tcell.EventMouse, setFocus func(p tview.Primitive)) (consumed bool, capture tview.Primitive) <span class="cov0" title="0">{
        return c.WrapMouseHandler(func(action tview.MouseAction, event *tcell.EventMouse, setFocus func(p tview.Primitive)) (consumed bool, capture tview.Primitive) </span><span class="cov0" title="0">{
                if c.content == nil </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                
                // Pass mouse events to content
                <span class="cov0" title="0">if handler := c.content.MouseHandler(); handler != nil </span><span class="cov0" title="0">{
                        return handler(action, event, setFocus)
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        })
}</pre>
		
		<pre class="file" id="file19" style="display: none">package ui

import (
        "fmt"

        "github.com/gdamore/tcell/v2"
        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
)

// DashboardBuilder provides an interface for building custom dashboards
type DashboardBuilder struct {
        app            *tview.Application
        pages          *tview.Pages
        monitor        *netcap.NetworkMonitor
        registry       *VisualizationRegistry
        theme          Theme
        
        // Current dashboard
        dashboard      *Dashboard
        selectedViz    Visualization
        
        // Builder UI components
        mainFlex       *tview.Flex
        vizList        *tview.List
        previewArea    *tview.TextView
        gridConfig     *tview.Form
        
        // Grid configuration
        gridRows       int
        gridCols       int
        currentRow     int
        currentCol     int
        
        // Callbacks
        onSave         func(layout DashboardLayout)
        onCancel       func()
}

// NewDashboardBuilder creates a new dashboard builder
func NewDashboardBuilder(app *tview.Application, monitor *netcap.NetworkMonitor, registry *VisualizationRegistry) *DashboardBuilder <span class="cov0" title="0">{
        db := &amp;DashboardBuilder{
                app:      app,
                monitor:  monitor,
                registry: registry,
                gridRows: 3,
                gridCols: 3,
                pages:    tview.NewPages(),
        }
        
        db.dashboard = NewDashboard(registry, monitor)
        db.setupUI()
        
        return db
}</span>

// SetTheme sets the theme
func (db *DashboardBuilder) SetTheme(theme Theme) <span class="cov0" title="0">{
        db.theme = theme
        db.dashboard.SetTheme(theme)
}</span>

// setupUI creates the builder interface
func (db *DashboardBuilder) setupUI() <span class="cov0" title="0">{
        // Visualization list
        db.vizList = tview.NewList()
        db.vizList.SetBorder(true).SetTitle("Available Visualizations")
        
        // Add all visualizations to list
        vizs := db.registry.GetAll()
        for _, viz := range vizs </span><span class="cov0" title="0">{
                v := viz // Capture for closure
                db.vizList.AddItem(v.GetName(), v.GetDescription(), 0, func() </span><span class="cov0" title="0">{
                        db.selectVisualization(v)
                }</span>)
        }
        
        // Preview area
        <span class="cov0" title="0">db.previewArea = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        db.previewArea.SetBorder(true).SetTitle("Preview")
        
        // Grid configuration form
        db.gridConfig = tview.NewForm()
        db.gridConfig.SetBorder(true).SetTitle("Grid Configuration")
        
        db.gridConfig.
                AddInputField("Rows", fmt.Sprintf("%d", db.gridRows), 5, nil, func(text string) </span><span class="cov0" title="0">{
                        if rows := parseIntOrDefault(text, 3); rows &gt; 0 &amp;&amp; rows &lt;= 10 </span><span class="cov0" title="0">{
                                db.gridRows = rows
                        }</span>
                }).
                AddInputField("Columns", fmt.Sprintf("%d", db.gridCols), 5, nil, func(text string) <span class="cov0" title="0">{
                        if cols := parseIntOrDefault(text, 3); cols &gt; 0 &amp;&amp; cols &lt;= 10 </span><span class="cov0" title="0">{
                                db.gridCols = cols
                        }</span>
                }).
                AddButton("Apply Grid", func() <span class="cov0" title="0">{
                        db.applyGridConfiguration()
                }</span>)
        
        // Dashboard view
        <span class="cov0" title="0">dashboardView := db.dashboard
        dashboardView.SetBorder(true).SetTitle("Dashboard Preview")
        
        // Control buttons
        controlForm := tview.NewForm()
        controlForm.SetBorder(true).SetTitle("Controls")
        
        controlForm.
                AddButton("Add to Dashboard", func() </span><span class="cov0" title="0">{
                        db.addSelectedVisualization()
                }</span>).
                AddButton("Clear Dashboard", func() <span class="cov0" title="0">{
                        db.clearDashboard()
                }</span>).
                AddButton("Save Dashboard", func() <span class="cov0" title="0">{
                        db.saveDashboard()
                }</span>).
                AddButton("Cancel", func() <span class="cov0" title="0">{
                        if db.onCancel != nil </span><span class="cov0" title="0">{
                                db.onCancel()
                        }</span>
                })
        
        // Layout
        <span class="cov0" title="0">leftPanel := tview.NewFlex().
                SetDirection(tview.FlexRow).
                AddItem(db.vizList, 0, 2, true).
                AddItem(db.gridConfig, 8, 0, false).
                AddItem(controlForm, 8, 0, false)
        
        rightPanel := tview.NewFlex().
                SetDirection(tview.FlexRow).
                AddItem(dashboardView, 0, 3, false).
                AddItem(db.previewArea, 0, 1, false)
        
        db.mainFlex = tview.NewFlex().
                AddItem(leftPanel, 0, 1, true).
                AddItem(rightPanel, 0, 2, false)
        
        // Keyboard shortcuts
        db.mainFlex.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                switch event.Key() </span>{
                case tcell.KeyEscape:<span class="cov0" title="0">
                        if db.onCancel != nil </span><span class="cov0" title="0">{
                                db.onCancel()
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                case tcell.KeyTab:<span class="cov0" title="0">
                        // Cycle focus
                        return event</span>
                }
                
                <span class="cov0" title="0">switch event.Rune() </span>{
                case 'a', 'A':<span class="cov0" title="0">
                        db.addSelectedVisualization()
                        return nil</span>
                case 'c', 'C':<span class="cov0" title="0">
                        db.clearDashboard()
                        return nil</span>
                case 's', 'S':<span class="cov0" title="0">
                        db.saveDashboard()
                        return nil</span>
                }
                
                <span class="cov0" title="0">return event</span>
        })
        
        // Initial grid setup
        <span class="cov0" title="0">db.applyGridConfiguration()</span>
}

// GetView returns the main view
func (db *DashboardBuilder) GetView() tview.Primitive <span class="cov0" title="0">{
        return db.mainFlex
}</span>

// selectVisualization selects a visualization for preview
func (db *DashboardBuilder) selectVisualization(viz Visualization) <span class="cov0" title="0">{
        db.selectedViz = viz
        
        // Update preview
        preview := fmt.Sprintf("[yellow]%s[white]\n\n", viz.GetName())
        preview += fmt.Sprintf("Description: %s\n\n", viz.GetDescription())
        
        minW, minH := viz.GetMinSize()
        preview += fmt.Sprintf("Minimum Size: %dx%d\n", minW, minH)
        preview += fmt.Sprintf("Supports Fullscreen: %v\n\n", viz.SupportsFullscreen())
        
        preview += "[green]Press 'A' to add to dashboard[white]\n"
        
        db.previewArea.SetText(preview)
}</span>

// addSelectedVisualization adds the selected visualization to the dashboard
func (db *DashboardBuilder) addSelectedVisualization() <span class="cov0" title="0">{
        if db.selectedViz == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Find next available position
        <span class="cov0" title="0">for row := 0; row &lt; db.gridRows; row++ </span><span class="cov0" title="0">{
                for col := 0; col &lt; db.gridCols; col++ </span><span class="cov0" title="0">{
                        if db.isPositionAvailable(row, col) </span><span class="cov0" title="0">{
                                // Add visualization at this position
                                vizConfig := DashboardVisualization{
                                        ID:      db.selectedViz.GetID(),
                                        Row:     row,
                                        Col:     col,
                                        RowSpan: 1,
                                        ColSpan: 1,
                                }
                                
                                // Update layout
                                layout := db.dashboard.layout
                                layout.Visualizations = append(layout.Visualizations, vizConfig)
                                layout.GridRows = db.gridRows
                                layout.GridCols = db.gridCols
                                
                                db.dashboard.SetLayout(layout)
                                db.updateDashboard()
                                return
                        }</span>
                }
        }
        
        // No space available
        <span class="cov0" title="0">db.showMessage("No space available in dashboard")</span>
}

// isPositionAvailable checks if a grid position is available
func (db *DashboardBuilder) isPositionAvailable(row, col int) bool <span class="cov0" title="0">{
        for _, viz := range db.dashboard.layout.Visualizations </span><span class="cov0" title="0">{
                if viz.Row == row &amp;&amp; viz.Col == col </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// clearDashboard clears all visualizations
func (db *DashboardBuilder) clearDashboard() <span class="cov0" title="0">{
        layout := DashboardLayout{
                GridRows: db.gridRows,
                GridCols: db.gridCols,
                Visualizations: []DashboardVisualization{},
        }
        db.dashboard.SetLayout(layout)
        db.updateDashboard()
}</span>

// applyGridConfiguration applies the grid configuration
func (db *DashboardBuilder) applyGridConfiguration() <span class="cov0" title="0">{
        layout := db.dashboard.layout
        layout.GridRows = db.gridRows
        layout.GridCols = db.gridCols
        
        // Remove visualizations that are now out of bounds
        newVizs := []DashboardVisualization{}
        for _, viz := range layout.Visualizations </span><span class="cov0" title="0">{
                if viz.Row &lt; db.gridRows &amp;&amp; viz.Col &lt; db.gridCols </span><span class="cov0" title="0">{
                        newVizs = append(newVizs, viz)
                }</span>
        }
        <span class="cov0" title="0">layout.Visualizations = newVizs
        
        db.dashboard.SetLayout(layout)
        db.updateDashboard()</span>
}

// updateDashboard updates the dashboard display
func (db *DashboardBuilder) updateDashboard() <span class="cov0" title="0">{
        // Trigger update
        go func() </span><span class="cov0" title="0">{
                db.dashboard.Update()
                db.app.Draw()
        }</span>()
}

// saveDashboard saves the current dashboard layout
func (db *DashboardBuilder) saveDashboard() <span class="cov0" title="0">{
        if db.onSave != nil </span><span class="cov0" title="0">{
                layout := db.dashboard.layout
                layout.Name = "Custom Dashboard"
                layout.Description = fmt.Sprintf("%dx%d grid with %d visualizations",
                        db.gridRows, db.gridCols, len(layout.Visualizations))
                
                db.onSave(layout)
        }</span>
}

// showMessage shows a temporary message
func (db *DashboardBuilder) showMessage(msg string) <span class="cov0" title="0">{
        modal := tview.NewModal().
                SetText(msg).
                AddButtons([]string{"OK"}).
                SetDoneFunc(func(_ int, _ string) </span><span class="cov0" title="0">{
                        db.app.SetRoot(db.mainFlex, true)
                }</span>)
        
        <span class="cov0" title="0">db.app.SetRoot(modal, true)</span>
}

// SetOnSave sets the save callback
func (db *DashboardBuilder) SetOnSave(fn func(DashboardLayout)) <span class="cov0" title="0">{
        db.onSave = fn
}</span>

// SetOnCancel sets the cancel callback
func (db *DashboardBuilder) SetOnCancel(fn func()) <span class="cov0" title="0">{
        db.onCancel = fn
}</span>

// parseIntOrDefault parses an integer or returns default
func parseIntOrDefault(s string, def int) int <span class="cov0" title="0">{
        var val int
        if _, err := fmt.Sscanf(s, "%d", &amp;val); err == nil </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return def</span>
}

// DashboardManager manages saved dashboards
type DashboardManager struct {
        dashboards map[string]DashboardLayout
}

// NewDashboardManager creates a new dashboard manager
func NewDashboardManager() *DashboardManager <span class="cov0" title="0">{
        dm := &amp;DashboardManager{
                dashboards: make(map[string]DashboardLayout),
        }
        
        // Add some default dashboards
        dm.addDefaultDashboards()
        
        return dm
}</span>

// addDefaultDashboards adds pre-configured dashboards
func (dm *DashboardManager) addDefaultDashboards() <span class="cov0" title="0">{
        // Network Overview Dashboard
        dm.dashboards["overview"] = DashboardLayout{
                Name:        "Network Overview",
                Description: "Comprehensive network monitoring dashboard",
                GridRows:    3,
                GridCols:    3,
                Visualizations: []DashboardVisualization{
                        {ID: "speedometer", Row: 0, Col: 0, RowSpan: 1, ColSpan: 1},
                        {ID: "heartbeat", Row: 0, Col: 1, RowSpan: 1, ColSpan: 2},
                        {ID: "sankey", Row: 1, Col: 0, RowSpan: 1, ColSpan: 2},
                        {ID: "weather", Row: 1, Col: 2, RowSpan: 1, ColSpan: 1},
                        {ID: "packet_dist", Row: 2, Col: 0, RowSpan: 1, ColSpan: 1},
                        {ID: "conn_lifetime", Row: 2, Col: 1, RowSpan: 1, ColSpan: 2},
                },
        }
        
        // Security Dashboard
        dm.dashboards["security"] = DashboardLayout{
                Name:        "Security Monitor",
                Description: "Focus on security-relevant network activity",
                GridRows:    2,
                GridCols:    3,
                Visualizations: []DashboardVisualization{
                        {ID: "constellation", Row: 0, Col: 0, RowSpan: 1, ColSpan: 2},
                        {ID: "dns_timeline", Row: 0, Col: 2, RowSpan: 1, ColSpan: 1},
                        {ID: "sunburst", Row: 1, Col: 0, RowSpan: 1, ColSpan: 1},
                        {ID: "matrix", Row: 1, Col: 1, RowSpan: 1, ColSpan: 2},
                },
        }
        
        // Performance Dashboard
        dm.dashboards["performance"] = DashboardLayout{
                Name:        "Performance Monitor",
                Description: "Network performance and bandwidth analysis",
                GridRows:    2,
                GridCols:    2,
                Visualizations: []DashboardVisualization{
                        {ID: "speedometer", Row: 0, Col: 0, RowSpan: 1, ColSpan: 1},
                        {ID: "heartbeat", Row: 0, Col: 1, RowSpan: 1, ColSpan: 1},
                        {ID: "heatmap", Row: 1, Col: 0, RowSpan: 1, ColSpan: 1},
                        {ID: "radial", Row: 1, Col: 1, RowSpan: 1, ColSpan: 1},
                },
        }
        
        // Protocol Analysis Dashboard
        dm.dashboards["protocols"] = DashboardLayout{
                Name:        "Protocol Analysis",
                Description: "Comprehensive FTP, SSH, POP3, and IMAP protocol monitoring",
                GridRows:    1,
                GridCols:    1,
                Visualizations: []DashboardVisualization{
                        {ID: "protocol_dashboard", Row: 0, Col: 0, RowSpan: 1, ColSpan: 1},
                },
        }
}</span>

// GetDashboard returns a dashboard by name
func (dm *DashboardManager) GetDashboard(name string) (DashboardLayout, bool) <span class="cov0" title="0">{
        layout, exists := dm.dashboards[name]
        return layout, exists
}</span>

// SaveDashboard saves a dashboard
func (dm *DashboardManager) SaveDashboard(name string, layout DashboardLayout) <span class="cov0" title="0">{
        dm.dashboards[name] = layout
}</span>

// ListDashboards returns all dashboard names
func (dm *DashboardManager) ListDashboards() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(dm.dashboards))
        for name := range dm.dashboards </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}</pre>
		
		<pre class="file" id="file20" style="display: none">package ui

import (
        "os"
        "time"

        chart "github.com/wcharczuk/go-chart/v2"
        "github.com/user/netmon/pkg/graph"
)

// ensure graph import is used
var _ = graph.NewMultiGraph

// ExportSVG exports the combined traffic graph to an SVG file.
func (ui *UI) ExportSVG(path string) error <span class="cov0" title="0">{
        widgets := ui.trafficGraph.GraphWidgets()
        series := make([]chart.Series, 0)
        for _, w := range widgets </span><span class="cov0" title="0">{
                // Primary data series
                primaryPts := w.DataPoints()
                xs := make([]time.Time, len(primaryPts))
                ys := make([]float64, len(primaryPts))
                for i, p := range primaryPts </span><span class="cov0" title="0">{
                        xs[i] = p.Timestamp
                        ys[i] = p.Value
                }</span>
                <span class="cov0" title="0">primaryLabel, _ := w.Labels()
                series = append(series, chart.TimeSeries{
                        Name:    primaryLabel,
                        XValues: xs,
                        YValues: ys,
                })

                // Secondary data series
                secondaryPts := w.SecondaryDataPoints()
                xs2 := make([]time.Time, len(secondaryPts))
                ys2 := make([]float64, len(secondaryPts))
                for i, p := range secondaryPts </span><span class="cov0" title="0">{
                        xs2[i] = p.Timestamp
                        ys2[i] = p.Value
                }</span>
                <span class="cov0" title="0">_, secondaryLabel := w.Labels()
                series = append(series, chart.TimeSeries{
                        Name:    secondaryLabel,
                        XValues: xs2,
                        YValues: ys2,
                })</span>
        }

        <span class="cov0" title="0">f, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        return chart.Chart{
                Series: series,
        }.Render(chart.SVG, f)</span>
}

// ExportPNG exports the combined traffic graph to a PNG file.
func (ui *UI) ExportPNG(path string) error <span class="cov0" title="0">{
        widgets := ui.trafficGraph.GraphWidgets()
        series := make([]chart.Series, 0)
        for _, w := range widgets </span><span class="cov0" title="0">{
                // Primary data series
                primaryPts := w.DataPoints()
                xs := make([]time.Time, len(primaryPts))
                ys := make([]float64, len(primaryPts))
                for i, p := range primaryPts </span><span class="cov0" title="0">{
                        xs[i] = p.Timestamp
                        ys[i] = p.Value
                }</span>
                <span class="cov0" title="0">primaryLabel, _ := w.Labels()
                series = append(series, chart.TimeSeries{
                        Name:    primaryLabel,
                        XValues: xs,
                        YValues: ys,
                })

                // Secondary data series
                secondaryPts := w.SecondaryDataPoints()
                xs2 := make([]time.Time, len(secondaryPts))
                ys2 := make([]float64, len(secondaryPts))
                for i, p := range secondaryPts </span><span class="cov0" title="0">{
                        xs2[i] = p.Timestamp
                        ys2[i] = p.Value
                }</span>
                <span class="cov0" title="0">_, secondaryLabel := w.Labels()
                series = append(series, chart.TimeSeries{
                        Name:    secondaryLabel,
                        XValues: xs2,
                        YValues: ys2,
                })</span>
        }

        <span class="cov0" title="0">f, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        return chart.Chart{
                Series: series,
        }.Render(chart.PNG, f)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package ui

import (
        "github.com/gdamore/tcell/v2"
        "github.com/rivo/tview"
)

// StyledGrid is a custom grid implementation that supports styled borders
type StyledGrid struct {
        *tview.Box
        
        // Grid cells
        cells []*gridCell
        
        // Grid dimensions
        rows, columns int
        rowHeights []int
        columnWidths []int
        
        // Minimum dimensions
        minHeight, minWidth int
        
        // Border settings
        borders bool
        borderStyle BorderChars
        borderColor tcell.Color
        
        // Animation settings
        animation string
        animationFrame int
        
        // Gap between cells
        gap int
}

// gridCell represents a single cell in the grid
type gridCell struct {
        row, column int
        rowSpan, colSpan int
        primitive tview.Primitive
        focus bool
        borderStyle *BorderChars // Custom border style for this cell (nil uses grid default)
        borderAnimation string   // Custom animation for this cell
}

// NewStyledGrid creates a new styled grid
func NewStyledGrid() *StyledGrid <span class="cov5" title="5">{
        return &amp;StyledGrid{
                Box:         tview.NewBox(),
                cells:       make([]*gridCell, 0),
                borders:     true,
                borderStyle: GetBorderStyle("Single"),
                borderColor: tcell.ColorWhite,
                gap:         0,
        }
}</span>

// SetBorders enables or disables borders
func (g *StyledGrid) SetBorders(borders bool) *StyledGrid <span class="cov4" title="4">{
        g.borders = borders
        return g
}</span>

// SetBorderStyle sets the border style
func (g *StyledGrid) SetBorderStyle(style string) *StyledGrid <span class="cov4" title="4">{
        g.borderStyle = GetBorderStyle(style)
        return g
}</span>

// SetBorderColor sets the border color
func (g *StyledGrid) SetBorderColor(color tcell.Color) *StyledGrid <span class="cov4" title="4">{
        g.borderColor = color
        return g
}</span>

// SetAnimation sets the border animation type
func (g *StyledGrid) SetAnimation(animation string) *StyledGrid <span class="cov4" title="4">{
        g.animation = animation
        return g
}</span>

// SetAnimationFrame sets the current animation frame
func (g *StyledGrid) SetAnimationFrame(frame int) *StyledGrid <span class="cov4" title="4">{
        g.animationFrame = frame
        return g
}</span>

// SetColumns defines column widths (0 means proportional)
func (g *StyledGrid) SetColumns(widths ...int) *StyledGrid <span class="cov4" title="4">{
        g.columns = len(widths)
        g.columnWidths = widths
        return g
}</span>

// SetRows defines row heights (0 means proportional)
func (g *StyledGrid) SetRows(heights ...int) *StyledGrid <span class="cov4" title="4">{
        g.rows = len(heights)
        g.rowHeights = heights
        return g
}</span>

// SetGap sets the gap between cells
func (g *StyledGrid) SetGap(gap int) *StyledGrid <span class="cov0" title="0">{
        g.gap = gap
        return g
}</span>

// AddItem adds a primitive to the grid
func (g *StyledGrid) AddItem(p tview.Primitive, row, column, rowSpan, colSpan int, minGridHeight, minGridWidth int, focus bool) *StyledGrid <span class="cov10" title="36">{
        g.cells = append(g.cells, &amp;gridCell{
                row:       row,
                column:    column,
                rowSpan:   rowSpan,
                colSpan:   colSpan,
                primitive: p,
                focus:     focus,
        })
        
        // Update minimum dimensions
        if minGridHeight &gt; g.minHeight </span><span class="cov0" title="0">{
                g.minHeight = minGridHeight
        }</span>
        <span class="cov10" title="36">if minGridWidth &gt; g.minWidth </span><span class="cov0" title="0">{
                g.minWidth = minGridWidth
        }</span>
        
        // Update grid dimensions
        <span class="cov10" title="36">if row+rowSpan &gt; g.rows </span><span class="cov0" title="0">{
                g.rows = row + rowSpan
        }</span>
        <span class="cov10" title="36">if column+colSpan &gt; g.columns </span><span class="cov0" title="0">{
                g.columns = column + colSpan
        }</span>
        
        <span class="cov10" title="36">return g</span>
}

// AddItemWithStyle adds a primitive to the grid with custom border style
func (g *StyledGrid) AddItemWithStyle(p tview.Primitive, row, column, rowSpan, colSpan int, minGridHeight, minGridWidth int, focus bool, borderStyle string, borderAnimation string) *StyledGrid <span class="cov0" title="0">{
        var style *BorderChars
        if borderStyle != "" </span><span class="cov0" title="0">{
                s := GetBorderStyle(borderStyle)
                style = &amp;s
        }</span>
        
        <span class="cov0" title="0">g.cells = append(g.cells, &amp;gridCell{
                row:             row,
                column:          column,
                rowSpan:         rowSpan,
                colSpan:         colSpan,
                primitive:       p,
                focus:           focus,
                borderStyle:     style,
                borderAnimation: borderAnimation,
        })
        
        // Update minimum dimensions
        if minGridHeight &gt; g.minHeight </span><span class="cov0" title="0">{
                g.minHeight = minGridHeight
        }</span>
        <span class="cov0" title="0">if minGridWidth &gt; g.minWidth </span><span class="cov0" title="0">{
                g.minWidth = minGridWidth
        }</span>
        
        // Update grid dimensions
        <span class="cov0" title="0">if row+rowSpan &gt; g.rows </span><span class="cov0" title="0">{
                g.rows = row + rowSpan
        }</span>
        <span class="cov0" title="0">if column+colSpan &gt; g.columns </span><span class="cov0" title="0">{
                g.columns = column + colSpan
        }</span>
        
        <span class="cov0" title="0">return g</span>
}

// Clear removes all items from the grid
func (g *StyledGrid) Clear() *StyledGrid <span class="cov0" title="0">{
        g.cells = nil
        return g
}</span>

// Draw draws the grid
func (g *StyledGrid) Draw(screen tcell.Screen) <span class="cov0" title="0">{
        g.Box.DrawForSubclass(screen, g)
        
        x, y, width, height := g.GetInnerRect()
        
        // Calculate actual row heights and column widths
        rowHeights := g.calculateDimensions(height, g.rows, g.rowHeights, g.borders)
        colWidths := g.calculateDimensions(width, g.columns, g.columnWidths, g.borders)
        
        // Draw borders if enabled
        if g.borders </span><span class="cov0" title="0">{
                g.drawBorders(screen, x, y, rowHeights, colWidths)
        }</span>
        
        // Draw cells
        <span class="cov0" title="0">for _, cell := range g.cells </span><span class="cov0" title="0">{
                if cell.primitive == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Calculate cell position and size
                <span class="cov0" title="0">cellX, cellY := x, y
                cellWidth, cellHeight := 0, 0
                
                // Calculate X position and width
                for i := 0; i &lt; cell.column; i++ </span><span class="cov0" title="0">{
                        cellX += colWidths[i]
                        if g.borders </span><span class="cov0" title="0">{
                                cellX++ // Border width
                        }</span>
                }
                <span class="cov0" title="0">for i := 0; i &lt; cell.colSpan &amp;&amp; cell.column+i &lt; len(colWidths); i++ </span><span class="cov0" title="0">{
                        cellWidth += colWidths[cell.column+i]
                        if g.borders &amp;&amp; i &gt; 0 </span><span class="cov0" title="0">{
                                cellWidth++ // Border between cells
                        }</span>
                }
                
                // Calculate Y position and height
                <span class="cov0" title="0">for i := 0; i &lt; cell.row; i++ </span><span class="cov0" title="0">{
                        cellY += rowHeights[i]
                        if g.borders </span><span class="cov0" title="0">{
                                cellY++ // Border height
                        }</span>
                }
                <span class="cov0" title="0">for i := 0; i &lt; cell.rowSpan &amp;&amp; cell.row+i &lt; len(rowHeights); i++ </span><span class="cov0" title="0">{
                        cellHeight += rowHeights[cell.row+i]
                        if g.borders &amp;&amp; i &gt; 0 </span><span class="cov0" title="0">{
                                cellHeight++ // Border between cells
                        }</span>
                }
                
                // Apply gap
                <span class="cov0" title="0">if g.gap &gt; 0 </span><span class="cov0" title="0">{
                        cellX += g.gap
                        cellY += g.gap
                        cellWidth -= 2 * g.gap
                        cellHeight -= 2 * g.gap
                }</span>
                
                // Set primitive position and draw
                <span class="cov0" title="0">if cellWidth &gt; 0 &amp;&amp; cellHeight &gt; 0 </span><span class="cov0" title="0">{
                        cell.primitive.SetRect(cellX, cellY, cellWidth, cellHeight)
                        cell.primitive.Draw(screen)
                }</span>
        }
}

// drawBorders draws the grid borders with the selected style
func (g *StyledGrid) drawBorders(screen tcell.Screen, x, y int, rowHeights, colWidths []int) <span class="cov0" title="0">{
        // Get animated color if animation is enabled
        borderColor := g.borderColor
        if g.animation != "None" &amp;&amp; g.animation != "" </span><span class="cov0" title="0">{
                borderColor = GetAnimatedBorderColor(g.borderColor, g.animation, g.animationFrame)
        }</span>
        <span class="cov0" title="0">style := tcell.StyleDefault.Foreground(borderColor).Background(tcell.ColorDefault)
        
        // Calculate grid positions
        rowPositions := make([]int, len(rowHeights)+1)
        colPositions := make([]int, len(colWidths)+1)
        
        rowPositions[0] = y - 1
        for i, h := range rowHeights </span><span class="cov0" title="0">{
                rowPositions[i+1] = rowPositions[i] + h + 1
        }</span>
        
        <span class="cov0" title="0">colPositions[0] = x - 1
        for i, w := range colWidths </span><span class="cov0" title="0">{
                colPositions[i+1] = colPositions[i] + w + 1
        }</span>
        
        // Draw horizontal lines
        <span class="cov0" title="0">for _, rowY := range rowPositions </span><span class="cov0" title="0">{
                for j := 0; j &lt; len(colPositions)-1; j++ </span><span class="cov0" title="0">{
                        startX := colPositions[j]
                        endX := colPositions[j+1]
                        
                        for x := startX + 1; x &lt; endX; x++ </span><span class="cov0" title="0">{
                                screen.SetContent(x, rowY, g.borderStyle.Horizontal, nil, style)
                        }</span>
                }
        }
        
        // Draw vertical lines
        <span class="cov0" title="0">for _, colX := range colPositions </span><span class="cov0" title="0">{
                for j := 0; j &lt; len(rowPositions)-1; j++ </span><span class="cov0" title="0">{
                        startY := rowPositions[j]
                        endY := rowPositions[j+1]
                        
                        for y := startY + 1; y &lt; endY; y++ </span><span class="cov0" title="0">{
                                screen.SetContent(colX, y, g.borderStyle.Vertical, nil, style)
                        }</span>
                }
        }
        
        // Draw corners and intersections
        <span class="cov0" title="0">for i, rowY := range rowPositions </span><span class="cov0" title="0">{
                for j, colX := range colPositions </span><span class="cov0" title="0">{
                        var ch rune
                        
                        // Determine which character to use based on position
                        if i == 0 &amp;&amp; j == 0 </span><span class="cov0" title="0">{
                                ch = g.borderStyle.TopLeft
                        }</span> else<span class="cov0" title="0"> if i == 0 &amp;&amp; j == len(colPositions)-1 </span><span class="cov0" title="0">{
                                ch = g.borderStyle.TopRight
                        }</span> else<span class="cov0" title="0"> if i == len(rowPositions)-1 &amp;&amp; j == 0 </span><span class="cov0" title="0">{
                                ch = g.borderStyle.BottomLeft
                        }</span> else<span class="cov0" title="0"> if i == len(rowPositions)-1 &amp;&amp; j == len(colPositions)-1 </span><span class="cov0" title="0">{
                                ch = g.borderStyle.BottomRight
                        }</span> else<span class="cov0" title="0"> if i == 0 </span><span class="cov0" title="0">{
                                ch = g.borderStyle.HorizontalDown
                        }</span> else<span class="cov0" title="0"> if i == len(rowPositions)-1 </span><span class="cov0" title="0">{
                                ch = g.borderStyle.HorizontalUp
                        }</span> else<span class="cov0" title="0"> if j == 0 </span><span class="cov0" title="0">{
                                ch = g.borderStyle.VerticalRight
                        }</span> else<span class="cov0" title="0"> if j == len(colPositions)-1 </span><span class="cov0" title="0">{
                                ch = g.borderStyle.VerticalLeft
                        }</span> else<span class="cov0" title="0"> {
                                ch = g.borderStyle.Cross
                        }</span>
                        
                        <span class="cov0" title="0">screen.SetContent(colX, rowY, ch, nil, style)</span>
                }
        }
}

// calculateDimensions calculates actual dimensions based on available space
func (g *StyledGrid) calculateDimensions(available, count int, specified []int, borders bool) []int <span class="cov0" title="0">{
        if count == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Account for borders
        <span class="cov0" title="0">if borders </span><span class="cov0" title="0">{
                available -= count + 1
        }</span>
        
        <span class="cov0" title="0">result := make([]int, count)
        totalFixed := 0
        proportionalCount := 0
        
        // First pass: count fixed sizes and proportional cells
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                if i &lt; len(specified) &amp;&amp; specified[i] &gt; 0 </span><span class="cov0" title="0">{
                        result[i] = specified[i]
                        totalFixed += specified[i]
                }</span> else<span class="cov0" title="0"> {
                        proportionalCount++
                }</span>
        }
        
        // Second pass: distribute remaining space
        <span class="cov0" title="0">if proportionalCount &gt; 0 &amp;&amp; available &gt; totalFixed </span><span class="cov0" title="0">{
                proportionalSize := (available - totalFixed) / proportionalCount
                remainder := (available - totalFixed) % proportionalCount
                
                for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                        if i &gt;= len(specified) || specified[i] == 0 </span><span class="cov0" title="0">{
                                result[i] = proportionalSize
                                if remainder &gt; 0 </span><span class="cov0" title="0">{
                                        result[i]++
                                        remainder--
                                }</span>
                        }
                }
        }
        
        <span class="cov0" title="0">return result</span>
}

// Focus passes focus to the appropriate cell
func (g *StyledGrid) Focus(delegate func(p tview.Primitive)) <span class="cov4" title="4">{
        for _, cell := range g.cells </span><span class="cov4" title="4">{
                if cell.focus &amp;&amp; cell.primitive != nil </span><span class="cov4" title="4">{
                        delegate(cell.primitive)
                        return
                }</span>
        }
        
        // No focus cell found, focus first available
        <span class="cov0" title="0">for _, cell := range g.cells </span><span class="cov0" title="0">{
                if cell.primitive != nil </span><span class="cov0" title="0">{
                        delegate(cell.primitive)
                        return
                }</span>
        }
}

// HasFocus returns whether any cell has focus
func (g *StyledGrid) HasFocus() bool <span class="cov0" title="0">{
        for _, cell := range g.cells </span><span class="cov0" title="0">{
                if cell.primitive != nil &amp;&amp; cell.primitive.HasFocus() </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// InputHandler returns the handler for this primitive
func (g *StyledGrid) InputHandler() func(event *tcell.EventKey, setFocus func(p tview.Primitive)) <span class="cov0" title="0">{
        return g.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p tview.Primitive)) </span><span class="cov0" title="0">{
                // Find focused cell
                for _, cell := range g.cells </span><span class="cov0" title="0">{
                        if cell.primitive != nil &amp;&amp; cell.primitive.HasFocus() </span><span class="cov0" title="0">{
                                if handler := cell.primitive.InputHandler(); handler != nil </span><span class="cov0" title="0">{
                                        handler(event, setFocus)
                                        return
                                }</span>
                        }
                }
        })
}

// MouseHandler returns the mouse handler for this primitive
func (g *StyledGrid) MouseHandler() func(action tview.MouseAction, event *tcell.EventMouse, setFocus func(p tview.Primitive)) (consumed bool, capture tview.Primitive) <span class="cov0" title="0">{
        return g.WrapMouseHandler(func(action tview.MouseAction, event *tcell.EventMouse, setFocus func(p tview.Primitive)) (consumed bool, capture tview.Primitive) </span><span class="cov0" title="0">{
                // Pass mouse events to cells
                for _, cell := range g.cells </span><span class="cov0" title="0">{
                        if cell.primitive != nil </span><span class="cov0" title="0">{
                                if handler := cell.primitive.MouseHandler(); handler != nil </span><span class="cov0" title="0">{
                                        consumed, capture = handler(action, event, setFocus)
                                        if consumed </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">return false, nil</span>
        })
}</pre>
		
		<pre class="file" id="file22" style="display: none">package ui

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "strconv"
        "github.com/gdamore/tcell/v2"
        "gopkg.in/yaml.v3"
)

// Theme defines UI color scheme inspired by VSCode themes.
type Theme struct {
        BorderColor        tcell.Color
        TitleColor         tcell.Color
        PrimaryColor       tcell.Color
        SecondaryColor     tcell.Color
        PieBorderColor     tcell.Color
        PieTitleColor      tcell.Color
        StatusBarTextColor tcell.Color
        StatusBarBgColor   tcell.Color
        WarningColor       tcell.Color
        SuccessColor       tcell.Color
        // Graph gradient colors (calculated from Primary/Secondary)
        GraphGradient1     tcell.Color
        GraphGradient2     tcell.Color
        GraphGradient3     tcell.Color
}

// calculateGradients computes intermediate gradient colors for smooth transitions
func (t *Theme) calculateGradients() <span class="cov9" title="14">{
        pr, pg, pb := t.PrimaryColor.RGB()
        sr, sg, sb := t.SecondaryColor.RGB()
        
        // Create 3 gradient stops between primary and secondary
        t.GraphGradient1 = tcell.NewRGBColor(
                pr*3/4 + sr*1/4,
                pg*3/4 + sg*1/4,
                pb*3/4 + sb*1/4,
        )
        t.GraphGradient2 = tcell.NewRGBColor(
                pr*1/2 + sr*1/2,
                pg*1/2 + sg*1/2,
                pb*1/2 + sb*1/2,
        )
        t.GraphGradient3 = tcell.NewRGBColor(
                pr*1/4 + sr*3/4,
                pg*1/4 + sg*3/4,
                pb*1/4 + sb*3/4,
        )
}</span>

// GetUsageColor returns a color based on usage percentage (0-100)
// Green (0-50%) -&gt; Yellow (50-80%) -&gt; Red (80-100%)
func GetUsageColor(percentage float64) tcell.Color <span class="cov0" title="0">{
        if percentage &lt; 0 </span><span class="cov0" title="0">{
                percentage = 0
        }</span>
        <span class="cov0" title="0">if percentage &gt; 100 </span><span class="cov0" title="0">{
                percentage = 100
        }</span>
        
        // Define color stops
        <span class="cov0" title="0">green := tcell.NewRGBColor(0x00, 0xFF, 0x00)
        yellow := tcell.NewRGBColor(0xFF, 0xFF, 0x00)
        red := tcell.NewRGBColor(0xFF, 0x00, 0x00)
        
        if percentage &lt;= 50 </span><span class="cov0" title="0">{
                // Interpolate between green and yellow
                ratio := percentage / 50.0
                return interpolateColor(green, yellow, ratio)
        }</span> else<span class="cov0" title="0"> {
                // Interpolate between yellow and red
                ratio := (percentage - 50) / 50.0
                return interpolateColor(yellow, red, ratio)
        }</span>
}

// interpolateColor blends two colors based on ratio (0-1)
func interpolateColor(c1, c2 tcell.Color, ratio float64) tcell.Color <span class="cov0" title="0">{
        r1, g1, b1 := c1.RGB()
        r2, g2, b2 := c2.RGB()
        
        r := int32(float64(r1)*(1-ratio) + float64(r2)*ratio)
        g := int32(float64(g1)*(1-ratio) + float64(g2)*ratio)
        b := int32(float64(b1)*(1-ratio) + float64(b2)*ratio)
        
        return tcell.NewRGBColor(r, g, b)
}</span>

// Themes holds predefined color schemes.
var Themes = map[string]Theme{
        // High-Contrast Dark: deep black with neon green &amp; electric blue accents
        "High-Contrast Dark": {
                BorderColor:        tcell.NewRGBColor(0x00, 0xFF, 0x00), // neon green
                TitleColor:         tcell.NewRGBColor(0x00, 0xFF, 0x00),
                PrimaryColor:       tcell.NewRGBColor(0x00, 0x80, 0xFF), // electric blue
                SecondaryColor:     tcell.NewRGBColor(0x00, 0xFF, 0x00),
                PieBorderColor:     tcell.NewRGBColor(0x00, 0xFF, 0x00),
                PieTitleColor:      tcell.NewRGBColor(0x00, 0xFF, 0x00),
                StatusBarTextColor: tcell.NewRGBColor(0x00, 0xFF, 0x00),
                StatusBarBgColor:   tcell.ColorBlack,
                WarningColor:       tcell.NewRGBColor(0xFF, 0xFF, 0x00), // yellow
                SuccessColor:       tcell.NewRGBColor(0x00, 0xFF, 0x00), // green
        },
        "Dark+": {
                BorderColor:        tcell.NewRGBColor(0x00, 0x7A, 0xCC),
                TitleColor:         tcell.NewRGBColor(0x00, 0x7A, 0xCC),
                PrimaryColor:       tcell.NewRGBColor(0x0E, 0xBF, 0xE9),
                SecondaryColor:     tcell.NewRGBColor(0xD4, 0x42, 0xFF),
                PieBorderColor:     tcell.NewRGBColor(0x00, 0x7A, 0xCC),
                PieTitleColor:      tcell.NewRGBColor(0x00, 0x7A, 0xCC),
                StatusBarTextColor: tcell.ColorWhite,
                StatusBarBgColor:   tcell.ColorBlack,
                WarningColor:       tcell.NewRGBColor(0xFF, 0xCC, 0x00), // amber
                SuccessColor:       tcell.NewRGBColor(0x4E, 0xC9, 0xB0), // light green
        },
        "Light+": {
                BorderColor:        tcell.NewRGBColor(0x00, 0x00, 0x00),
                TitleColor:         tcell.NewRGBColor(0x00, 0x00, 0x00),
                PrimaryColor:       tcell.NewRGBColor(0x00, 0x64, 0x00),
                SecondaryColor:     tcell.NewRGBColor(0x00, 0x00, 0x8B),
                PieBorderColor:     tcell.NewRGBColor(0x00, 0x00, 0x00),
                PieTitleColor:      tcell.NewRGBColor(0x00, 0x00, 0x00),
                StatusBarTextColor: tcell.ColorBlack,
                StatusBarBgColor:   tcell.ColorWhite,
                WarningColor:       tcell.NewRGBColor(0xFF, 0x8C, 0x00), // dark orange
                SuccessColor:       tcell.NewRGBColor(0x00, 0x80, 0x00), // dark green
        },
        "Monokai": {
                BorderColor:        tcell.NewRGBColor(0xA6, 0xE2, 0x2E),
                TitleColor:         tcell.NewRGBColor(0xA6, 0xE2, 0x2E),
                PrimaryColor:       tcell.NewRGBColor(0xA6, 0xE2, 0x2E),
                SecondaryColor:     tcell.NewRGBColor(0x66, 0xD9, 0xEF),
                PieBorderColor:     tcell.NewRGBColor(0xA6, 0xE2, 0x2E),
                PieTitleColor:      tcell.NewRGBColor(0xA6, 0xE2, 0x2E),
                StatusBarTextColor: tcell.ColorWhite,
                StatusBarBgColor:   tcell.ColorBlack,
                WarningColor:       tcell.NewRGBColor(0xF9, 0x26, 0x72), // pink
                SuccessColor:       tcell.NewRGBColor(0xA6, 0xE2, 0x2E), // green,
        },
        // Solarized Light: light background with Solarized palette
        "Solarized Light": {
                BorderColor:        tcell.NewRGBColor(0x26, 0x8B, 0xD2), // #268bd2
                TitleColor:         tcell.NewRGBColor(0x26, 0x8B, 0xD2),
                PrimaryColor:       tcell.NewRGBColor(0x85, 0x99, 0x00), // #859900
                SecondaryColor:     tcell.NewRGBColor(0x2A, 0xA1, 0x98),
                PieBorderColor:     tcell.NewRGBColor(0x26, 0x8B, 0xD2),
                PieTitleColor:      tcell.NewRGBColor(0x26, 0x8B, 0xD2),
                StatusBarTextColor: tcell.ColorBlack,
                StatusBarBgColor:   tcell.NewRGBColor(0xFD, 0xF6, 0xE3),
                WarningColor:       tcell.NewRGBColor(0xCB, 0x4B, 0x16), // orange
                SuccessColor:       tcell.NewRGBColor(0x85, 0x99, 0x00), // green, // #fdf6e3
        },
        "Solarized Dark": {
                BorderColor:        tcell.NewRGBColor(0x26, 0x8B, 0xD2),
                TitleColor:         tcell.NewRGBColor(0x26, 0x8B, 0xD2),
                PrimaryColor:       tcell.NewRGBColor(0xB5, 0x89, 0x00),
                SecondaryColor:     tcell.NewRGBColor(0x2A, 0xA1, 0x98),
                PieBorderColor:     tcell.NewRGBColor(0x26, 0x8B, 0xD2),
                PieTitleColor:      tcell.NewRGBColor(0x26, 0x8B, 0xD2),
                StatusBarTextColor: tcell.ColorWhite,
                StatusBarBgColor:   tcell.NewRGBColor(0x00, 0x2B, 0x36),
                WarningColor:       tcell.NewRGBColor(0xCB, 0x4B, 0x16), // orange
                SuccessColor:       tcell.NewRGBColor(0x85, 0x99, 0x00), // green,
        },
        // Monochrome Accessibility: pure black-and-white UI
        "Monochrome Accessibility": {
                BorderColor:        tcell.ColorWhite,
                TitleColor:         tcell.ColorWhite,
                PrimaryColor:       tcell.ColorWhite,
                SecondaryColor:     tcell.ColorWhite,
                PieBorderColor:     tcell.ColorWhite,
                PieTitleColor:      tcell.ColorWhite,
                StatusBarTextColor: tcell.ColorBlack,
                StatusBarBgColor:   tcell.ColorBlack,
                WarningColor:       tcell.ColorWhite,
                SuccessColor:       tcell.ColorWhite,
        },
        "Dracula": {
                BorderColor:        tcell.NewRGBColor(0xBD, 0x93, 0xF9),
                TitleColor:         tcell.NewRGBColor(0xBD, 0x93, 0xF9),
                PrimaryColor:       tcell.NewRGBColor(0x50, 0xFA, 0x7B),
                SecondaryColor:     tcell.NewRGBColor(0xFF, 0x79, 0xC6),
                PieBorderColor:     tcell.NewRGBColor(0xBD, 0x93, 0xF9),
                PieTitleColor:      tcell.NewRGBColor(0xBD, 0x93, 0xF9),
                StatusBarTextColor: tcell.ColorWhite,
                StatusBarBgColor:   tcell.NewRGBColor(0x28, 0x2A, 0x36),
                WarningColor:       tcell.NewRGBColor(0xF1, 0xFA, 0x8C), // yellow
                SuccessColor:       tcell.NewRGBColor(0x50, 0xFA, 0x7B), // green,
        },
        "Tokyo Night": {
                BorderColor:        tcell.NewRGBColor(0x7A, 0xA2, 0xF7),
                TitleColor:         tcell.NewRGBColor(0x7A, 0xA2, 0xF7),
                PrimaryColor:       tcell.NewRGBColor(0x7D, 0xCF, 0xFF),
                SecondaryColor:     tcell.NewRGBColor(0xBB, 0x9A, 0xF7),
                PieBorderColor:     tcell.NewRGBColor(0x7A, 0xA2, 0xF7),
                PieTitleColor:      tcell.NewRGBColor(0x7A, 0xA2, 0xF7),
                StatusBarTextColor: tcell.ColorWhite,
                StatusBarBgColor:   tcell.NewRGBColor(0x1A, 0x1B, 0x26),
                WarningColor:       tcell.NewRGBColor(0xE0, 0xAF, 0x68), // yellow
                SuccessColor:       tcell.NewRGBColor(0x9E, 0xCE, 0x6A), // green,
        },
        "Tokyo Night Storm": {
                BorderColor:        tcell.NewRGBColor(0x9D, 0x7C, 0xD8),
                TitleColor:         tcell.NewRGBColor(0x9D, 0x7C, 0xD8),
                PrimaryColor:       tcell.NewRGBColor(0x7D, 0xCF, 0xFF),
                SecondaryColor:     tcell.NewRGBColor(0x7A, 0xA2, 0xF7),
                PieBorderColor:     tcell.NewRGBColor(0x9D, 0x7C, 0xD8),
                PieTitleColor:      tcell.NewRGBColor(0x9D, 0x7C, 0xD8),
                StatusBarTextColor: tcell.ColorWhite,
                StatusBarBgColor:   tcell.NewRGBColor(0x24, 0x28, 0x3B),
                WarningColor:       tcell.NewRGBColor(0xE0, 0xAF, 0x68), // yellow
                SuccessColor:       tcell.NewRGBColor(0x9E, 0xCE, 0x6A), // green,
        },
        // New btop-inspired themes
        "Nord": {
                BorderColor:        tcell.NewRGBColor(0x5E, 0x81, 0xAC),
                TitleColor:         tcell.NewRGBColor(0x5E, 0x81, 0xAC),
                PrimaryColor:       tcell.NewRGBColor(0x88, 0xC0, 0xD0),
                SecondaryColor:     tcell.NewRGBColor(0x81, 0xA1, 0xC1),
                PieBorderColor:     tcell.NewRGBColor(0x5E, 0x81, 0xAC),
                PieTitleColor:      tcell.NewRGBColor(0x5E, 0x81, 0xAC),
                StatusBarTextColor: tcell.NewRGBColor(0xD8, 0xDE, 0xE9),
                StatusBarBgColor:   tcell.NewRGBColor(0x2E, 0x34, 0x40),
                WarningColor:       tcell.NewRGBColor(0xEB, 0xCB, 0x8B), // yellow
                SuccessColor:       tcell.NewRGBColor(0xA3, 0xBE, 0x8C), // green,
        },
        "Gruvbox": {
                BorderColor:        tcell.NewRGBColor(0xFE, 0x80, 0x19),
                TitleColor:         tcell.NewRGBColor(0xFE, 0x80, 0x19),
                PrimaryColor:       tcell.NewRGBColor(0xB8, 0xBB, 0x26),
                SecondaryColor:     tcell.NewRGBColor(0xFA, 0xBD, 0x2F),
                PieBorderColor:     tcell.NewRGBColor(0xFE, 0x80, 0x19),
                PieTitleColor:      tcell.NewRGBColor(0xFE, 0x80, 0x19),
                StatusBarTextColor: tcell.NewRGBColor(0xEB, 0xDB, 0xB2),
                StatusBarBgColor:   tcell.NewRGBColor(0x28, 0x28, 0x28),
                WarningColor:       tcell.NewRGBColor(0xFA, 0xBD, 0x2F), // yellow
                SuccessColor:       tcell.NewRGBColor(0xB8, 0xBB, 0x26), // green,
        },
        "Catppuccin": {
                BorderColor:        tcell.NewRGBColor(0xF5, 0xC2, 0xE7),
                TitleColor:         tcell.NewRGBColor(0xF5, 0xC2, 0xE7),
                PrimaryColor:       tcell.NewRGBColor(0x89, 0xDC, 0xEB),
                SecondaryColor:     tcell.NewRGBColor(0xF5, 0xE0, 0xDC),
                PieBorderColor:     tcell.NewRGBColor(0xF5, 0xC2, 0xE7),
                PieTitleColor:      tcell.NewRGBColor(0xF5, 0xC2, 0xE7),
                StatusBarTextColor: tcell.NewRGBColor(0xCD, 0xD6, 0xF4),
                StatusBarBgColor:   tcell.NewRGBColor(0x1E, 0x1E, 0x2E),
                WarningColor:       tcell.NewRGBColor(0xF9, 0xE2, 0xAF), // yellow
                SuccessColor:       tcell.NewRGBColor(0xA6, 0xE3, 0xA1), // green,
        },
        "One Dark": {
                BorderColor:        tcell.NewRGBColor(0x61, 0xAF, 0xEF),
                TitleColor:         tcell.NewRGBColor(0x61, 0xAF, 0xEF),
                PrimaryColor:       tcell.NewRGBColor(0x98, 0xC3, 0x79),
                SecondaryColor:     tcell.NewRGBColor(0xE0, 0x6C, 0x75),
                PieBorderColor:     tcell.NewRGBColor(0x61, 0xAF, 0xEF),
                PieTitleColor:      tcell.NewRGBColor(0x61, 0xAF, 0xEF),
                StatusBarTextColor: tcell.NewRGBColor(0xAB, 0xB2, 0xBF),
                StatusBarBgColor:   tcell.NewRGBColor(0x28, 0x2C, 0x34),
                WarningColor:       tcell.NewRGBColor(0xE5, 0xC0, 0x7B), // yellow
                SuccessColor:       tcell.NewRGBColor(0x98, 0xC3, 0x79), // green,
        },
}

// DetectAutoTheme returns a theme name based on the terminal background color from $COLORFGBG
func DetectAutoTheme() string <span class="cov0" title="0">{
    val := os.Getenv("COLORFGBG")
    parts := strings.Split(val, ";")
    if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
        b, err := strconv.Atoi(parts[len(parts)-1])
        if err == nil </span><span class="cov0" title="0">{
            if b &lt; 7 </span><span class="cov0" title="0">{
                return "Dark+"
            }</span>
            <span class="cov0" title="0">return "Light+"</span>
        }
    }
    // default to dark theme
    <span class="cov0" title="0">return "Dark+"</span>
}

// themeConfig defines JSON/YAML schema for custom themes
type themeConfig struct {
        BorderColor        string `json:"BorderColor" yaml:"BorderColor"`
        TitleColor         string `json:"TitleColor" yaml:"TitleColor"`
        PrimaryColor       string `json:"PrimaryColor" yaml:"PrimaryColor"`
        SecondaryColor     string `json:"SecondaryColor" yaml:"SecondaryColor"`
        PieBorderColor     string `json:"PieBorderColor" yaml:"PieBorderColor"`
        PieTitleColor      string `json:"PieTitleColor" yaml:"PieTitleColor"`
        StatusBarTextColor string `json:"StatusBarTextColor" yaml:"StatusBarTextColor"`
        StatusBarBgColor   string `json:"StatusBarBgColor" yaml:"StatusBarBgColor"`
}

// LoadThemes loads custom themes from JSON or YAML file and merges into Themes
func LoadThemes(path string) error <span class="cov3" title="2">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">ext := strings.ToLower(filepath.Ext(path))
        var raw map[string]themeConfig
        switch ext </span>{
        case ".json":<span class="cov1" title="1">
                err = json.Unmarshal(data, &amp;raw)</span>
        case ".yaml", ".yml":<span class="cov1" title="1">
                err = yaml.Unmarshal(data, &amp;raw)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported theme file type: %s", ext)</span>
        }
        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">for name, cfg := range raw </span><span class="cov3" title="2">{
                t := Theme{
                        BorderColor:        parseHex(cfg.BorderColor),
                        TitleColor:         parseHex(cfg.TitleColor),
                        PrimaryColor:       parseHex(cfg.PrimaryColor),
                        SecondaryColor:     parseHex(cfg.SecondaryColor),
                        PieBorderColor:     parseHex(cfg.PieBorderColor),
                        PieTitleColor:      parseHex(cfg.PieTitleColor),
                        StatusBarTextColor: parseHex(cfg.StatusBarTextColor),
                        StatusBarBgColor:   parseHex(cfg.StatusBarBgColor),
                }
                Themes[name] = t
        }</span>
        <span class="cov3" title="2">return nil</span>
}

// init calculates gradients for all built-in themes
func init() <span class="cov1" title="1">{
        for name, theme := range Themes </span><span class="cov9" title="14">{
                theme.calculateGradients()
                Themes[name] = theme
        }</span>
}

// ExportTheme writes the theme definition for the given theme name to a JSON or YAML file.
func ExportTheme(name, path string) error <span class="cov3" title="2">{
        t, ok := Themes[name]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("theme %s not found", name)
        }</span>
        <span class="cov3" title="2">cfg := themeConfig{
                BorderColor:        colorToHex(t.BorderColor),
                TitleColor:         colorToHex(t.TitleColor),
                PrimaryColor:       colorToHex(t.PrimaryColor),
                SecondaryColor:     colorToHex(t.SecondaryColor),
                PieBorderColor:     colorToHex(t.PieBorderColor),
                PieTitleColor:      colorToHex(t.PieTitleColor),
                StatusBarTextColor: colorToHex(t.StatusBarTextColor),
                StatusBarBgColor:   colorToHex(t.StatusBarBgColor),
        }
        raw := map[string]themeConfig{name: cfg}
        ext := strings.ToLower(filepath.Ext(path))
        var data []byte
        var err error
        switch ext </span>{
        case ".json":<span class="cov1" title="1">
                data, err = json.MarshalIndent(raw, "", "  ")</span>
        case ".yaml", ".yml":<span class="cov1" title="1">
                data, err = yaml.Marshal(raw)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported export file type: %s", ext)</span>
        }
        <span class="cov3" title="2">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="2">return os.WriteFile(path, data, 0644)</span>
}

// colorToHex converts a tcell.Color to a hex string (#rrggbb).
func colorToHex(c tcell.Color) string <span class="cov10" title="18">{
        r, g, b := c.RGB()
        return fmt.Sprintf("#%02x%02x%02x", r, g, b)
}</span>

// parseHex parses a hex color string (#rrggbb) into tcell.Color; defaults white on error
func parseHex(s string) tcell.Color <span class="cov9" title="16">{
        s = strings.TrimPrefix(s, "#")
        if len(s) != 6 </span><span class="cov0" title="0">{
                return tcell.ColorWhite
        }</span>
        <span class="cov9" title="16">rv, err1 := strconv.ParseInt(s[0:2], 16, 32)
        gv, err2 := strconv.ParseInt(s[2:4], 16, 32)
        bv, err3 := strconv.ParseInt(s[4:6], 16, 32)
        if err1 != nil || err2 != nil || err3 != nil </span><span class="cov0" title="0">{
                return tcell.ColorWhite
        }</span>
        <span class="cov9" title="16">return tcell.NewRGBColor(int32(rv), int32(gv), int32(bv))</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package ui

import (
        "encoding/json"
        "fmt"
        "math"
        "net/http"
        "os"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/google/gopacket"
        "github.com/google/gopacket/layers"
        "github.com/shirou/gopsutil/v3/cpu"
        "github.com/shirou/gopsutil/v3/mem"
        "github.com/gdamore/tcell/v2"
        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/graph"
        "github.com/user/netmon/pkg/netcap"
        "github.com/user/netmon/pkg/ui/i18n"
        "github.com/user/netmon/pkg/utils"
)

// UI represents the terminal user interface
type UI struct {
        app              *tview.Application
        pages            *tview.Pages
        networkMonitor   *netcap.NetworkMonitor
        interfaceList    *tview.List
        statsView        *tview.TextView
        connectionTable  *tview.Table
        detailView       *tview.TextView
        statusBar        *tview.TextView
        trafficGraph     *graph.MultiGraph
        networkGraph     *graph.GraphWidget
        cpuMemGraph      *graph.GraphWidget
        protocolView     *tview.TextView
        selectedIface    string
        selectedConnection *netcap.Connection // currently selected connection
        updateInterval   time.Duration
        stopChan         chan struct{}
        connections      []*netcap.Connection
        sortBy           string
        sortAscending    bool
        filterString     string
        bpfString        string           // current BPF filter
        packetTable      *tview.Table     // raw packet buffer view
        histView         *tview.TextView  // packet size histogram view
        dnsHttpView      *tview.TextView  // HTTP/DNS summary view
        geoView          *tview.Table     // Geo mapping view
        geoCache         map[string]*GeoLocation // cache IP-&gt;location data
        geoMapView       *tview.TextView  // ASCII world map view
        helpView         *tview.TextView  // Help screen view
        rawView         *tview.TextView  // raw packet hex view
        rawDumpLines    []string         // stored lines for search
        // Traffic rate calculation
        lastBytesIn      uint64
        lastBytesOut     uint64
        lastUpdateTime   time.Time
        panels           []*panel
        servicePieView   *tview.TextView
        protocolPieView  *tview.TextView
        securePieView    *tview.TextView
        ifaceStatsView   *tview.Table
        theme            Theme
        styleName        string
        paused           bool
        currentLayout    int
        layoutPresets    []string
        graphStyle       graph.GraphStyle
        markedConnections map[string]bool // Track marked connections for bulk operations
        connectionHistory map[string][]float64 // Track bandwidth history for sparklines
        recording         bool
        recordingStart    time.Time
        sessionData       *SessionRecording
        plugins           []PluginInfo
        pluginView        *tview.TextView
        showPlugins       bool
        selectedPlugin    int
        uiMutex           sync.Mutex   // Protect UI operations
        borderStyle       string       // Current border style
        borderAnimation   string       // Border animation type
        animationTicker   *time.Ticker // Animation update ticker
        animationFrame    int          // Current animation frame
        mainGrid          *StyledGrid  // Reference to main grid for animation updates
        startupVizID      string       // Visualization to show on startup
        startupDashboard  string       // Dashboard to show on startup
        startupFullscreen bool         // Start in fullscreen mode
}

// panel represents a UI section that can be toggled and positioned in the grid
type panel struct {
        id        string
        primitive tview.Primitive
        visible   bool
        row, col, rowSpan, colSpan int
        borderStyle string // Custom border style for this panel
        borderAnimation string // Custom animation for this panel
}

// PluginInfo stores information about a loaded plugin
type PluginInfo struct {
        Name        string
        Description string
        Output      []string
        LastUpdate  time.Time
        Status      string
}

// GeoLocation stores detailed geographic information
type GeoLocation struct {
        CountryCode string    `json:"countryCode"`
        Country     string    `json:"country"`
        Region      string    `json:"regionName"`
        City        string    `json:"city"`
        Latitude    float64   `json:"lat"`
        Longitude   float64   `json:"lon"`
        ISP         string    `json:"isp"`
        Org         string    `json:"org"`
        AS          string    `json:"as"`
        LastUpdate  time.Time
}

// SessionRecording stores recorded network session data
type SessionRecording struct {
        StartTime     time.Time                    `json:"start_time"`
        EndTime       time.Time                    `json:"end_time"`
        Interface     string                       `json:"interface"`
        Snapshots     []NetworkSnapshot            `json:"snapshots"`
        Events        []SessionEvent               `json:"events"`
        PacketCount   int                          `json:"packet_count"`
        TotalBytes    uint64                       `json:"total_bytes"`
}

// NetworkSnapshot captures network state at a point in time
type NetworkSnapshot struct {
        Timestamp   time.Time                      `json:"timestamp"`
        Connections []*netcap.Connection           `json:"connections"`
        Stats       map[string]*netcap.InterfaceStats `json:"stats"`
        BandwidthIn  float64                       `json:"bandwidth_in"`
        BandwidthOut float64                       `json:"bandwidth_out"`
}

// SessionEvent records user interactions and system events
type SessionEvent struct {
        Timestamp time.Time `json:"timestamp"`
        Type      string    `json:"type"`
        Details   string    `json:"details"`
}

// UIProfile stores UI configuration for save/load
type UIProfile struct {
        Name            string                 `json:"name"`
        Theme           string                 `json:"theme"`
        BorderStyle     string                 `json:"border_style"`
        BorderAnimation string                 `json:"border_animation"`
        LayoutPreset    int                    `json:"layout_preset"`
        UpdateInterval  string                 `json:"update_interval"`
        GraphStyle      string                 `json:"graph_style"`
        PanelStates     map[string]bool        `json:"panel_states"`
        GradientEnabled bool                   `json:"gradient_enabled"`
        ShowLegend      bool                   `json:"show_legend"`
        DashboardLayout *DashboardLayout       `json:"dashboard_layout,omitempty"`
        CreatedAt       time.Time              `json:"created_at"`
        UpdatedAt       time.Time              `json:"updated_at"`
}

// NewUI creates a new terminal UI
func NewUI(networkMonitor *netcap.NetworkMonitor) *UI <span class="cov3" title="4">{
        ui := &amp;UI{
                app:            tview.NewApplication(),
                networkMonitor: networkMonitor,
                updateInterval: 1 * time.Second,
                stopChan:       make(chan struct{}),
                sortBy:         "bytes",
                sortAscending:  false,
                theme:          Themes["Dark+"],
                styleName:      "Standard",
                geoCache:       make(map[string]*GeoLocation),
                currentLayout:  0,
                layoutPresets:  []string{"Default", "Compact", "Detailed", "Minimal"},
                graphStyle:     graph.StyleBraille,
                markedConnections: make(map[string]bool),
                connectionHistory: make(map[string][]float64),
                borderStyle:    "Single",
                borderAnimation: "None",
        }

        ui.initComponents()
        ui.setupUI()
        
        // Enable mouse support
        ui.app.EnableMouse(true)
        ui.setupMouseHandlers()
        // Initialize pie-chart panels
        ui.servicePieView = tview.NewTextView().SetDynamicColors(true)
        ui.servicePieView.SetBorder(true).SetBorderColor(ui.theme.PieBorderColor).SetTitleColor(ui.theme.PieTitleColor).SetTitle(i18n.T("service_usage_pie"))
        ui.protocolPieView = tview.NewTextView().SetDynamicColors(true)
        ui.protocolPieView.SetBorder(true).SetBorderColor(ui.theme.PieBorderColor).SetTitleColor(ui.theme.PieTitleColor).SetTitle(i18n.T("protocol_usage_pie"))
        ui.securePieView = tview.NewTextView().SetDynamicColors(true)
        ui.securePieView.SetBorder(true).SetBorderColor(ui.theme.PieBorderColor).SetTitleColor(ui.theme.PieTitleColor).SetTitle(i18n.T("secure_nonsecure_pie"))
        // Interface counters page as table
        ui.ifaceStatsView = tview.NewTable().SetBorders(false)
        ui.ifaceStatsView.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor).SetTitle(i18n.T("interface_counters"))
        ui.ifaceStatsView.SetFixed(1, 0)
        // Packet size histogram view
        ui.histView = tview.NewTextView().SetDynamicColors(true)
        ui.histView.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor).SetTitle(i18n.T("packet_size_histogram"))
        // HTTP/DNS summary view
        ui.dnsHttpView = tview.NewTextView().SetDynamicColors(true)
        ui.dnsHttpView.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor).SetTitle(i18n.T("http_dns_summary"))
        // Geo mapping view: will list remote IPs and country codes
        ui.geoView = tview.NewTable().SetBorders(false)
        ui.geoView.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor).SetTitle(i18n.T("geo_mapping"))
        ui.geoView.SetFixed(1, 0)
        // Geo map view for ASCII world map
        ui.geoMapView = tview.NewTextView().SetDynamicColors(true).SetWrap(false)
        ui.geoMapView.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor).SetTitle(i18n.T("world_map"))
        // Help view
        ui.helpView = tview.NewTextView().SetDynamicColors(true).SetWrap(true)
        ui.helpView.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor).SetTitle(i18n.T("help"))
        // Raw packet hex view
        ui.rawView = tview.NewTextView().SetDynamicColors(true).SetWrap(false)
        ui.rawView.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor).SetTitle(i18n.T("raw_packet"))
        // Plugin view
        ui.pluginView = tview.NewTextView().SetDynamicColors(true).SetWrap(true)
        ui.pluginView.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor).SetTitle(i18n.T("plugins"))
        // Define panel layout (interfaces column + data panels)
        ui.panels = []*panel{
                {id: "interfaces", primitive: ui.interfaceList, visible: true, row: 0, col: 0, rowSpan: 4, colSpan: 1},
                {id: "stats", primitive: ui.statsView, visible: true, row: 0, col: 1, rowSpan: 1, colSpan: 1},
                {id: "traffic", primitive: ui.trafficGraph, visible: true, row: 0, col: 2, rowSpan: 1, colSpan: 1},
                {id: "protocol", primitive: ui.protocolView, visible: true, row: 0, col: 3, rowSpan: 1, colSpan: 1},
                {id: "servicePie", primitive: ui.servicePieView, visible: true, row: 1, col: 1, rowSpan: 1, colSpan: 1},
                {id: "protocolPie", primitive: ui.protocolPieView, visible: true, row: 1, col: 2, rowSpan: 1, colSpan: 1},
                {id: "securePie", primitive: ui.securePieView, visible: true, row: 1, col: 3, rowSpan: 1, colSpan: 1},
                {id: "connections", primitive: ui.connectionTable, visible: true, row: 2, col: 1, rowSpan: 1, colSpan: 3},
                {id: "details", primitive: ui.detailView, visible: true, row: 3, col: 1, rowSpan: 1, colSpan: 3},
        }
        // Build the initial grid
        ui.rebuildLayout()
        return ui
}</span>

// RegisterPlugin registers a plugin with the UI
func (ui *UI) RegisterPlugin(name, description string) <span class="cov0" title="0">{
        plugin := PluginInfo{
                Name:        name,
                Description: description,
                Output:      []string{},
                LastUpdate:  time.Now(),
                Status:      "Active",
        }
        ui.plugins = append(ui.plugins, plugin)
}</span>

// UpdatePluginOutput updates the output for a specific plugin
func (ui *UI) UpdatePluginOutput(name string, output string) <span class="cov0" title="0">{
        for i := range ui.plugins </span><span class="cov0" title="0">{
                if ui.plugins[i].Name == name </span><span class="cov0" title="0">{
                        ui.plugins[i].Output = append(ui.plugins[i].Output, output)
                        // Keep only last 100 lines
                        if len(ui.plugins[i].Output) &gt; 100 </span><span class="cov0" title="0">{
                                ui.plugins[i].Output = ui.plugins[i].Output[len(ui.plugins[i].Output)-100:]
                        }</span>
                        <span class="cov0" title="0">ui.plugins[i].LastUpdate = time.Now()
                        break</span>
                }
        }
}

// SetPluginStatus updates the status of a plugin
func (ui *UI) SetPluginStatus(name string, status string) <span class="cov0" title="0">{
        for i := range ui.plugins </span><span class="cov0" title="0">{
                if ui.plugins[i].Name == name </span><span class="cov0" title="0">{
                        ui.plugins[i].Status = status
                        break</span>
                }
        }
}

// initComponents initializes all UI primitives
func (ui *UI) initComponents() <span class="cov3" title="4">{
        // Interface list
        ui.interfaceList = tview.NewList().ShowSecondaryText(false)
        ui.interfaceList.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitle(i18n.T("interfaces"))
        // Stats view
        ui.statsView = tview.NewTextView().SetDynamicColors(true)
        ui.statsView.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitle(i18n.T("network_statistics"))
        // Traffic graph
        ui.trafficGraph = graph.NewMultiGraph()
        ui.trafficGraph.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitle(i18n.T("network_traffic"))
        // Network graph widget
        ui.networkGraph = graph.NewGraphWidget()
        ui.networkGraph.SetTitle(i18n.T("bandwidth"))
        ui.networkGraph.SetColor(ui.theme.PrimaryColor)
        ui.networkGraph.SetSecondaryColor(ui.theme.SecondaryColor)
        ui.networkGraph.SetLabels("In", "Out")
        ui.networkGraph.SetUnit("B/s")
        ui.networkGraph.SetDataFunc(ui.getNetworkRates)
        ui.networkGraph.SetSampleInterval(1 * time.Second)
        ui.networkGraph.SetHistoryDuration(2 * time.Minute)
        ui.networkGraph.SetStyle(ui.graphStyle)
        ui.trafficGraph.AddGraph(ui.networkGraph)
        // CPU &amp; Memory usage graph widget
        ui.cpuMemGraph = graph.NewGraphWidget()
        ui.cpuMemGraph.SetTitle(i18n.T("cpu_mem"))
        ui.cpuMemGraph.SetColor(ui.theme.PrimaryColor)
        ui.cpuMemGraph.SetSecondaryColor(ui.theme.SecondaryColor)
        ui.cpuMemGraph.SetLabels("CPU%", "Mem%")
        ui.cpuMemGraph.SetUnit("%")
        ui.cpuMemGraph.SetDataFunc(ui.getCPUMemory)
        ui.cpuMemGraph.SetSampleInterval(1 * time.Second)
        ui.cpuMemGraph.SetHistoryDuration(2 * time.Minute)
        ui.cpuMemGraph.SetStyle(ui.graphStyle)
        ui.trafficGraph.AddGraph(ui.cpuMemGraph)
        // Protocol view
        ui.protocolView = tview.NewTextView().SetDynamicColors(true)
        ui.protocolView.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitle(i18n.T("protocols"))
        // Connection table
        ui.connectionTable = tview.NewTable().SetBorders(false)
        ui.connectionTable.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitle(i18n.T("connections"))
        ui.connectionTable.SetSelectable(true, false)
        // Detail view
        ui.detailView = tview.NewTextView().SetDynamicColors(true)
        ui.detailView.SetBorder(true).SetBorderColor(ui.theme.BorderColor).SetTitle(i18n.T("connection_details"))
        // Status bar
        ui.statusBar = tview.NewTextView().SetDynamicColors(true)
        ui.statusBar.SetTextAlign(tview.AlignCenter)
        ui.statusBar.SetBackgroundColor(ui.theme.StatusBarBgColor)
}</span>

// setupUI initializes the UI components
func (ui *UI) setupUI() <span class="cov3" title="4">{
        // Create the pages for different views
        ui.pages = tview.NewPages()

        // Set up key bindings
        ui.setupKeyBindings()

        // Set the root and focus
        ui.app.SetRoot(ui.pages, true)
        // Focus on interface list by default
        ui.app.SetFocus(ui.interfaceList)
}</span>

// setupKeyBindings configures keyboard shortcuts
func (ui *UI) setupKeyBindings() <span class="cov3" title="4">{
        ui.app.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                // Global key bindings
                switch event.Key() </span>{
                case tcell.KeyEscape:<span class="cov0" title="0">
                        // If on a secondary page, return to main
                        if ui.pages.HasPage("help") </span><span class="cov0" title="0">{
                                name, _ := ui.pages.GetFrontPage()
                                if name == "help" </span><span class="cov0" title="0">{
                                        ui.pages.SwitchToPage("main")
                                        return nil
                                }</span>
                        }
                case tcell.KeyTab:<span class="cov0" title="0">
                        // Cycle focus between panels
                        if ui.interfaceList.HasFocus() </span><span class="cov0" title="0">{
                                ui.app.SetFocus(ui.connectionTable)
                        }</span> else<span class="cov0" title="0"> if ui.connectionTable.HasFocus() </span><span class="cov0" title="0">{
                                ui.app.SetFocus(ui.interfaceList)
                        }</span> else<span class="cov0" title="0"> {
                                ui.app.SetFocus(ui.interfaceList)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                // Handle runes - btop-style single key shortcuts
                <span class="cov0" title="0">switch event.Rune() </span>{
                case 'q', 'Q':<span class="cov0" title="0">
                        // Show exit menu instead of immediate quit
                        ui.showExitMenu()
                        return nil</span>
                case '?', 'h', 'H':<span class="cov0" title="0">
                        // Help screen
                        name, _ := ui.pages.GetFrontPage()
                        if name == "help" </span><span class="cov0" title="0">{
                                ui.pages.SwitchToPage("main")
                        }</span> else<span class="cov0" title="0"> {
                                ui.showHelpPage()
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                case 'o', 'O':<span class="cov0" title="0">
                        // Options/settings menu - only show on main page
                        if ui.pages != nil </span><span class="cov0" title="0">{
                                if name, _ := ui.pages.GetFrontPage(); name == "main" </span><span class="cov0" title="0">{
                                        ui.showOptionsMenu()
                                }</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                case 'p', 'P':<span class="cov0" title="0">
                        // Cycle through layout presets
                        ui.cycleLayoutPreset()
                        return nil</span>
                case '+', '=':<span class="cov0" title="0">
                        // Increase update speed
                        ui.decreaseUpdateInterval()
                        return nil</span>
                case '-', '_':<span class="cov0" title="0">
                        // Decrease update speed
                        ui.increaseUpdateInterval()
                        return nil</span>
                case 'r':<span class="cov0" title="0">
                        // Force refresh
                        ui.updateData()
                        return nil</span>
                case 's', 'S':<span class="cov0" title="0">
                        // Sort options
                        ui.showSortOptions()
                        return nil</span>
                case 'f', 'F':<span class="cov0" title="0">
                        // Filter
                        ui.showFilterInput()
                        return nil</span>
                case 'b', 'B':<span class="cov0" title="0">
                        // BPF filter
                        ui.showBpfInput()
                        return nil</span>
                case 'n':<span class="cov0" title="0">
                        // Next interface
                        ui.selectNextInterface()
                        return nil</span>
                case 'N':<span class="cov0" title="0">
                        // Previous interface
                        ui.selectPreviousInterface()
                        return nil</span>
                case 't', 'T':<span class="cov0" title="0">
                        // Toggle graph style
                        ui.cycleGraphStyle()
                        return nil</span>
                case 'e', 'E':<span class="cov0" title="0">
                        // Export data
                        ui.showExportMenu()
                        return nil</span>
                case 'u', 'U':<span class="cov0" title="0">
                        // UI Profiles menu
                        ui.showProfilesMenu()
                        return nil</span>
                case 'c', 'C':<span class="cov0" title="0">
                        // Clear filters
                        ui.clearFilters()
                        return nil</span>
                case ' ':<span class="cov0" title="0">
                        // Pause/resume updates
                        ui.togglePause()
                        return nil</span>
                case 'R':<span class="cov0" title="0">
                        // Start/stop recording
                        ui.toggleRecording()
                        return nil</span>
                case 'L':<span class="cov0" title="0">
                        // Load and replay session
                        ui.showReplayMenu()
                        return nil</span>
                case 'G':<span class="cov0" title="0">
                        // Show plugins view
                        ui.showPluginsPage()
                        return nil</span>
                case '&amp;':<span class="cov0" title="0">
                        // Show border styles preview
                        ui.showBorderStylesPreview()
                        return nil</span>
                // Legacy shortcuts for specific pages
                case 'i':<span class="cov0" title="0">
                        ui.showIfaceStatsPage()
                        return nil</span>
                case 'd':<span class="cov0" title="0">
                        // Dashboard menu
                        ui.showDashboardMenu()
                        return nil</span>
                case 'g':<span class="cov0" title="0">
                        ui.showGeoPage()
                        return nil</span>
                }

                // Panel toggle keys 0–9 (0 = interfaces)
                <span class="cov0" title="0">switch event.Rune() </span>{
                case '0':<span class="cov0" title="0"> ui.togglePanel("interfaces")</span>
                case '1':<span class="cov0" title="0"> ui.togglePanel("stats")</span>
                case '2':<span class="cov0" title="0"> ui.togglePanel("traffic")</span>
                case '3':<span class="cov0" title="0"> ui.togglePanel("protocol")</span>
                case '4':<span class="cov0" title="0"> ui.togglePanel("servicePie")</span>
                case '5':<span class="cov0" title="0"> ui.togglePanel("protocolPie")</span>
                case '6':<span class="cov0" title="0"> ui.togglePanel("securePie")</span>
                case '7':<span class="cov0" title="0"> ui.togglePanel("connections")</span>
                case '8':<span class="cov0" title="0"> ui.togglePanel("details")</span>
                case '9':<span class="cov0" title="0"> ui.togglePanel("packets")</span>
                }

                <span class="cov0" title="0">return event</span>
        })

        // Interface list selection changed
        <span class="cov3" title="4">ui.interfaceList.SetChangedFunc(func(index int, mainText, secondaryText string, shortcut rune) </span><span class="cov0" title="0">{
                if index &gt;= 0 </span><span class="cov0" title="0">{
                        ui.selectedIface = mainText
                        ui.updateData()
                }</span>
        })

        // Connection table selection changed
        <span class="cov3" title="4">ui.connectionTable.SetSelectionChangedFunc(func(row, column int) </span><span class="cov0" title="0">{
                if row &gt; 0 &amp;&amp; row-1 &lt; len(ui.connections) </span><span class="cov0" title="0">{
                        ui.selectedConnection = ui.connections[row-1]
                        // Update details in a safe way
                        go ui.app.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                                ui.showConnectionDetails(ui.selectedConnection)
                        }</span>)
                } else<span class="cov0" title="0"> {
                        ui.selectedConnection = nil
                        go ui.app.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                                ui.detailView.SetText("")
                        }</span>)
                }
        })
        
        // Add connection table keyboard shortcuts
        <span class="cov3" title="4">ui.connectionTable.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                if ui.selectedConnection == nil </span><span class="cov0" title="0">{
                        return event
                }</span>
                
                <span class="cov0" title="0">switch event.Key() </span>{
                case tcell.KeyEnter:<span class="cov0" title="0">
                        // Show detailed packet view
                        ui.showConnectionPacketsPage()
                        return nil</span>
                case tcell.KeyDelete:<span class="cov0" title="0">
                        // Show kill connection dialog
                        ui.showKillConnectionDialog()
                        return nil</span>
                }
                
                <span class="cov0" title="0">switch event.Rune() </span>{
                case 'k', 'K':<span class="cov0" title="0">
                        // Kill connection
                        ui.showKillConnectionDialog()
                        return nil</span>
                case 'e', 'E':<span class="cov0" title="0">
                        // Export connection data
                        ui.showConnectionExportMenu()
                        return nil</span>
                case 'x', 'X':<span class="cov0" title="0">
                        // Mark/unmark connection
                        ui.toggleConnectionMark()
                        return nil</span>
                case 'a', 'A':<span class="cov0" title="0">
                        // Select all connections
                        ui.selectAllConnections()
                        return nil</span>
                }
                
                <span class="cov0" title="0">return event</span>
        })
}

// updateAnimationTicker manages the animation update ticker
func (ui *UI) updateAnimationTicker() <span class="cov0" title="0">{
        // Stop existing ticker if any
        if ui.animationTicker != nil </span><span class="cov0" title="0">{
                ui.animationTicker.Stop()
                ui.animationTicker = nil
        }</span>
        
        // Start new ticker if animation is enabled
        <span class="cov0" title="0">if ui.borderAnimation != "None" &amp;&amp; ui.borderAnimation != "" </span><span class="cov0" title="0">{
                ui.animationTicker = time.NewTicker(100 * time.Millisecond)
                go func() </span><span class="cov0" title="0">{
                        for range ui.animationTicker.C </span><span class="cov0" title="0">{
                                ui.animationFrame++
                                ui.app.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                                        if ui.mainGrid != nil </span><span class="cov0" title="0">{
                                                ui.mainGrid.SetAnimationFrame(ui.animationFrame)
                                        }</span>
                                })
                        }
                }()
        }
}

// rebuildLayout re-constructs the main page grid based on panel settings
func (ui *UI) rebuildLayout() <span class="cov3" title="4">{
    grid := NewStyledGrid().
        SetBorders(true).
        SetBorderStyle(ui.borderStyle).
        SetBorderColor(ui.theme.BorderColor).
        SetAnimation(ui.borderAnimation).
        SetAnimationFrame(ui.animationFrame)
    
    // Store reference to main grid for animation updates
    ui.mainGrid = grid

    // determine if interfaces panel is visible
    ifaceVisible := false
    for _, p := range ui.panels </span><span class="cov3" title="4">{
        if p.id == "interfaces" &amp;&amp; p.visible </span><span class="cov3" title="4">{
            ifaceVisible = true
            break</span>
        }
    }

    // dynamic tiling: identify visible non-interface rows
    <span class="cov3" title="4">rowsSet := map[int]bool{}
    for _, p := range ui.panels </span><span class="cov7" title="36">{
        if p.visible &amp;&amp; p.id != "interfaces" </span><span class="cov7" title="32">{
            rowsSet[p.row] = true
        }</span>
    }
    // sort and collect rows
    <span class="cov3" title="4">visibleRows := make([]int, 0, len(rowsSet))
    for r := range rowsSet </span><span class="cov6" title="16">{
        visibleRows = append(visibleRows, r)
    }</span>
    <span class="cov3" title="4">sort.Ints(visibleRows)
    totalRows := len(visibleRows)
    if totalRows == 0 </span><span class="cov0" title="0">{
        totalRows = 1
    }</span>
    // count regular panels per row
    <span class="cov3" title="4">colCounts := map[int]int{}
    for _, p := range ui.panels </span><span class="cov7" title="36">{
        if p.visible &amp;&amp; p.id != "interfaces" &amp;&amp; p.colSpan == 1 </span><span class="cov7" title="24">{
            colCounts[p.row]++
        }</span>
    }
    <span class="cov3" title="4">maxCols := 0
    for _, c := range colCounts </span><span class="cov4" title="8">{
        if c &gt; maxCols </span><span class="cov3" title="4">{
            maxCols = c
        }</span>
    }
    <span class="cov3" title="4">if maxCols == 0 </span><span class="cov0" title="0">{
        maxCols = 1
    }</span>
    // define grid sizes
    <span class="cov3" title="4">rows := make([]int, totalRows)
    grid.SetRows(rows...)
    dataOffset := 1
    if !ifaceVisible </span><span class="cov0" title="0">{
        dataOffset = 0
    }</span>
    <span class="cov3" title="4">cols := make([]int, maxCols+dataOffset)
    if ifaceVisible </span><span class="cov3" title="4">{
        cols[0] = 20
        for i := 1; i &lt; len(cols); i++ </span><span class="cov5" title="12">{
            cols[i] = 0
        }</span>
    } else<span class="cov0" title="0"> {
        for i := 0; i &lt; len(cols); i++ </span><span class="cov0" title="0">{
            cols[i] = 0
        }</span>
    }
    <span class="cov3" title="4">grid.SetColumns(cols...)

    // place panels
    for _, p := range ui.panels </span><span class="cov7" title="36">{
        if !p.visible </span><span class="cov0" title="0">{
            continue</span>
        }
        <span class="cov7" title="36">if p.id == "interfaces" </span><span class="cov3" title="4">{
            if ifaceVisible </span><span class="cov3" title="4">{
                // span all rows in first col
                grid.AddItem(p.primitive, 0, 0, totalRows, 1, 0, 0, true)
            }</span>
            <span class="cov3" title="4">continue</span>
        }
        // map original row to new index
        <span class="cov7" title="32">newRow := 0
        for i, r := range visibleRows </span><span class="cov8" title="64">{
            if r == p.row </span><span class="cov7" title="32">{
                newRow = i
                break</span>
            }
        }
        <span class="cov7" title="32">if p.colSpan &gt; 1 </span><span class="cov4" title="8">{
            // full-width panels except interfaces
            grid.AddItem(p.primitive, newRow, dataOffset, p.rowSpan, maxCols, 0, 0, true)
        }</span> else<span class="cov7" title="24"> {
            // tile single-col panels
            idx := 0
            for _, q := range ui.panels </span><span class="cov10" title="108">{
                if !q.visible || q.id == "interfaces" || q.colSpan &gt; 1 || q.row != p.row </span><span class="cov8" title="60">{
                    continue</span>
                }
                <span class="cov8" title="48">if q.id == p.id </span><span class="cov7" title="24">{
                    break</span>
                }
                <span class="cov7" title="24">idx++</span>
            }
            <span class="cov7" title="24">grid.AddItem(p.primitive, newRow, dataOffset+idx, p.rowSpan, 1, 0, 0, true)</span>
        }
    }
    <span class="cov3" title="4">ui.pages.RemovePage("main")
    ui.pages.AddPage("main", grid, true, true)
    ui.app.SetRoot(ui.pages, true)</span>
}

// togglePanel flips visibility of the named panel and rebuilds layout
func (ui *UI) togglePanel(id string) <span class="cov0" title="0">{
        for _, p := range ui.panels </span><span class="cov0" title="0">{
                if p.id == id </span><span class="cov0" title="0">{
                        p.visible = !p.visible
                        break</span>
                }
        }
        <span class="cov0" title="0">ui.rebuildLayout()</span>
}

// updateData refreshes all UI components with current data
func (ui *UI) updateData() <span class="cov0" title="0">{
        // Start capturing on the selected interface if not already
        if ui.selectedIface != "" </span><span class="cov0" title="0">{
                err := ui.networkMonitor.StartCapture(ui.selectedIface)
                if err != nil &amp;&amp; !strings.Contains(err.Error(), "already capturing") </span><span class="cov0" title="0">{
                        ui.showError(fmt.Sprintf("Error starting capture: %v", err))
                }</span>
                // Apply BPF filter if set
                <span class="cov0" title="0">if ui.bpfString != "" </span><span class="cov0" title="0">{
                        _ = ui.networkMonitor.SetBpfFilter(ui.selectedIface, ui.bpfString)
                }</span>
        }

        <span class="cov0" title="0">ui.updateStatsView()
        ui.updateConnectionHistory()
        ui.updateConnectionTable()
        ui.updateProtocolView()
        ui.updatePieCharts()
        
        // Record snapshot if recording
        if ui.recording </span><span class="cov0" title="0">{
                ui.recordSnapshot()
        }</span>
        
        // Auto-refresh packets page if visible
        <span class="cov0" title="0">if name, _ := ui.pages.GetFrontPage(); name == "packets" </span><span class="cov0" title="0">{
                ui.pages.RemovePage("packets")
                ui.showPacketBufferPage()
        }</span>
        
        // We don't need to manually add data points here anymore
        // The graph widget's goroutine will handle that
}

// updatePieCharts computes counts and updates ASCII pie-chart panels
func (ui *UI) updatePieCharts() <span class="cov0" title="0">{
        buf := ui.networkMonitor.GetPacketBuffer()
        total := len(buf)
        svcCounts := make(map[string]int)
        protoCounts := make(map[string]int)
        secureCounts := map[string]int{"Secure": 0, "NonSecure": 0}
        for _, p := range buf </span><span class="cov0" title="0">{
                svcCounts[p.Service]++
                protoCounts[p.Protocol]++
                if p.Service == "HTTPS" </span><span class="cov0" title="0">{
                        secureCounts["Secure"]++
                }</span> else<span class="cov0" title="0"> {
                        secureCounts["NonSecure"]++
                }</span>
        }
        <span class="cov0" title="0">svcChart := renderStackedPie(ui.servicePieView, svcCounts, total)
        ui.servicePieView.SetText(svcChart)
        ui.servicePieView.ScrollToBeginning()
        protoChart := renderStackedPie(ui.protocolPieView, protoCounts, total)
        ui.protocolPieView.SetText(protoChart)
        ui.protocolPieView.ScrollToBeginning()
        secChart := renderStackedPie(ui.securePieView, secureCounts, total)
        ui.securePieView.SetText(secChart)
        ui.securePieView.ScrollToBeginning()</span>
}

var pieColors = []string{
        "[green]", "[blue]", "[magenta]", "[yellow]", "[red]",
        "[cyan]", "[white]", "[orange]", "[purple]", "[gray]",
}

// renderStackedPie renders pie and legend one above the other, fitting the TextView
func renderStackedPie(tv *tview.TextView, counts map[string]int, total int) string <span class="cov0" title="0">{
        legend := buildLegend(counts, total)
        legendLines := len(strings.Split(strings.TrimRight(legend, "\n"), "\n"))
        _, _, width, height := tv.GetInnerRect()
        // available height for chart area (excluding legend) and minimal width
        chartArea := height - legendLines
        if chartArea &lt; 5 || width &lt; 8 </span><span class="cov0" title="0">{
                // not enough space to draw a circle
                return legend
        }</span>
        // compute max radius by height (chart uses 2*r + 3 lines)
        <span class="cov0" title="0">maxRadiusH := (chartArea - 3) / 2
        // compute max radius by width (chart interior requires 4*r + 4 chars)
        maxRadiusW := (width - 4) / 4
        // choose the smaller radius
        r := maxRadiusH
        if maxRadiusW &lt; r </span><span class="cov0" title="0">{
                r = maxRadiusW
        }</span>
        <span class="cov0" title="0">if r &lt; 1 </span><span class="cov0" title="0">{
                r = 1
        }</span>
        <span class="cov0" title="0">chart := renderTermPieWithRadius(counts, total, r)
        return chart + legend</span>
}

// renderTermPieWithRadius renders a pie chart with a specified radius
func renderTermPieWithRadius(counts map[string]int, total int, radius int) string <span class="cov0" title="0">{
        // handle no data
        if total == 0 || len(counts) == 0 </span><span class="cov0" title="0">{
                return "\n   [gray]No data\n"
        }</span>
        // compute slices
        <span class="cov0" title="0">type slice struct{ start, end float64; color string }
        keys := make([]string, 0, len(counts))
        for k := range counts </span><span class="cov0" title="0">{ keys = append(keys, k) }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        var slices []slice
        current := -math.Pi/2
        if len(keys) == 1 </span><span class="cov0" title="0">{
                // single slice: fill whole pie
                slices = append(slices, slice{-math.Pi, math.Pi, pieColors[0]})
        }</span> else<span class="cov0" title="0"> {
                for i, k := range keys </span><span class="cov0" title="0">{
                        frac := 0.0
                        if total &gt; 0 </span><span class="cov0" title="0">{ frac = float64(counts[k]) / float64(total) }</span>
                        <span class="cov0" title="0">span := frac * 2 * math.Pi
                        slices = append(slices, slice{current, current + span, pieColors[i%len(pieColors)]})
                        current += span</span>
                }
        }
        // draw grid
        <span class="cov0" title="0">var sb strings.Builder
        sb.WriteString("[gray]+" + strings.Repeat("-", radius*4) + "+\n")
        for y := -radius; y &lt;= radius; y++ </span><span class="cov0" title="0">{
                line := ""
                for x := -radius; x &lt;= radius; x++ </span><span class="cov0" title="0">{
                        dx := float64(x) / float64(radius)
                        dy := float64(y) / float64(radius)
                        if dx*dx+dy*dy &gt; 1.0 </span><span class="cov0" title="0">{
                                line += "  "
                                continue</span>
                        }
                        // center label for single-slice
                        <span class="cov0" title="0">ang := math.Atan2(dy, dx)
                        col := "[white]"
                        for i, s := range slices </span><span class="cov0" title="0">{
                                if (s.start &lt;= s.end &amp;&amp; ang &gt;= s.start &amp;&amp; ang &lt; s.end) ||
                                        (s.start &gt; s.end &amp;&amp; (ang &gt;= s.start || ang &lt; s.end)) </span><span class="cov0" title="0">{
                                        col = pieColors[i%len(pieColors)]
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">line += col + "@ "</span>
                }
                // Pad line to fixed width
                <span class="cov0" title="0">for len(line) &lt; (radius*2+1)*2 </span><span class="cov0" title="0">{ line += " " }</span>
                <span class="cov0" title="0">sb.WriteString("|" + line + "|\n")</span>
        }
        <span class="cov0" title="0">sb.WriteString("[gray]+" + strings.Repeat("-", radius*4) + "+\n")
        return sb.String()</span>
}

// buildLegend builds a legend for a pie chart: colored label, percent, and count
func buildLegend(counts map[string]int, total int) string <span class="cov0" title="0">{
        keys := make([]string, 0, len(counts))
        for k := range counts </span><span class="cov0" title="0">{
                keys = append(keys, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        // Collect legend lines and find max width
        lines := make([]string, len(keys))
        maxWidth := 0
        for i, k := range keys </span><span class="cov0" title="0">{
                v := counts[k]
                perc := 0
                if total &gt; 0 </span><span class="cov0" title="0">{ perc = v * 100 / total }</span>
                <span class="cov0" title="0">color := pieColors[i%len(pieColors)]
                line := fmt.Sprintf("%s%s %d%% [%d]", color, k, perc, v)
                lines[i] = line
                if len(line) &gt; maxWidth </span><span class="cov0" title="0">{
                        maxWidth = len(line)
                }</span>
        }
        // Right-align all lines
        <span class="cov0" title="0">var sb strings.Builder
        for _, line := range lines </span><span class="cov0" title="0">{
                pad := maxWidth - len(line)
                sb.WriteString(strings.Repeat(" ", pad) + line + "\n")
        }</span>
        <span class="cov0" title="0">return sb.String()</span>
}

// showSortOptions displays a modal for sorting options
func (ui *UI) showSortOptions() <span class="cov0" title="0">{
    modal := tview.NewModal().SetText(i18n.T("sort_connections_by")).
        AddButtons([]string{i18n.T("bytes"), i18n.T("packets"), i18n.T("last_seen"), i18n.T("cancel")}).
        SetDoneFunc(func(_ int, label string) </span><span class="cov0" title="0">{
            if label != i18n.T("cancel") </span><span class="cov0" title="0">{
                switch label </span>{
                case i18n.T("bytes"):<span class="cov0" title="0">
                    ui.sortBy = "bytes"</span>
                case i18n.T("packets"):<span class="cov0" title="0">
                    ui.sortBy = "packets"</span>
                case i18n.T("last_seen"):<span class="cov0" title="0">
                    ui.sortBy = "time"</span>
                }
                <span class="cov0" title="0">ui.sortAscending = !ui.sortAscending
                ui.updateConnectionTable()</span>
            }
            <span class="cov0" title="0">ui.pages.SwitchToPage("main")</span>
        })
    <span class="cov0" title="0">ui.pages.AddPage("sort", modal, true, true)</span>
}

// showFilterInput displays an input form for filtering connections
func (ui *UI) showFilterInput() <span class="cov0" title="0">{
    ui.showAdvancedFilterDialog()
}</span>

// showBpfInput displays an input form for setting BPF filter
func (ui *UI) showBpfInput() <span class="cov0" title="0">{
    form := tview.NewForm().
        AddInputField(i18n.T("bpf_filter"), ui.bpfString, 40, nil, func(text string) </span><span class="cov0" title="0">{ ui.bpfString = text }</span>).
        AddButton(i18n.T("apply"), func() <span class="cov0" title="0">{ _ = ui.networkMonitor.SetBpfFilter(ui.selectedIface, ui.bpfString); ui.pages.SwitchToPage("main") }</span>).
        AddButton(i18n.T("clear"), func() <span class="cov0" title="0">{ ui.bpfString = ""; _ = ui.networkMonitor.SetBpfFilter(ui.selectedIface, ""); ui.pages.SwitchToPage("main") }</span>).
        AddButton(i18n.T("cancel"), func() <span class="cov0" title="0">{ ui.pages.SwitchToPage("main") }</span>)
    <span class="cov0" title="0">form.SetBorder(true).SetTitle(i18n.T("bpf_filter")).SetTitleAlign(tview.AlignCenter)
    ui.pages.AddPage("bpf", form, true, true)</span>
}

// showPacketBufferPage displays recent captured packets
func (ui *UI) showPacketBufferPage() <span class="cov0" title="0">{
    ui.pages.RemovePage("packets")
    packets := ui.networkMonitor.GetPacketBuffer()
    table := tview.NewTable().SetBorders(false)
    table.SetSelectable(true, false).SetFixed(1, 0)
    table.Select(1, 0)
    table.SetBorder(true).SetTitle(i18n.T("captured_packets"))
    headers := []string{i18n.T("time"), i18n.T("source"), i18n.T("destination"), i18n.T("proto"), i18n.T("service"), i18n.T("length")}
    for i, h := range headers </span><span class="cov0" title="0">{
        table.SetCell(0, i, tview.NewTableCell(h).
            SetTextColor(tcell.ColorYellow).SetSelectable(false))
    }</span>
    <span class="cov0" title="0">for r, p := range packets </span><span class="cov0" title="0">{
        row := r + 1
        table.SetCell(row, 0, tview.NewTableCell(p.Timestamp.Format("15:04:05")))
        table.SetCell(row, 1, tview.NewTableCell(fmt.Sprintf("%s:%d", p.SrcIP, p.SrcPort)))
        table.SetCell(row, 2, tview.NewTableCell(fmt.Sprintf("%s:%d", p.DstIP, p.DstPort)))
        // protocol color
        protoColor := ui.theme.SecondaryColor
        switch p.Protocol </span>{
        case "TCP":<span class="cov0" title="0"> protoColor = tcell.ColorGreen</span>
        case "UDP":<span class="cov0" title="0"> protoColor = tcell.ColorBlue</span>
        case "ICMP":<span class="cov0" title="0"> protoColor = tcell.ColorFuchsia</span>
        }
        <span class="cov0" title="0">table.SetCell(row, 3, tview.NewTableCell(p.Protocol).SetTextColor(protoColor))
        table.SetCell(row, 4, tview.NewTableCell(p.Service))
        table.SetCell(row, 5, tview.NewTableCell(fmt.Sprintf("%d", p.Length)))</span>
    }
    <span class="cov0" title="0">table.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
        switch event.Key() </span>{
        case tcell.KeyEscape:<span class="cov0" title="0">
            ui.pages.SwitchToPage("main")
            return nil</span>
        case tcell.KeyEnter:<span class="cov0" title="0">
            row, _ := table.GetSelection()
            if row &gt; 0 </span><span class="cov0" title="0">{
                ui.showRawPacketPage(row-1)
            }</span>
            <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return event</span>
    })
    <span class="cov0" title="0">ui.pages.AddPage("packets", table, true, true)
    ui.app.SetFocus(table)</span>
}

// showIfaceStatsPage displays interface counters and errors/drops
func (ui *UI) showIfaceStatsPage() <span class="cov0" title="0">{
    ui.pages.RemovePage("ifaceStats")
    table := ui.ifaceStatsView
    table.Clear()
    // Header row
    headers := []string{i18n.T("interface"), i18n.T("in_bytes_packets"), i18n.T("out_bytes_packets"), i18n.T("pcap_recv"), i18n.T("pcap_drop"), i18n.T("pcap_ifdrop")}
    for i, h := range headers </span><span class="cov0" title="0">{
        table.SetCell(0, i, tview.NewTableCell(h).
            SetTextColor(tcell.ColorYellow).
            SetSelectable(false))
    }</span>
    // Data rows
    <span class="cov0" title="0">ifaces, _ := netcap.GetInterfaces()
    statsMap := ui.networkMonitor.GetInterfaceStats()
    for r, iface := range ifaces </span><span class="cov0" title="0">{
        name := iface.Name
        ifStats, ok := statsMap[name]
        if !ok </span><span class="cov0" title="0">{
            ifStats = &amp;netcap.InterfaceStats{Name: name}
        }</span>
        <span class="cov0" title="0">rec, dr, ifdr := 0, 0, 0
        if pStats, err := ui.networkMonitor.GetPcapStats(name); err == nil </span><span class="cov0" title="0">{
            rec = pStats.PacketsReceived
            dr = pStats.PacketsDropped
            ifdr = pStats.PacketsIfDropped
        }</span>
        <span class="cov0" title="0">row := r + 1
        table.SetCell(row, 0, tview.NewTableCell(name))
        table.SetCell(row, 1, tview.NewTableCell(fmt.Sprintf("%s/%d", utils.FormatBytes(ifStats.BytesIn), ifStats.PacketsIn)))
        table.SetCell(row, 2, tview.NewTableCell(fmt.Sprintf("%s/%d", utils.FormatBytes(ifStats.BytesOut), ifStats.PacketsOut)))
        table.SetCell(row, 3, tview.NewTableCell(fmt.Sprintf("%d", rec)))
        table.SetCell(row, 4, tview.NewTableCell(fmt.Sprintf("%d", dr)))
        table.SetCell(row, 5, tview.NewTableCell(fmt.Sprintf("%d", ifdr)))</span>
    }
    <span class="cov0" title="0">table.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
        if event.Key() == tcell.KeyEscape </span><span class="cov0" title="0">{
            ui.pages.SwitchToPage("main")
            return nil
        }</span>
        <span class="cov0" title="0">return event</span>
    })
    <span class="cov0" title="0">ui.pages.AddPage("ifaceStats", table, true, true)
    ui.app.SetFocus(table)</span>
}

// showHistPage displays a packet-size histogram
func (ui *UI) showHistPage() <span class="cov0" title="0">{
    ui.pages.RemovePage("hist")
    buf := ui.networkMonitor.GetPacketBuffer()
    var sb strings.Builder
    if len(buf) == 0 </span><span class="cov0" title="0">{
        sb.WriteString("[yellow]" + i18n.T("no_packets_captured") + "\n")
    }</span> else<span class="cov0" title="0"> {
        buckets := []int{64, 128, 256, 512, 1024, 1500}
        labels := []string{i18n.T("lt_64"), i18n.T("64_127"), i18n.T("128_255"), i18n.T("256_511"), i18n.T("512_1023"), i18n.T("gte_1024")}
        counts := make([]int, len(buckets))
        for _, p := range buf </span><span class="cov0" title="0">{
            l := int(p.Length)
            idx := len(buckets) - 1
            for i, th := range buckets </span><span class="cov0" title="0">{
                if l &lt; th </span><span class="cov0" title="0">{ idx = i; break</span> }
            }
            <span class="cov0" title="0">counts[idx]++</span>
        }
        <span class="cov0" title="0">maxCount := 0
        for _, c := range counts </span><span class="cov0" title="0">{ if c &gt; maxCount </span><span class="cov0" title="0">{ maxCount = c }</span> }
        <span class="cov0" title="0">barWidth := 50
        for i, label := range labels </span><span class="cov0" title="0">{
            bar := ""
            if maxCount &gt; 0 </span><span class="cov0" title="0">{
                w := int(math.Round(float64(counts[i]) * float64(barWidth) / float64(maxCount)))
                bar = strings.Repeat("█", w)
            }</span>
            <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("%-10s |%s (%d)\n", label, bar, counts[i]))</span>
        }
    }
    <span class="cov0" title="0">ui.histView.SetText(sb.String())
    ui.histView.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
        if event.Key() == tcell.KeyEscape </span><span class="cov0" title="0">{
            ui.pages.SwitchToPage("main")
            return nil
        }</span>
        <span class="cov0" title="0">return event</span>
    })
    <span class="cov0" title="0">ui.pages.AddPage("hist", ui.histView, true, true)
    ui.app.SetFocus(ui.histView)</span>
}

// showDnsHttpPage displays HTTP and DNS packet counts
func (ui *UI) showDnsHttpPage() <span class="cov0" title="0">{
    ui.pages.RemovePage("dnsHttp")
    buf := ui.networkMonitor.GetPacketBuffer()
    httpCount, httpsCount, dnsCount := 0, 0, 0
    for _, p := range buf </span><span class="cov0" title="0">{
        switch p.Service </span>{
        case "HTTP":<span class="cov0" title="0"> httpCount++</span>
        case "HTTPS":<span class="cov0" title="0"> httpsCount++</span>
        case "DNS":<span class="cov0" title="0"> dnsCount++</span>
        }
    }
    <span class="cov0" title="0">text := fmt.Sprintf(
        "[green]" + i18n.T("http") + ":[white] %d\n"+
        "[green]" + i18n.T("https") + ":[white] %d\n"+
        "[green]" + i18n.T("dns") + ":[white] %d\n",
        httpCount, httpsCount, dnsCount,
    )
    ui.dnsHttpView.SetText(text)
    ui.dnsHttpView.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
        if event.Key() == tcell.KeyEscape </span><span class="cov0" title="0">{
            ui.pages.SwitchToPage("main")
            return nil
        }</span>
        <span class="cov0" title="0">return event</span>
    })
    <span class="cov0" title="0">ui.pages.AddPage("dnsHttp", ui.dnsHttpView, true, true)
    ui.app.SetFocus(ui.dnsHttpView)</span>
}

// showGeoPage displays enhanced geographic visualization
func (ui *UI) showGeoPage() <span class="cov0" title="0">{
    ui.pages.RemovePage("geo")
    
    // Create a flex container for map and table
    flex := tview.NewFlex().SetDirection(tview.FlexRow)
    
    // Update geo data
    ui.updateGeoData()
    
    // Add world map view (takes up more space)
    flex.AddItem(ui.geoMapView, 0, 3, false)
    
    // Add detailed geo table
    flex.AddItem(ui.geoView, 0, 2, true)
    
    // Set up input capture for the flex container
    flex.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
        switch event.Key() </span>{
        case tcell.KeyEscape:<span class="cov0" title="0">
            ui.pages.SwitchToPage("main")
            return nil</span>
        case tcell.KeyTab:<span class="cov0" title="0">
            // Toggle focus between map and table
            if ui.geoView.HasFocus() </span><span class="cov0" title="0">{
                ui.app.SetFocus(ui.geoMapView)
            }</span> else<span class="cov0" title="0"> {
                ui.app.SetFocus(ui.geoView)
            }</span>
            <span class="cov0" title="0">return nil</span>
        }
        
        <span class="cov0" title="0">switch event.Rune() </span>{
        case 'r', 'R':<span class="cov0" title="0">
            // Refresh geo data
            ui.clearGeoCache()
            ui.updateGeoData()
            return nil</span>
        }
        
        <span class="cov0" title="0">return event</span>
    })
    
    <span class="cov0" title="0">ui.pages.AddPage("geo", flex, true, true)
    ui.app.SetFocus(ui.geoView)</span>
}

// updateGeoData updates both the map and table with current connection data
func (ui *UI) updateGeoData() <span class="cov0" title="0">{
    // Clear views
    ui.geoView.Clear()
    ui.geoMapView.Clear()
    
    if ui.selectedIface == "" </span><span class="cov0" title="0">{
        fmt.Fprintf(ui.geoMapView, "[yellow]No interface selected[white]")
        return
    }</span>
    
    // Gather connections
    <span class="cov0" title="0">conns := ui.networkMonitor.GetConnections(ui.selectedIface)
    ipConnections := make(map[string]int)
    ipTraffic := make(map[string]uint64)
    
    for _, c := range conns </span><span class="cov0" title="0">{
        // Determine remote IP
        var remoteIP string
        if ui.networkMonitor.IsLocalAddress(c.SrcIP.String()) </span><span class="cov0" title="0">{
            remoteIP = c.DstIP.String()
        }</span> else<span class="cov0" title="0"> {
            remoteIP = c.SrcIP.String()
        }</span>
        
        // Skip local addresses
        <span class="cov0" title="0">if ui.networkMonitor.IsLocalAddress(remoteIP) </span><span class="cov0" title="0">{
            continue</span>
        }
        
        <span class="cov0" title="0">ipConnections[remoteIP]++
        ipTraffic[remoteIP] += c.Size</span>
    }
    
    // Fetch geo data for IPs
    <span class="cov0" title="0">locations := make([]*GeoLocation, 0)
    countryCounts := make(map[string]int)
    countryTraffic := make(map[string]uint64)
    
    for ip := range ipConnections </span><span class="cov0" title="0">{
        loc := ui.getGeoLocation(ip)
        if loc != nil </span><span class="cov0" title="0">{
            locations = append(locations, loc)
            countryCounts[loc.CountryCode] += ipConnections[ip]
            countryTraffic[loc.CountryCode] += ipTraffic[ip]
        }</span>
    }
    
    // Sort locations by connection count
    <span class="cov0" title="0">sort.Slice(locations, func(i, j int) bool </span><span class="cov0" title="0">{
        return ipConnections[locations[i].Country] &gt; ipConnections[locations[j].Country]
    }</span>)
    
    // Update world map
    <span class="cov0" title="0">worldMap := NewWorldMap()
    maxCount := 0
    for _, count := range countryCounts </span><span class="cov0" title="0">{
        if count &gt; maxCount </span><span class="cov0" title="0">{
            maxCount = count
        }</span>
    }
    
    <span class="cov0" title="0">mapStr := worldMap.RenderWithColors(countryCounts, maxCount)
    fmt.Fprint(ui.geoMapView, mapStr)
    fmt.Fprintf(ui.geoMapView, "\n%s", GetMapLegend())
    
    // Update table with detailed information
    headers := []string{"IP", "Country", "City", "Region", "ISP/Org", "Connections", "Traffic"}
    for i, h := range headers </span><span class="cov0" title="0">{
        ui.geoView.SetCell(0, i, tview.NewTableCell(h).
            SetTextColor(ui.theme.PrimaryColor).
            SetSelectable(false).
            SetAlign(tview.AlignCenter))
    }</span>
    
    // Add data rows
    <span class="cov0" title="0">row := 1
    addedIPs := make(map[string]bool)
    
    for _, loc := range locations </span><span class="cov0" title="0">{
        // Find all IPs for this location
        for ip, count := range ipConnections </span><span class="cov0" title="0">{
            ipLoc := ui.getGeoLocation(ip)
            if ipLoc == nil || addedIPs[ip] </span><span class="cov0" title="0">{
                continue</span>
            }
            
            <span class="cov0" title="0">if ipLoc.Country == loc.Country &amp;&amp; ipLoc.City == loc.City </span><span class="cov0" title="0">{
                ui.geoView.SetCell(row, 0, tview.NewTableCell(ip))
                ui.geoView.SetCell(row, 1, tview.NewTableCell(fmt.Sprintf("%s %s", ipLoc.CountryCode, ipLoc.Country)))
                ui.geoView.SetCell(row, 2, tview.NewTableCell(ipLoc.City))
                ui.geoView.SetCell(row, 3, tview.NewTableCell(ipLoc.Region))
                
                // Show ISP or Org
                ispOrg := ipLoc.ISP
                if ispOrg == "" </span><span class="cov0" title="0">{
                    ispOrg = ipLoc.Org
                }</span>
                <span class="cov0" title="0">if len(ispOrg) &gt; 30 </span><span class="cov0" title="0">{
                    ispOrg = ispOrg[:27] + "..."
                }</span>
                <span class="cov0" title="0">ui.geoView.SetCell(row, 4, tview.NewTableCell(ispOrg))
                
                ui.geoView.SetCell(row, 5, tview.NewTableCell(fmt.Sprintf("%d", count)).
                    SetAlign(tview.AlignRight))
                ui.geoView.SetCell(row, 6, tview.NewTableCell(utils.FormatBytes(ipTraffic[ip])).
                    SetAlign(tview.AlignRight))
                
                addedIPs[ip] = true
                row++</span>
            }
        }
    }
    
    // Add summary at the bottom
    <span class="cov0" title="0">fmt.Fprintf(ui.geoMapView, "\n\n[yellow]Summary:[white] %d unique IPs from %d countries", 
        len(ipConnections), len(countryCounts))</span>
}

// getGeoLocation fetches or retrieves cached geo location for an IP
func (ui *UI) getGeoLocation(ip string) *GeoLocation <span class="cov0" title="0">{
    // Check cache
    if loc, ok := ui.geoCache[ip]; ok </span><span class="cov0" title="0">{
        // Cache for 24 hours
        if time.Since(loc.LastUpdate) &lt; 24*time.Hour </span><span class="cov0" title="0">{
            return loc
        }</span>
    }
    
    // Fetch from API with more fields
    <span class="cov0" title="0">url := fmt.Sprintf("http://ip-api.com/json/%s?fields=status,message,country,countryCode,region,regionName,city,lat,lon,isp,org,as", ip)
    resp, err := http.Get(url)
    if err != nil </span><span class="cov0" title="0">{
        return nil
    }</span>
    <span class="cov0" title="0">defer resp.Body.Close()
    
    var result struct {
        Status string `json:"status"`
        *GeoLocation
    }
    
    if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
        return nil
    }</span>
    
    <span class="cov0" title="0">if result.Status != "success" </span><span class="cov0" title="0">{
        return nil
    }</span>
    
    <span class="cov0" title="0">result.GeoLocation.LastUpdate = time.Now()
    ui.geoCache[ip] = result.GeoLocation
    
    return result.GeoLocation</span>
}

// clearGeoCache clears the geo location cache
func (ui *UI) clearGeoCache() <span class="cov0" title="0">{
    ui.geoCache = make(map[string]*GeoLocation)
}</span>

// showPluginsPage displays the plugins view
func (ui *UI) showPluginsPage() <span class="cov0" title="0">{
    ui.updatePluginView()
    
    ui.pluginView.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
        switch event.Key() </span>{
        case tcell.KeyEscape:<span class="cov0" title="0">
            ui.pages.SwitchToPage("main")
            return nil</span>
        case tcell.KeyUp:<span class="cov0" title="0">
            if ui.selectedPlugin &gt; 0 </span><span class="cov0" title="0">{
                ui.selectedPlugin--
                ui.updatePluginView()
            }</span>
            <span class="cov0" title="0">return nil</span>
        case tcell.KeyDown:<span class="cov0" title="0">
            if ui.selectedPlugin &lt; len(ui.plugins)-1 </span><span class="cov0" title="0">{
                ui.selectedPlugin++
                ui.updatePluginView()
            }</span>
            <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return event</span>
    })
    
    <span class="cov0" title="0">ui.pages.AddPage("plugins", ui.pluginView, true, true)
    ui.app.SetFocus(ui.pluginView)</span>
}

// updatePluginView refreshes the plugin display
func (ui *UI) updatePluginView() <span class="cov0" title="0">{
    ui.pluginView.Clear()
    
    if len(ui.plugins) == 0 </span><span class="cov0" title="0">{
        fmt.Fprintf(ui.pluginView, "[%s]No plugins loaded.[white]\n\n", 
            graph.ColorToHex(ui.theme.WarningColor))
        fmt.Fprintf(ui.pluginView, "Use --plugins flag to load plugins.\n")
        return
    }</span>
    
    // Header
    <span class="cov0" title="0">fmt.Fprintf(ui.pluginView, "[%s]═══ Loaded Plugins ═══[white]\n\n", 
        graph.ColorToHex(ui.theme.PrimaryColor))
    
    // Display each plugin
    for i, plugin := range ui.plugins </span><span class="cov0" title="0">{
        // Plugin name and status
        statusColor := ui.theme.SuccessColor
        if plugin.Status != "Active" </span><span class="cov0" title="0">{
            statusColor = ui.theme.WarningColor
        }</span>
        
        <span class="cov0" title="0">marker := " "
        if i == ui.selectedPlugin </span><span class="cov0" title="0">{
            marker = "►"
        }</span>
        
        <span class="cov0" title="0">fmt.Fprintf(ui.pluginView, "%s [%s]%s[white] - [%s]%s[white]\n", 
            marker,
            graph.ColorToHex(ui.theme.PrimaryColor), 
            plugin.Name,
            graph.ColorToHex(statusColor),
            plugin.Status)
        
        // Plugin description
        if plugin.Description != "" </span><span class="cov0" title="0">{
            fmt.Fprintf(ui.pluginView, "  %s\n", plugin.Description)
        }</span>
        
        // Last update
        <span class="cov0" title="0">fmt.Fprintf(ui.pluginView, "  Last Update: %s ago\n", 
            time.Since(plugin.LastUpdate).Round(time.Second))
        
        // Show recent output for selected plugin
        if i == ui.selectedPlugin &amp;&amp; len(plugin.Output) &gt; 0 </span><span class="cov0" title="0">{
            fmt.Fprintf(ui.pluginView, "\n  [%s]Recent Output:[white]\n", 
                graph.ColorToHex(ui.theme.SecondaryColor))
            
            // Show last 10 lines of output
            start := 0
            if len(plugin.Output) &gt; 10 </span><span class="cov0" title="0">{
                start = len(plugin.Output) - 10
            }</span>
            
            <span class="cov0" title="0">for _, line := range plugin.Output[start:] </span><span class="cov0" title="0">{
                fmt.Fprintf(ui.pluginView, "  │ %s\n", line)
            }</span>
        }
        
        <span class="cov0" title="0">fmt.Fprintln(ui.pluginView)</span>
    }
    
    // Footer
    <span class="cov0" title="0">fmt.Fprintf(ui.pluginView, "\n[%s]Press ↑/↓ to navigate, ESC to return[white]", 
        graph.ColorToHex(ui.theme.BorderColor))</span>
}

// populateInterfaceList loads available interfaces
func (ui *UI) populateInterfaceList() <span class="cov0" title="0">{
    ui.interfaceList.Clear()
    ifaces, err := netcap.GetInterfaces()
    if err != nil </span><span class="cov0" title="0">{
        ui.showError(fmt.Sprintf("Error getting interfaces: %v", err))
        return
    }</span>
    <span class="cov0" title="0">for i, iface := range ifaces </span><span class="cov0" title="0">{
        desc := iface.Description
        if desc == "" </span><span class="cov0" title="0">{
            desc = "No description"
        }</span>
        <span class="cov0" title="0">ui.interfaceList.AddItem(iface.Name, desc, rune('a'+i), nil)</span>
    }
    <span class="cov0" title="0">if ui.selectedIface == "" &amp;&amp; ui.interfaceList.GetItemCount() &gt; 0 </span><span class="cov0" title="0">{
        ui.selectedIface, _ = ui.interfaceList.GetItemText(0)
        ui.interfaceList.SetCurrentItem(0)
    }</span>
}

// updateStatsView refreshes the stats panel
func (ui *UI) updateStatsView() <span class="cov0" title="0">{
    if ui.selectedIface == "" </span><span class="cov0" title="0">{
        return
    }</span>
    <span class="cov0" title="0">stats := ui.networkMonitor.GetInterfaceStats()
    ifStats, ok := stats[ui.selectedIface]
    if !ok </span><span class="cov0" title="0">{
        ui.statsView.SetText("[yellow]" + i18n.T("no_statistics_available"))
        return
    }</span>
    // compute current in/out rates
    <span class="cov0" title="0">inRate, outRate := ui.getNetworkRates()
    text := fmt.Sprintf(
        "[green]" + i18n.T("interface") + ":[white] %s\n\n"+
        "[green]" + i18n.T("in") + ":[white] %s (%d pkts)\n"+
        "[green]" + i18n.T("out") + ":[white] %s (%d pkts)\n"+
        "[green]" + i18n.T("in_rate") + ":[white] %s/s\n"+
        "[green]" + i18n.T("out_rate") + ":[white] %s/s\n\n"+
        "[green]" + i18n.T("connections") + ":[white] %d\n",
        ui.selectedIface,
        utils.FormatBytes(ifStats.BytesIn), ifStats.PacketsIn,
        utils.FormatBytes(ifStats.BytesOut), ifStats.PacketsOut,
        utils.FormatBytes(uint64(inRate)), utils.FormatBytes(uint64(outRate)),
        len(ifStats.Connections),
    )
    ui.statsView.SetText(text)</span>
}

// updateConnectionTable refreshes the connections table
func (ui *UI) updateConnectionTable() <span class="cov0" title="0">{
    selRow, _ := ui.connectionTable.GetSelection()
    var selConn *netcap.Connection
    if selRow &gt; 0 &amp;&amp; selRow-1 &lt; len(ui.connections) </span><span class="cov0" title="0">{
        selConn = ui.connections[selRow-1]
    }</span>
    <span class="cov0" title="0">ui.connectionTable.Clear()
    headers := []string{i18n.T("source"), i18n.T("destination"), i18n.T("proto"), i18n.T("svc"), i18n.T("bytes"), i18n.T("pkts"), i18n.T("activity"), i18n.T("last_seen")}
    for i, h := range headers </span><span class="cov0" title="0">{
        ui.connectionTable.SetCell(0, i, tview.NewTableCell(h).
            SetTextColor(ui.theme.TitleColor).
            SetSelectable(false).
            SetExpansion(1))
    }</span>
    <span class="cov0" title="0">if ui.selectedIface == "" </span><span class="cov0" title="0">{
        return
    }</span>
    <span class="cov0" title="0">ui.connections = ui.networkMonitor.GetConnections(ui.selectedIface)
    sort.Slice(ui.connections, func(i, j int) bool </span><span class="cov0" title="0">{
        a, b := ui.connections[i], ui.connections[j]
        switch ui.sortBy </span>{
        case "bytes":<span class="cov0" title="0">
            return a.Size &gt; b.Size</span>
        case "packets":<span class="cov0" title="0">
            return a.Packets &gt; b.Packets</span>
        case "time":<span class="cov0" title="0">
            return a.LastSeen.After(b.LastSeen)</span>
        }
        <span class="cov0" title="0">return false</span>
    })
    <span class="cov0" title="0">for i, c := range ui.connections </span><span class="cov0" title="0">{
        row := i + 1
        
        // Check if connection is marked
        connKey := getConnectionKey(c)
        marked := ui.markedConnections[connKey]
        markPrefix := ""
        if marked </span><span class="cov0" title="0">{
            markPrefix = "[X] "
        }</span>
        
        <span class="cov0" title="0">ui.connectionTable.SetCell(row, 0, tview.NewTableCell(markPrefix + c.SrcIP.String()).SetTextColor(ui.theme.PrimaryColor).SetExpansion(1))
        ui.connectionTable.SetCell(row, 1, tview.NewTableCell(c.DstIP.String()).SetTextColor(ui.theme.PrimaryColor).SetExpansion(1))
        // protocol color
        protoColor := ui.theme.SecondaryColor
        switch c.Protocol </span>{
        case "TCP":<span class="cov0" title="0"> protoColor = tcell.ColorGreen</span>
        case "UDP":<span class="cov0" title="0"> protoColor = tcell.ColorBlue</span>
        case "ICMP":<span class="cov0" title="0"> protoColor = tcell.ColorFuchsia</span>
        }
        <span class="cov0" title="0">ui.connectionTable.SetCell(row, 2, tview.NewTableCell(c.Protocol).SetTextColor(protoColor).SetExpansion(1))
        ui.connectionTable.SetCell(row, 3, tview.NewTableCell(c.Service).SetTextColor(ui.theme.TitleColor).SetExpansion(1))
        ui.connectionTable.SetCell(row, 4, tview.NewTableCell(fmt.Sprintf("%d", c.Size)).SetTextColor(ui.theme.SecondaryColor).SetExpansion(1))
        ui.connectionTable.SetCell(row, 5, tview.NewTableCell(fmt.Sprintf("%d", c.Packets)).SetTextColor(ui.theme.PrimaryColor).SetExpansion(1))
        
        // Generate sparkline for connection activity
        sparkline := ui.getConnectionSparkline(connKey)
        ui.connectionTable.SetCell(row, 6, tview.NewTableCell(sparkline).SetTextColor(ui.theme.PrimaryColor))
        
        ui.connectionTable.SetCell(row, 7, tview.NewTableCell(c.LastSeen.Format(time.Kitchen)).SetTextColor(ui.theme.TitleColor).SetExpansion(1))</span>
    }
    <span class="cov0" title="0">newRow := 0
    if selConn != nil </span><span class="cov0" title="0">{
        for i, c := range ui.connections </span><span class="cov0" title="0">{
            if c == selConn </span><span class="cov0" title="0">{
                newRow = i + 1
                break</span>
            }
        }
    }
    <span class="cov0" title="0">if newRow == 0 </span><span class="cov0" title="0">{
        if selRow &gt; 0 &amp;&amp; selRow &lt;= len(ui.connections) </span><span class="cov0" title="0">{
            newRow = selRow
        }</span> else<span class="cov0" title="0"> if len(ui.connections) &gt; 0 </span><span class="cov0" title="0">{
            newRow = 1
        }</span>
    }
    <span class="cov0" title="0">ui.connectionTable.Select(newRow, 0)
    if newRow &gt; 0 &amp;&amp; newRow-1 &lt; len(ui.connections) </span><span class="cov0" title="0">{
        ui.showConnectionDetails(ui.connections[newRow-1])
    }</span> else<span class="cov0" title="0"> {
        ui.detailView.SetText("")
    }</span>
}

// showConnectionDetails shows detailed info for a connection
func (ui *UI) showConnectionDetails(c *netcap.Connection) <span class="cov0" title="0">{
    if c == nil </span><span class="cov0" title="0">{
        ui.detailView.SetText("")
        return
    }</span>
    <span class="cov0" title="0">text := fmt.Sprintf(
        "[green]" + i18n.T("src") + ":[white] %s:%d\n"+
        "[green]" + i18n.T("dst") + ":[white] %s:%d\n"+
        "[green]" + i18n.T("proto") + ":[white] %s\n"+
        "[green]" + i18n.T("svc") + ":[white] %s\n"+
        "[green]" + i18n.T("bytes") + ":[white] %s\n"+
        "[green]" + i18n.T("pkts") + ":[white] %d\n",
        c.SrcIP, c.SrcPort, c.DstIP, c.DstPort,
        c.Protocol, c.Service,
        utils.FormatBytes(c.Size), c.Packets,
    )
    // Don't show hex dump in the detail view to avoid performance issues
    ui.detailView.SetText(text)</span>
}

// showError displays an error modal
func (ui *UI) showError(msg string) <span class="cov0" title="0">{
    modal := tview.NewModal().SetText(msg).
        AddButtons([]string{i18n.T("ok")}).
        SetDoneFunc(func(_ int, _ string) </span><span class="cov0" title="0">{ ui.pages.SwitchToPage("main") }</span>)
    <span class="cov0" title="0">ui.pages.AddPage("error", modal, true, true)</span>
}

// startUpdateLoop starts periodic UI updates
func (ui *UI) startUpdateLoop() <span class="cov0" title="0">{
    lastInterval := ui.updateInterval
    ticker := time.NewTicker(ui.updateInterval)
    defer ticker.Stop()
    for </span><span class="cov0" title="0">{
        select </span>{
        case &lt;-ticker.C:<span class="cov0" title="0">
            if !ui.paused </span><span class="cov0" title="0">{
                ui.app.QueueUpdateDraw(ui.updateData)
            }</span>
            <span class="cov0" title="0">ui.app.QueueUpdateDraw(ui.updateStatusBar)
            // Reset ticker if interval changed
            if lastInterval != ui.updateInterval </span><span class="cov0" title="0">{
                ticker.Stop()
                ticker = time.NewTicker(ui.updateInterval)
                lastInterval = ui.updateInterval
            }</span>
        case &lt;-ui.stopChan:<span class="cov0" title="0">
            return</span>
        }
    }
}

// updateStatusBar updates the status bar with current state
func (ui *UI) updateStatusBar() <span class="cov0" title="0">{
    var pauseText string
    if ui.paused </span><span class="cov0" title="0">{
        pauseText = " [PAUSED]"
    }</span>
    
    <span class="cov0" title="0">var recordText string
    if ui.recording </span><span class="cov0" title="0">{
        recordText = fmt.Sprintf(" [REC %s]", time.Since(ui.recordingStart).Round(time.Second))
    }</span>
    
    <span class="cov0" title="0">updateText := fmt.Sprintf("%.1fs", ui.updateInterval.Seconds())
    layoutText := ui.layoutPresets[ui.currentLayout]
    
    status := fmt.Sprintf("Layout: %s | Update: %s%s%s | q:Exit h:Help p:Preset +/-:Speed Space:Pause R:Record L:Load", 
        layoutText, updateText, pauseText, recordText)
    
    if ui.filterString != "" </span><span class="cov0" title="0">{
        status += fmt.Sprintf(" | Filter: %s", ui.filterString)
    }</span>
    
    <span class="cov0" title="0">ui.statusBar.SetText(status).SetTextColor(ui.theme.StatusBarTextColor)</span>
}

// getNetworkRates computes in/outbps
func (ui *UI) getNetworkRates() (float64, float64) <span class="cov0" title="0">{
    if ui.selectedIface == "" </span><span class="cov0" title="0">{ return 0, 0 }</span>
    <span class="cov0" title="0">stats := ui.networkMonitor.GetInterfaceStats()
    if s, ok := stats[ui.selectedIface]; ok </span><span class="cov0" title="0">{
        now := time.Now()
        elapsed := now.Sub(ui.lastUpdateTime)
        if ui.lastUpdateTime.IsZero() || elapsed &lt; 100*time.Millisecond </span><span class="cov0" title="0">{
            ui.lastBytesIn, ui.lastBytesOut = s.BytesIn, s.BytesOut
            ui.lastUpdateTime = now
            return 0, 0
        }</span>
        <span class="cov0" title="0">inRate := float64(s.BytesIn - ui.lastBytesIn) / elapsed.Seconds()
        outRate := float64(s.BytesOut - ui.lastBytesOut) / elapsed.Seconds()
        ui.lastBytesIn, ui.lastBytesOut, ui.lastUpdateTime = s.BytesIn, s.BytesOut, now
        return inRate, outRate</span>
    }
    <span class="cov0" title="0">return 0, 0</span>
}

// updateProtocolView updates the protocol usage text view
func (ui *UI) updateProtocolView() <span class="cov0" title="0">{
    buf := ui.networkMonitor.GetPacketBuffer()
    counts := make(map[string]int)
    for _, p := range buf </span><span class="cov0" title="0">{ counts[p.Service]++ }</span>
    <span class="cov0" title="0">total := len(buf)
    // sort services for consistent ordering
    keys := make([]string, 0, len(counts))
    for k := range counts </span><span class="cov0" title="0">{ keys = append(keys, k) }</span>
    <span class="cov0" title="0">sort.Strings(keys)
    // color-coded lines
    lines := []string{}
    for i, svc := range keys </span><span class="cov0" title="0">{
        v := counts[svc]
        perc := 0
        if total &gt; 0 </span><span class="cov0" title="0">{ perc = v * 100 / total }</span>
        <span class="cov0" title="0">color := pieColors[i%len(pieColors)]
        lines = append(lines, fmt.Sprintf("%s%s %d%%", color, svc, perc))</span>
    }
    <span class="cov0" title="0">ui.protocolView.SetText(strings.Join(lines, "\n"))</span>
}

// showHelpPage displays the help screen
func (ui *UI) showHelpPage() <span class="cov0" title="0">{
    ui.pages.RemovePage("help")
    
    // Get current context
    currentPage, _ := ui.pages.GetFrontPage()
    focusedPrimitive := ui.app.GetFocus()
    
    // Build context-sensitive help
    helpText := ui.buildContextualHelp(currentPage, focusedPrimitive)
    
    ui.helpView.SetText(helpText)
    ui.helpView.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
        if event.Key() == tcell.KeyEscape || event.Rune() == '?' || event.Rune() == 'h' </span><span class="cov0" title="0">{
            ui.pages.SwitchToPage("main")
            return nil
        }</span>
        <span class="cov0" title="0">return event</span>
    })
    <span class="cov0" title="0">ui.pages.AddPage("help", ui.helpView, true, true)
    ui.app.SetFocus(ui.helpView)</span>
}

// buildContextualHelp generates help text based on current context
func (ui *UI) buildContextualHelp(currentPage string, focused tview.Primitive) string <span class="cov0" title="0">{
    var help strings.Builder
    
    // Header
    help.WriteString(fmt.Sprintf("[%s]NetMon Help - Press ESC or ? to close[white]\n\n", 
        graph.ColorToHex(ui.theme.TitleColor)))
    
    // Global shortcuts
    help.WriteString(fmt.Sprintf("[%s]═══ Global Shortcuts ═══[white]\n", 
        graph.ColorToHex(ui.theme.PrimaryColor)))
    help.WriteString(`
  q       - Exit menu (Options/Help/Quit)
  h/?     - Show this help
  o       - Options/settings menu
  p       - Cycle layout presets
  +/-     - Increase/decrease update speed
  Space   - Pause/resume updates
  Tab     - Switch focus between panels
  
`)
    
    // Navigation
    help.WriteString(fmt.Sprintf("[%s]═══ Navigation ═══[white]\n", 
        graph.ColorToHex(ui.theme.PrimaryColor)))
    help.WriteString(`
  n/N     - Next/previous interface
  ↑/↓     - Navigate lists and tables
  Enter   - Select/view details
  ESC     - Back to main view
  
`)
    
    // Panel visibility
    help.WriteString(fmt.Sprintf("[%s]═══ Panel Toggles ═══[white]\n", 
        graph.ColorToHex(ui.theme.PrimaryColor)))
    help.WriteString(`
  0       - Toggle interfaces panel
  1       - Toggle statistics panel
  2       - Toggle traffic graphs
  3       - Toggle protocol view
  4-6     - Toggle pie charts
  7       - Toggle connections table
  8       - Toggle connection details
  
`)
    
    // Context-specific help
    switch </span>{
    case focused == ui.connectionTable:<span class="cov0" title="0">
        help.WriteString(fmt.Sprintf("[%s]═══ Connection Table ═══[white]\n", 
            graph.ColorToHex(ui.theme.SecondaryColor)))
        help.WriteString(`
  Enter   - View connection packets
  k/Del   - Kill connection
  e       - Export connection data
  x       - Mark/unmark connection
  a       - Select all connections
  s       - Sort connections
  f       - Filter connections
  
  Mouse:
  - Click to select
  - Right-click for context menu
  - Double-click to view packets
`)</span>
        
    case focused == ui.interfaceList:<span class="cov0" title="0">
        help.WriteString(fmt.Sprintf("[%s]═══ Interface List ═══[white]\n", 
            graph.ColorToHex(ui.theme.SecondaryColor)))
        help.WriteString(`
  ↑/↓     - Select interface
  Enter   - Apply selection
  r       - Refresh interface list
  
  Mouse:
  - Click to select
  - Scroll to navigate
`)</span>
        
    case currentPage == "main" &amp;&amp; focused == ui.trafficGraph:<span class="cov0" title="0">
        help.WriteString(fmt.Sprintf("[%s]═══ Traffic Graphs ═══[white]\n", 
            graph.ColorToHex(ui.theme.SecondaryColor)))
        help.WriteString(`
  t       - Toggle graph style (Braille/Block/TTY)
  
  Mouse:
  - Click title to cycle graph styles
`)</span>
        
    case currentPage == "geo":<span class="cov0" title="0">
        help.WriteString(fmt.Sprintf("[%s]═══ Geographic View ═══[white]\n", 
            graph.ColorToHex(ui.theme.SecondaryColor)))
        help.WriteString(`
  Tab     - Toggle focus between map and table
  r       - Refresh geo data (clear cache)
  ↑/↓     - Navigate table rows
  
  The world map shows connection density with:
  █ ▓ ▒ ░ symbols for traffic volume
  Colors indicate percentage of max connections
`)</span>
    }
    
    // Features and filters
    <span class="cov0" title="0">help.WriteString(fmt.Sprintf("\n[%s]═══ Features &amp; Filters ═══[white]\n", 
        graph.ColorToHex(ui.theme.PrimaryColor)))
    help.WriteString(`
  b       - Set BPF (Berkeley Packet Filter)
  c       - Clear all filters
  d       - Dashboard menu
  e       - Export data menu
  u       - UI profiles (save/load)
  i       - Interface statistics page
  g       - Geographic IP mapping
  G       - Show plugins view
  &amp;       - Border styles preview
  r       - Force refresh
  
`)
    
    // Current status
    help.WriteString(fmt.Sprintf("[%s]═══ Current Status ═══[white]\n", 
        graph.ColorToHex(ui.theme.TitleColor)))
    help.WriteString(fmt.Sprintf(`
  Layout:         %s
  Update Speed:   %.1fs
  Graph Style:    %s
  Theme:          %s
  Paused:         %v
`,
        ui.layoutPresets[ui.currentLayout],
        ui.updateInterval.Seconds(),
        []string{"Braille", "Block", "TTY"}[ui.graphStyle],
        ui.getCurrentThemeName(),
        ui.paused))
    
    return help.String()</span>
}

// getCurrentThemeName returns the name of the current theme
func (ui *UI) getCurrentThemeName() string <span class="cov0" title="0">{
    for name, theme := range Themes </span><span class="cov0" title="0">{
        if theme == ui.theme </span><span class="cov0" title="0">{
            return name
        }</span>
    }
    <span class="cov0" title="0">return "Custom"</span>
}

// showBorderStylesPreview shows a preview of all border styles
func (ui *UI) showBorderStylesPreview() <span class="cov0" title="0">{
        // Create a text view to show border style examples
        preview := tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        
        preview.SetBorder(true).
                SetTitle("Border Styles Preview").
                SetTitleColor(ui.theme.TitleColor).
                SetBorderColor(ui.theme.BorderColor)
        
        // Generate preview text
        var text string
        text += fmt.Sprintf("[%s]═══ Border Styles Preview ═══[white]\n\n", 
                graph.ColorToHex(ui.theme.PrimaryColor))
        
        // Sort border style names for consistent display
        styleNames := BorderStyleNames()
        for _, styleName := range styleNames </span><span class="cov0" title="0">{
                style := GetBorderStyle(styleName)
                text += fmt.Sprintf("[%s]%s Style:[white]\n", 
                        graph.ColorToHex(ui.theme.SecondaryColor), styleName)
                
                // Draw a sample box
                text += fmt.Sprintf("  %c%c%c%c%c%c%c\n", 
                        style.TopLeft, style.Horizontal, style.HorizontalDown, 
                        style.Horizontal, style.Horizontal, style.Horizontal, style.TopRight)
                text += fmt.Sprintf("  %c     %c\n", style.Vertical, style.Vertical)
                text += fmt.Sprintf("  %c%c%c%c%c%c%c\n", 
                        style.VerticalRight, style.Horizontal, style.Cross, 
                        style.Horizontal, style.Horizontal, style.Horizontal, style.VerticalLeft)
                text += fmt.Sprintf("  %c     %c\n", style.Vertical, style.Vertical)
                text += fmt.Sprintf("  %c%c%c%c%c%c%c\n\n", 
                        style.BottomLeft, style.Horizontal, style.HorizontalUp, 
                        style.Horizontal, style.Horizontal, style.Horizontal, style.BottomRight)
        }</span>
        
        <span class="cov0" title="0">text += fmt.Sprintf("\n[%s]Current style:[white] %s\n", 
                graph.ColorToHex(ui.theme.PrimaryColor), ui.borderStyle)
        text += fmt.Sprintf("\n[%s]Press ESC to return[white]", 
                graph.ColorToHex(ui.theme.BorderColor))
        
        preview.SetText(text)
        
        // Handle escape key
        preview.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                if event.Key() == tcell.KeyEscape </span><span class="cov0" title="0">{
                        ui.pages.SwitchToPage("main")
                        return nil
                }</span>
                <span class="cov0" title="0">return event</span>
        })
        
        <span class="cov0" title="0">ui.pages.AddPage("borderPreview", preview, true, true)
        ui.app.SetFocus(preview)</span>
}

// SetTheme applies a named theme to UI components
func (ui *UI) SetTheme(name string) *UI <span class="cov6" title="17">{
    t, ok := Themes[name]
    if !ok </span><span class="cov1" title="1">{
        t = Themes["Dark+"]
    }</span>
    <span class="cov6" title="17">ui.theme = t
    ui.interfaceList.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.statsView.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.trafficGraph.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.networkGraph.SetColor(t.PrimaryColor).SetSecondaryColor(t.SecondaryColor)
    ui.protocolView.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.connectionTable.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.detailView.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.servicePieView.SetBorderColor(t.PieBorderColor).SetTitleColor(t.PieTitleColor)
    ui.protocolPieView.SetBorderColor(t.PieBorderColor).SetTitleColor(t.PieTitleColor)
    ui.securePieView.SetBorderColor(t.PieBorderColor).SetTitleColor(t.PieTitleColor)
    ui.ifaceStatsView.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.histView.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.dnsHttpView.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.geoView.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.geoMapView.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.helpView.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.rawView.SetBorderColor(t.BorderColor).SetTitleColor(t.TitleColor)
    ui.statusBar.SetBackgroundColor(t.StatusBarBgColor)
    ui.statusBar.SetTextColor(t.StatusBarTextColor)

    // Update pie chart segment colors to match theme
    pieColors = []string{
        "[" + graph.ColorToHex(t.PrimaryColor) + "]",
        "[" + graph.ColorToHex(t.SecondaryColor) + "]",
        "[" + graph.ColorToHex(t.PieTitleColor) + "]",
        "[" + graph.ColorToHex(t.TitleColor) + "]",
    }

    return ui</span>
}

// SetStyle applies a named UI style (Standard or btop).
func (ui *UI) SetStyle(name string) *UI <span class="cov3" title="3">{
    def, ok := Styles[name]
    if ok </span><span class="cov2" title="2">{
        ui.styleName = name
    }</span> else<span class="cov1" title="1"> {
        def = Styles["Standard"]
        ui.styleName = "Standard"
    }</span>
    // Override border runes for the selected style
    <span class="cov3" title="3">tview.Borders.TopLeft = def.BorderTL
    tview.Borders.TopRight = def.BorderTR
    tview.Borders.BottomLeft = def.BorderBL
    tview.Borders.BottomRight = def.BorderBR
    tview.Borders.Horizontal = def.BorderH
    tview.Borders.Vertical = def.BorderV
    return ui</span>
}

// SetGradientEnabled toggles static gradient shading on the traffic and network graphs
func (ui *UI) SetGradientEnabled(enabled bool) *UI <span class="cov0" title="0">{
    ui.trafficGraph.SetGradientEnabled(enabled)
    ui.networkGraph.SetGradientEnabled(enabled)
    return ui
}</span>

// Run starts the UI application
func (ui *UI) Run() error <span class="cov0" title="0">{
    ui.bpfString = ui.networkMonitor.GetFilterExpression()
    ui.populateInterfaceList()
    ui.networkGraph.Start()
    go ui.startUpdateLoop()
    ui.updateData()
    
    // Handle startup modes
    if ui.startupVizID != "" </span><span class="cov0" title="0">{
        // Start with specific visualization
        ui.app.SetAfterDrawFunc(func(screen tcell.Screen) </span><span class="cov0" title="0">{
            ui.app.SetAfterDrawFunc(nil) // Only run once
            ui.showVisualizationFullscreen(ui.startupVizID)
        }</span>)
    } else<span class="cov0" title="0"> if ui.startupDashboard != "" </span><span class="cov0" title="0">{
        // Start with specific dashboard
        ui.app.SetAfterDrawFunc(func(screen tcell.Screen) </span><span class="cov0" title="0">{
            ui.app.SetAfterDrawFunc(nil) // Only run once
            dm := NewDashboardManager()
            if layout, exists := dm.GetDashboard(ui.startupDashboard); exists </span><span class="cov0" title="0">{
                ui.showDashboard(layout)
            }</span> else<span class="cov0" title="0"> {
                ui.showError(fmt.Sprintf("Dashboard '%s' not found", ui.startupDashboard))
            }</span>
        })
    }
    
    <span class="cov0" title="0">return ui.app.Run()</span>
}

// Stop cleans up resources and exits
func (ui *UI) Stop() <span class="cov0" title="0">{
    close(ui.stopChan)
    ui.networkGraph.Stop()
    ui.networkMonitor.StopAllCaptures()
    ui.app.Stop()
}</span>

// showRawPacketPage displays hex dump of a packet
func (ui *UI) showRawPacketPage(idx int) <span class="cov0" title="0">{
    ui.pages.RemovePage("raw")
    packets := ui.networkMonitor.GetPacketBuffer()
    if idx &lt; 0 || idx &gt;= len(packets) </span><span class="cov0" title="0">{
        return
    }</span>
    <span class="cov0" title="0">var sb strings.Builder
    resetTag := colorTag(ui.theme.TitleColor)
    data := packets[idx].Data
    dumpTag := colorTag(ui.theme.PrimaryColor)
    // Packet Layers ASCII tree
    pkt := gopacket.NewPacket(data, layers.LayerTypeEthernet, gopacket.Default)
    sb.WriteString(i18n.T("packet_layers") + ":\n")
    ly := pkt.Layers()
    for i, layer := range ly </span><span class="cov0" title="0">{
        prefix := "├─ "
        if i == len(ly)-1 </span><span class="cov0" title="0">{ prefix = "└─ " }</span>
        <span class="cov0" title="0">sb.WriteString(prefix + layer.LayerType().String() + "\n")</span>
    }
    <span class="cov0" title="0">sb.WriteString("\n")
    sb.WriteString(fmt.Sprintf("[%s]" + i18n.T("hex_dump") + ":[%s]\n", dumpTag, resetTag))
    for i := 0; i &lt; len(data); i += 16 </span><span class="cov0" title="0">{
        sb.WriteString(fmt.Sprintf("[%s]%04x  [%s]", colorTag(ui.theme.SecondaryColor), i, resetTag))
        for j := 0; j &lt; 16; j++ </span><span class="cov0" title="0">{
            if i+j &lt; len(data) </span><span class="cov0" title="0">{
                b := data[i+j]
                var col tcell.Color
                switch </span>{
                case b &lt; 64:<span class="cov0" title="0">
                    col = tcell.ColorDarkGray</span>
                case b &lt; 128:<span class="cov0" title="0">
                    col = tcell.ColorGray</span>
                case b &lt; 192:<span class="cov0" title="0">
                    col = tcell.ColorLightGray</span>
                default:<span class="cov0" title="0">
                    col = ui.theme.PrimaryColor</span>
                }
                <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("[%s]%02x[%s] ", colorTag(col), b, resetTag))</span>
            } else<span class="cov0" title="0"> {
                sb.WriteString("   ")
            }</span>
        }
        <span class="cov0" title="0">sb.WriteString(" ")
        for j := 0; j &lt; 16; j++ </span><span class="cov0" title="0">{
            if i+j &lt; len(data) </span><span class="cov0" title="0">{
                b := data[i+j]
                if b &gt;= 32 &amp;&amp; b &lt; 127 </span><span class="cov0" title="0">{
                    sb.WriteString(fmt.Sprintf("[%s]%c[%s]", colorTag(ui.theme.SecondaryColor), b, resetTag))
                }</span> else<span class="cov0" title="0"> {
                    sb.WriteString(fmt.Sprintf("[%s].[%s]", colorTag(ui.theme.SecondaryColor), resetTag))
                }</span>
            }
        }
        <span class="cov0" title="0">sb.WriteString("\n")</span>
    }
    <span class="cov0" title="0">dump := sb.String()
    ui.rawView.SetText(dump)
    ui.rawDumpLines = strings.Split(dump, "\n")
    ui.rawView.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
        if event.Key() == tcell.KeyEscape </span><span class="cov0" title="0">{
            ui.pages.SwitchToPage("packets")
            return nil
        }</span>
        // Search in hex dump
        <span class="cov0" title="0">if event.Rune() == '/' </span><span class="cov0" title="0">{
            // create search input field
            inputField := tview.NewInputField().SetLabel(i18n.T("search") + ": ")
            inputField.SetDoneFunc(func(key tcell.Key) </span><span class="cov0" title="0">{
                if key == tcell.KeyEnter </span><span class="cov0" title="0">{
                    term := inputField.GetText()
                    matched := []string{}
                    for _, line := range ui.rawDumpLines </span><span class="cov0" title="0">{
                        if strings.Contains(strings.ToLower(line), strings.ToLower(term)) </span><span class="cov0" title="0">{
                            matched = append(matched, line)
                        }</span>
                    }
                    <span class="cov0" title="0">ui.rawView.SetText(strings.Join(matched, "\n"))
                    ui.pages.RemovePage("search")
                    ui.app.SetFocus(ui.rawView)</span>
                }
            })
            <span class="cov0" title="0">ui.pages.AddPage("search", inputField, true, true)
            ui.app.SetFocus(inputField)
            return nil</span>
        }
        <span class="cov0" title="0">return event</span>
    })
    <span class="cov0" title="0">ui.pages.AddPage("raw", ui.rawView, true, true)
    ui.app.SetFocus(ui.rawView)</span>
}

// showConnectionPacketsPage displays packets for the selected connection
func (ui *UI) showConnectionPacketsPage() <span class="cov0" title="0">{
    ui.pages.RemovePage("connPackets")
    conn := ui.selectedConnection
    if conn == nil </span><span class="cov0" title="0">{
        return
    }</span>
    <span class="cov0" title="0">packets := ui.networkMonitor.GetPacketBuffer()
    table := tview.NewTable().SetBorders(false)
    table.SetSelectable(true, false).SetFixed(1, 0)
    title := fmt.Sprintf(i18n.T("packets_for") + " %s:%d ↔ %s:%d", conn.SrcIP, conn.SrcPort, conn.DstIP, conn.DstPort)
    table.SetBorder(true).SetTitle(title)
    headers := []string{i18n.T("time"), i18n.T("source"), i18n.T("dest"), i18n.T("proto"), i18n.T("service"), i18n.T("len")}
    for i, h := range headers </span><span class="cov0" title="0">{
        table.SetCell(0, i, tview.NewTableCell(h).
            SetTextColor(tcell.ColorYellow).
            SetSelectable(false))
    }</span>
    <span class="cov0" title="0">row := 1
    for _, p := range packets </span><span class="cov0" title="0">{
        if (p.SrcIP.String() == conn.SrcIP.String() &amp;&amp; p.SrcPort == conn.SrcPort &amp;&amp; p.DstIP.String() == conn.DstIP.String() &amp;&amp; p.DstPort == conn.DstPort &amp;&amp; p.Protocol == conn.Protocol) ||
           (p.SrcIP.String() == conn.DstIP.String() &amp;&amp; p.SrcPort == conn.DstPort &amp;&amp; p.DstIP.String() == conn.SrcIP.String() &amp;&amp; p.DstPort == conn.SrcPort &amp;&amp; p.Protocol == conn.Protocol) </span><span class="cov0" title="0">{
            table.SetCell(row, 0, tview.NewTableCell(p.Timestamp.Format("15:04:05")))
            table.SetCell(row, 1, tview.NewTableCell(fmt.Sprintf("%s:%d", p.SrcIP, p.SrcPort)))
            table.SetCell(row, 2, tview.NewTableCell(fmt.Sprintf("%s:%d", p.DstIP, p.DstPort)))
            // protocol color
            protoColor := ui.theme.SecondaryColor
            switch p.Protocol </span>{
            case "TCP":<span class="cov0" title="0"> protoColor = tcell.ColorGreen</span>
            case "UDP":<span class="cov0" title="0"> protoColor = tcell.ColorBlue</span>
            case "ICMP":<span class="cov0" title="0"> protoColor = tcell.ColorFuchsia</span>
            }
            <span class="cov0" title="0">table.SetCell(row, 3, tview.NewTableCell(p.Protocol).SetTextColor(protoColor))
            table.SetCell(row, 4, tview.NewTableCell(p.Service))
            table.SetCell(row, 5, tview.NewTableCell(fmt.Sprintf("%d", p.Length)))
            row++</span>
        }
    }
    <span class="cov0" title="0">table.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
        switch event.Key() </span>{
        case tcell.KeyEscape:<span class="cov0" title="0">
            ui.pages.SwitchToPage("main")
            return nil</span>
        case tcell.KeyEnter:<span class="cov0" title="0">
            r, _ := table.GetSelection()
            if r &gt; 0 </span><span class="cov0" title="0">{
                ui.showRawPacketPage(r - 1)
            }</span>
            <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return event</span>
    })
    <span class="cov0" title="0">ui.pages.AddPage("connPackets", table, true, true)
    ui.app.SetFocus(table)</span>
}

// getCPUMemory returns current CPU and memory usage percentages
func (ui *UI) getCPUMemory() (float64, float64) <span class="cov0" title="0">{
    cpuPercents, err := cpu.Percent(0, false)
    var cpuPct float64
    if err == nil &amp;&amp; len(cpuPercents) &gt; 0 </span><span class="cov0" title="0">{
        cpuPct = cpuPercents[0]
    }</span>
    <span class="cov0" title="0">vm, err := mem.VirtualMemory()
    var memPct float64
    if err == nil </span><span class="cov0" title="0">{
        memPct = vm.UsedPercent
    }</span>
    <span class="cov0" title="0">return cpuPct, memPct</span>
}

// colorTag returns a hex code suitable for tview dynamic color tags.
func colorTag(c tcell.Color) string <span class="cov0" title="0">{
    rgb := uint32(c)
    r := (rgb &gt;&gt; 16) &amp; 0xff
    g := (rgb &gt;&gt; 8) &amp; 0xff
    b := rgb &amp; 0xff
    return fmt.Sprintf("#%02x%02x%02x", r, g, b)
}</span>

// showExitMenu displays a btop-style exit menu
func (ui *UI) showExitMenu() <span class="cov0" title="0">{
        modal := tview.NewModal().
                SetText(i18n.T("exit_menu_text")).
                AddButtons([]string{i18n.T("options"), i18n.T("help"), i18n.T("quit"), i18n.T("cancel")}).
                SetDoneFunc(func(buttonIndex int, buttonLabel string) </span><span class="cov0" title="0">{
                        switch buttonIndex </span>{
                        case 0:<span class="cov0" title="0"> // Options
                                ui.pages.RemovePage("exit")
                                ui.showOptionsMenu()</span>
                        case 1:<span class="cov0" title="0"> // Help
                                ui.pages.RemovePage("exit")
                                ui.showHelpPage()</span>
                        case 2:<span class="cov0" title="0"> // Quit
                                ui.Stop()</span>
                        case 3:<span class="cov0" title="0"> // Cancel
                                ui.pages.RemovePage("exit")</span>
                        }
                })
        <span class="cov0" title="0">ui.pages.AddPage("exit", modal, true, true)</span>
}

// showOptionsMenu displays the options/settings menu
func (ui *UI) showOptionsMenu() <span class="cov0" title="0">{
        // Create a basic form to test
        form := tview.NewForm()
        
        // Theme selection
        themeNames := make([]string, 0, len(Themes))
        currentThemeIndex := 0
        for name := range Themes </span><span class="cov0" title="0">{
                themeNames = append(themeNames, name)
        }</span>
        <span class="cov0" title="0">sort.Strings(themeNames)
        
        // Find current theme index
        currentThemeName := ui.getCurrentThemeName()
        for i, name := range themeNames </span><span class="cov0" title="0">{
                if name == currentThemeName </span><span class="cov0" title="0">{
                        currentThemeIndex = i
                        break</span>
                }
        }
        
        // Update interval options
        <span class="cov0" title="0">intervals := []string{"0.5s", "1s", "2s", "5s", "10s"}
        currentIntervalIndex := 1 // default to 1s
        for i, interval := range intervals </span><span class="cov0" title="0">{
                if interval == fmt.Sprintf("%.1fs", ui.updateInterval.Seconds()) </span><span class="cov0" title="0">{
                        currentIntervalIndex = i
                        break</span>
                }
        }
        
        // Graph style options
        <span class="cov0" title="0">graphStyles := []string{"Braille", "Block", "TTY"}
        currentStyleIndex := int(ui.graphStyle)
        
        // Store temporary values for checkboxes
        var tempGradientEnabled = true
        var tempShowLegend = true
        
        // Border style options
        borderStyles := BorderStyleNames()
        currentBorderIndex := 0
        for i, style := range borderStyles </span><span class="cov0" title="0">{
                if style == ui.borderStyle </span><span class="cov0" title="0">{
                        currentBorderIndex = i
                        break</span>
                }
        }
        
        <span class="cov0" title="0">form.
                AddDropDown("Theme", themeNames, currentThemeIndex, func(option string, index int) </span><span class="cov0" title="0">{
                        ui.theme = Themes[option]
                        ui.theme.calculateGradients()
                        ui.applyTheme()
                }</span>).
                AddDropDown("Update Interval", intervals, currentIntervalIndex, func(option string, index int) <span class="cov0" title="0">{
                        duration, _ := time.ParseDuration(option)
                        ui.updateInterval = duration
                        ui.updateStatusBar()
                }</span>).
                AddDropDown("Graph Style", graphStyles, currentStyleIndex, func(option string, index int) <span class="cov0" title="0">{
                        ui.graphStyle = graph.GraphStyle(index)
                }</span>).
                AddDropDown("Border Style", borderStyles, currentBorderIndex, func(option string, index int) <span class="cov0" title="0">{
                        ui.borderStyle = option
                        // Will be applied when the grid is rebuilt
                }</span>).
                AddDropDown("Border Animation", AnimationNames, 0, func(option string, index int) <span class="cov0" title="0">{
                        ui.borderAnimation = option
                        ui.updateAnimationTicker()
                }</span>).
                AddCheckbox("Enable Gradients", tempGradientEnabled, func(checked bool) <span class="cov0" title="0">{
                        tempGradientEnabled = checked
                }</span>).
                AddCheckbox("Show Legend", tempShowLegend, func(checked bool) <span class="cov0" title="0">{
                        tempShowLegend = checked
                }</span>).
                AddButton("Apply", func() <span class="cov0" title="0">{
                        // Apply all settings when Apply is clicked
                        if ui.trafficGraph != nil </span><span class="cov0" title="0">{
                                for _, gw := range ui.trafficGraph.GraphWidgets() </span><span class="cov0" title="0">{
                                        if gw != nil </span><span class="cov0" title="0">{
                                                gw.SetStyle(ui.graphStyle)
                                                gw.SetGradientEnabled(tempGradientEnabled)
                                                gw.ShowLegend(tempShowLegend)
                                        }</span>
                                }
                        }
                        // Rebuild layout to apply new border style
                        <span class="cov0" title="0">ui.rebuildLayout()
                        ui.pages.RemovePage("options")</span>
                }).
                AddButton("Cancel", func() <span class="cov0" title="0">{
                        ui.pages.RemovePage("options")
                }</span>)
        
        <span class="cov0" title="0">form.SetBorder(true).SetTitle("Options").SetTitleAlign(tview.AlignCenter)
        form.SetButtonsAlign(tview.AlignCenter)
        
        // Handle escape key
        form.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                if event.Key() == tcell.KeyEscape </span><span class="cov0" title="0">{
                        ui.pages.RemovePage("options")
                        return nil
                }</span>
                <span class="cov0" title="0">return event</span>
        })
        
        // Create a flex container to center the form
        <span class="cov0" title="0">flex := tview.NewFlex().
                SetDirection(tview.FlexRow).
                AddItem(nil, 0, 1, false).
                AddItem(tview.NewFlex().
                        AddItem(nil, 0, 1, false).
                        AddItem(form, 60, 0, true).
                        AddItem(nil, 0, 1, false), 20, 0, true).
                AddItem(nil, 0, 1, false)
        
        ui.pages.AddPage("options", flex, true, true)</span>
}

// applyTheme applies the current theme to all UI components
func (ui *UI) applyTheme() <span class="cov0" title="0">{
        // Update all component colors
        ui.interfaceList.SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor)
        ui.statsView.SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor)
        ui.trafficGraph.SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor)
        ui.protocolView.SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor)
        ui.connectionTable.SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor)
        ui.detailView.SetBorderColor(ui.theme.BorderColor).SetTitleColor(ui.theme.TitleColor)
        ui.statusBar.SetBackgroundColor(ui.theme.StatusBarBgColor)
        
        // Update graph colors
        if ui.trafficGraph != nil </span><span class="cov0" title="0">{
                for _, gw := range ui.trafficGraph.GraphWidgets() </span><span class="cov0" title="0">{
                        if gw != nil </span><span class="cov0" title="0">{
                                gw.SetColor(ui.theme.PrimaryColor)
                                gw.SetSecondaryColor(ui.theme.SecondaryColor)
                        }</span>
                }
        }
        
        // Don't call Draw() here as it may cause deadlock
        // The display will refresh on the next update cycle
}

// cycleLayoutPreset cycles through available layout presets
func (ui *UI) cycleLayoutPreset() <span class="cov0" title="0">{
        ui.currentLayout = (ui.currentLayout + 1) % len(ui.layoutPresets)
        ui.applyLayoutPreset(ui.currentLayout)
        ui.rebuildLayout()
}</span>

// applyLayoutPreset applies a specific layout configuration
func (ui *UI) applyLayoutPreset(preset int) <span class="cov0" title="0">{
        // Reset all panels visibility
        for _, p := range ui.panels </span><span class="cov0" title="0">{
                p.visible = false
        }</span>
        
        <span class="cov0" title="0">switch preset </span>{
        case 0:<span class="cov0" title="0"> // Default - balanced view
                ui.setPanelVisibility("interfaces", true)
                ui.setPanelVisibility("stats", true)
                ui.setPanelVisibility("traffic", true)
                ui.setPanelVisibility("connections", true)
                ui.setPanelVisibility("details", true)</span>
                
        case 1:<span class="cov0" title="0"> // Compact - essential info only
                ui.setPanelVisibility("interfaces", true)
                ui.setPanelVisibility("traffic", true)
                ui.setPanelVisibility("connections", true)</span>
                
        case 2:<span class="cov0" title="0"> // Detailed - all information
                ui.setPanelVisibility("interfaces", true)
                ui.setPanelVisibility("stats", true)
                ui.setPanelVisibility("traffic", true)
                ui.setPanelVisibility("protocol", true)
                ui.setPanelVisibility("connections", true)
                ui.setPanelVisibility("details", true)
                ui.setPanelVisibility("servicePie", true)
                ui.setPanelVisibility("protocolPie", true)</span>
                
        case 3:<span class="cov0" title="0"> // Minimal - just graphs
                ui.setPanelVisibility("traffic", true)
                ui.setPanelVisibility("connections", true)</span>
        }
}

// setPanelVisibility sets visibility for a specific panel
func (ui *UI) setPanelVisibility(id string, visible bool) <span class="cov0" title="0">{
        for _, p := range ui.panels </span><span class="cov0" title="0">{
                if p.id == id </span><span class="cov0" title="0">{
                        p.visible = visible
                        break</span>
                }
        }
}

// decreaseUpdateInterval makes updates faster
func (ui *UI) decreaseUpdateInterval() <span class="cov0" title="0">{
        if ui.updateInterval &gt; 500*time.Millisecond </span><span class="cov0" title="0">{
                ui.updateInterval -= 250 * time.Millisecond
                ui.updateStatusBar()
        }</span>
}

// increaseUpdateInterval makes updates slower
func (ui *UI) increaseUpdateInterval() <span class="cov0" title="0">{
        if ui.updateInterval &lt; 10*time.Second </span><span class="cov0" title="0">{
                ui.updateInterval += 250 * time.Millisecond
                ui.updateStatusBar()
        }</span>
}

// selectNextInterface selects the next network interface
func (ui *UI) selectNextInterface() <span class="cov0" title="0">{
        count := ui.interfaceList.GetItemCount()
        if count == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">current := ui.interfaceList.GetCurrentItem()
        next := (current + 1) % count
        ui.interfaceList.SetCurrentItem(next)</span>
}

// selectPreviousInterface selects the previous network interface
func (ui *UI) selectPreviousInterface() <span class="cov0" title="0">{
        count := ui.interfaceList.GetItemCount()
        if count == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">current := ui.interfaceList.GetCurrentItem()
        prev := current - 1
        if prev &lt; 0 </span><span class="cov0" title="0">{
                prev = count - 1
        }</span>
        <span class="cov0" title="0">ui.interfaceList.SetCurrentItem(prev)</span>
}

// cycleGraphStyle cycles through available graph rendering styles
func (ui *UI) cycleGraphStyle() <span class="cov0" title="0">{
        styles := []graph.GraphStyle{graph.StyleBraille, graph.StyleBlock, graph.StyleTTY}
        currentIdx := 0
        for i, s := range styles </span><span class="cov0" title="0">{
                if s == ui.graphStyle </span><span class="cov0" title="0">{
                        currentIdx = i
                        break</span>
                }
        }
        <span class="cov0" title="0">ui.graphStyle = styles[(currentIdx+1)%len(styles)]
        
        // Apply to all graphs
        if ui.trafficGraph != nil </span><span class="cov0" title="0">{
                for _, gw := range ui.trafficGraph.GraphWidgets() </span><span class="cov0" title="0">{
                        if gw != nil </span><span class="cov0" title="0">{
                                gw.SetStyle(ui.graphStyle)
                        }</span>
                }
        }
}

// showExportMenu shows data export options
func (ui *UI) showExportMenu() <span class="cov0" title="0">{
        modal := tview.NewModal().
                SetText("Export to: ").
                AddButtons([]string{"CSV", "JSON", "Cancel"}).
                SetDoneFunc(func(buttonIndex int, buttonLabel string) </span><span class="cov0" title="0">{
                        switch buttonIndex </span>{
                        case 0:<span class="cov0" title="0"></span> // CSV
                                // TODO: Implement CSV export
                        case 1:<span class="cov0" title="0"></span> // JSON
                                // TODO: Implement JSON export
                        }
                        <span class="cov0" title="0">ui.pages.RemovePage("export")</span>
                })
        <span class="cov0" title="0">ui.pages.AddPage("export", modal, true, true)</span>
}

// clearFilters clears all active filters
func (ui *UI) clearFilters() <span class="cov0" title="0">{
        ui.filterString = ""
        ui.bpfString = ""
        ui.updateData()
}</span>

// togglePause pauses/resumes data updates
func (ui *UI) togglePause() <span class="cov0" title="0">{
        ui.paused = !ui.paused
        ui.updateStatusBar()
}</span>

// setupMouseHandlers adds mouse click handlers to UI elements
func (ui *UI) setupMouseHandlers() <span class="cov3" title="4">{
        // Add mouse handler for connection table
        ui.connectionTable.SetMouseCapture(func(action tview.MouseAction, event *tcell.EventMouse) (tview.MouseAction, *tcell.EventMouse) </span><span class="cov0" title="0">{
                if action == tview.MouseLeftClick </span><span class="cov0" title="0">{
                        row, _ := ui.connectionTable.GetSelection()
                        if row &gt; 0 &amp;&amp; row-1 &lt; len(ui.connections) </span><span class="cov0" title="0">{
                                ui.selectedConnection = ui.connections[row-1]
                                ui.showConnectionDetails(ui.selectedConnection)
                        }</span>
                } else<span class="cov0" title="0"> if action == tview.MouseRightClick </span><span class="cov0" title="0">{
                        // Show context menu for connection
                        row, _ := ui.connectionTable.GetSelection()
                        if row &gt; 0 &amp;&amp; row-1 &lt; len(ui.connections) </span><span class="cov0" title="0">{
                                ui.showConnectionContextMenu(row - 1)
                        }</span>
                } else<span class="cov0" title="0"> if action == tview.MouseLeftDoubleClick </span><span class="cov0" title="0">{
                        // Double-click to show packet details
                        if ui.selectedConnection != nil </span><span class="cov0" title="0">{
                                ui.showConnectionPacketsPage()
                        }</span>
                }
                <span class="cov0" title="0">return action, event</span>
        })
        
        // Add clickable titles to panels
        <span class="cov3" title="4">ui.setupClickablePanelTitles()
        
        // Add mouse wheel support for interface list
        ui.interfaceList.SetMouseCapture(func(action tview.MouseAction, event *tcell.EventMouse) (tview.MouseAction, *tcell.EventMouse) </span><span class="cov0" title="0">{
                if action == tview.MouseScrollUp </span><span class="cov0" title="0">{
                        ui.selectPreviousInterface()
                }</span> else<span class="cov0" title="0"> if action == tview.MouseScrollDown </span><span class="cov0" title="0">{
                        ui.selectNextInterface()
                }</span>
                <span class="cov0" title="0">return action, event</span>
        })
}

// setupClickablePanelTitles makes panel titles clickable to toggle visibility
func (ui *UI) setupClickablePanelTitles() <span class="cov3" title="4">{
        // Make the traffic graph title clickable to cycle graph styles
        ui.trafficGraph.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                return event
        }</span>)
        
        <span class="cov3" title="4">ui.trafficGraph.SetMouseCapture(func(action tview.MouseAction, event *tcell.EventMouse) (tview.MouseAction, *tcell.EventMouse) </span><span class="cov0" title="0">{
                if action == tview.MouseLeftClick </span><span class="cov0" title="0">{
                        x, y := event.Position()
                        _, titleY, width, _ := ui.trafficGraph.GetRect()
                        // Check if click is on the title bar
                        if y == titleY &amp;&amp; x &gt; 0 &amp;&amp; x &lt; width </span><span class="cov0" title="0">{
                                ui.cycleGraphStyle()
                        }</span>
                }
                <span class="cov0" title="0">return action, event</span>
        })
}

// showConnectionContextMenu displays a context menu for a connection
func (ui *UI) showConnectionContextMenu(connIndex int) <span class="cov0" title="0">{
        if connIndex &lt; 0 || connIndex &gt;= len(ui.connections) </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">conn := ui.connections[connIndex]
        modal := tview.NewModal().
                SetText(fmt.Sprintf("Connection: %s:%d → %s:%d", 
                        conn.SrcIP, conn.SrcPort, conn.DstIP, conn.DstPort)).
                AddButtons([]string{"View Packets", "Export", "Block", "Cancel"}).
                SetDoneFunc(func(buttonIndex int, buttonLabel string) </span><span class="cov0" title="0">{
                        switch buttonIndex </span>{
                        case 0:<span class="cov0" title="0"> // View Packets
                                ui.selectedConnection = conn
                                ui.showConnectionPacketsPage()</span>
                        case 1:<span class="cov0" title="0"></span> // Export
                                // TODO: Export connection data
                        case 2:<span class="cov0" title="0"></span> // Block
                                // TODO: Block connection
                        }
                        <span class="cov0" title="0">ui.pages.RemovePage("connMenu")</span>
                })
        <span class="cov0" title="0">ui.pages.AddPage("connMenu", modal, true, true)</span>
}

// showKillConnectionDialog shows a confirmation dialog for killing a connection
func (ui *UI) showKillConnectionDialog() <span class="cov0" title="0">{
        if ui.selectedConnection == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">modal := tview.NewModal().
                SetText(fmt.Sprintf("Kill connection %s:%d → %s:%d?", 
                        ui.selectedConnection.SrcIP, ui.selectedConnection.SrcPort,
                        ui.selectedConnection.DstIP, ui.selectedConnection.DstPort)).
                AddButtons([]string{"Kill", "Cancel"}).
                SetDoneFunc(func(buttonIndex int, buttonLabel string) </span><span class="cov0" title="0">{
                        if buttonIndex == 0 </span><span class="cov0" title="0">{
                                // TODO: Implement actual connection killing
                                // For now, just remove from display
                                ui.updateData()
                        }</span>
                        <span class="cov0" title="0">ui.pages.RemovePage("killConn")</span>
                })
        <span class="cov0" title="0">ui.pages.AddPage("killConn", modal, true, true)</span>
}

// showConnectionExportMenu shows export options for connection data
func (ui *UI) showConnectionExportMenu() <span class="cov0" title="0">{
        if ui.selectedConnection == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">modal := tview.NewModal().
                SetText("Export connection data as:").
                AddButtons([]string{"CSV", "JSON", "PCAP", "Cancel"}).
                SetDoneFunc(func(buttonIndex int, buttonLabel string) </span><span class="cov0" title="0">{
                        switch buttonIndex </span>{
                        case 0:<span class="cov0" title="0"> // CSV
                                ui.exportConnectionCSV()</span>
                        case 1:<span class="cov0" title="0"> // JSON
                                ui.exportConnectionJSON()</span>
                        case 2:<span class="cov0" title="0"> // PCAP
                                ui.exportConnectionPCAP()</span>
                        }
                        <span class="cov0" title="0">ui.pages.RemovePage("exportConn")</span>
                })
        <span class="cov0" title="0">ui.pages.AddPage("exportConn", modal, true, true)</span>
}

// toggleConnectionMark marks/unmarks a connection for bulk operations
func (ui *UI) toggleConnectionMark() <span class="cov0" title="0">{
        if ui.selectedConnection == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">connKey := fmt.Sprintf("%s:%d-%s:%d-%s", 
                ui.selectedConnection.SrcIP, ui.selectedConnection.SrcPort,
                ui.selectedConnection.DstIP, ui.selectedConnection.DstPort,
                ui.selectedConnection.Protocol)
        
        if ui.markedConnections[connKey] </span><span class="cov0" title="0">{
                delete(ui.markedConnections, connKey)
        }</span> else<span class="cov0" title="0"> {
                ui.markedConnections[connKey] = true
        }</span>
        
        <span class="cov0" title="0">ui.updateConnectionTable()</span>
}

// selectAllConnections marks all visible connections
func (ui *UI) selectAllConnections() <span class="cov0" title="0">{
        for _, conn := range ui.connections </span><span class="cov0" title="0">{
                connKey := fmt.Sprintf("%s:%d-%s:%d-%s", 
                        conn.SrcIP, conn.SrcPort,
                        conn.DstIP, conn.DstPort,
                        conn.Protocol)
                ui.markedConnections[connKey] = true
        }</span>
        <span class="cov0" title="0">ui.updateConnectionTable()</span>
}

// exportConnectionCSV exports connection data to CSV
func (ui *UI) exportConnectionCSV() <span class="cov0" title="0">{
        // TODO: Implement CSV export
        ui.showError("CSV export not yet implemented")
}</span>

// exportConnectionJSON exports connection data to JSON
func (ui *UI) exportConnectionJSON() <span class="cov0" title="0">{
        // TODO: Implement JSON export
        ui.showError("JSON export not yet implemented")
}</span>

// exportConnectionPCAP exports connection packets to PCAP
func (ui *UI) exportConnectionPCAP() <span class="cov0" title="0">{
        // TODO: Implement PCAP export
        ui.showError("PCAP export not yet implemented")
}</span>

// getConnectionKey returns a unique key for a connection
func getConnectionKey(conn *netcap.Connection) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d-%s:%d-%s", 
                conn.SrcIP, conn.SrcPort,
                conn.DstIP, conn.DstPort,
                conn.Protocol)
}</span>

// generateSparkline creates a mini ASCII graph for connection activity
func generateSparkline(values []float64, width int) string <span class="cov0" title="0">{
        if len(values) == 0 || width &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        // Unicode block characters for sparklines
        <span class="cov0" title="0">blocks := []rune{' ', '▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'}
        
        // Find min and max values
        min, max := values[0], values[0]
        for _, v := range values </span><span class="cov0" title="0">{
                if v &lt; min </span><span class="cov0" title="0">{
                        min = v
                }</span>
                <span class="cov0" title="0">if v &gt; max </span><span class="cov0" title="0">{
                        max = v
                }</span>
        }
        
        // Handle case where all values are the same
        <span class="cov0" title="0">if max == min </span><span class="cov0" title="0">{
                if max == 0 </span><span class="cov0" title="0">{
                        return strings.Repeat(string(blocks[0]), width)
                }</span>
                <span class="cov0" title="0">return strings.Repeat(string(blocks[4]), width)</span>
        }
        
        // Sample or interpolate values to fit width
        <span class="cov0" title="0">sparkline := make([]rune, width)
        for i := 0; i &lt; width; i++ </span><span class="cov0" title="0">{
                // Map position to value index
                valueIdx := int(float64(i) * float64(len(values)-1) / float64(width-1))
                if valueIdx &gt;= len(values) </span><span class="cov0" title="0">{
                        valueIdx = len(values) - 1
                }</span>
                
                // Normalize value to 0-8 range
                <span class="cov0" title="0">normalized := (values[valueIdx] - min) / (max - min)
                blockIdx := int(normalized * 8)
                if blockIdx &gt; 8 </span><span class="cov0" title="0">{
                        blockIdx = 8
                }</span>
                <span class="cov0" title="0">if blockIdx &lt; 0 </span><span class="cov0" title="0">{
                        blockIdx = 0
                }</span>
                
                <span class="cov0" title="0">sparkline[i] = blocks[blockIdx]</span>
        }
        
        <span class="cov0" title="0">return string(sparkline)</span>
}

// getConnectionSparkline returns a sparkline for the connection's bandwidth history
func (ui *UI) getConnectionSparkline(connKey string) string <span class="cov0" title="0">{
        history, exists := ui.connectionHistory[connKey]
        if !exists || len(history) == 0 </span><span class="cov0" title="0">{
                return "        " // Empty sparkline
        }</span>
        
        // Keep only recent history (last 20 points)
        <span class="cov0" title="0">if len(history) &gt; 20 </span><span class="cov0" title="0">{
                history = history[len(history)-20:]
                ui.connectionHistory[connKey] = history
        }</span>
        
        <span class="cov0" title="0">return generateSparkline(history, 8)</span> // 8-character wide sparkline
}

// updateConnectionHistory updates the bandwidth history for connections
func (ui *UI) updateConnectionHistory() <span class="cov0" title="0">{
        for _, conn := range ui.connections </span><span class="cov0" title="0">{
                connKey := getConnectionKey(conn)
                
                // Initialize history if needed
                if _, exists := ui.connectionHistory[connKey]; !exists </span><span class="cov0" title="0">{
                        ui.connectionHistory[connKey] = make([]float64, 0, 20)
                }</span>
                
                // Add current size as the data point (we'll track growth over time)
                <span class="cov0" title="0">ui.connectionHistory[connKey] = append(ui.connectionHistory[connKey], float64(conn.Size))
                
                // Limit history size
                if len(ui.connectionHistory[connKey]) &gt; 20 </span><span class="cov0" title="0">{
                        ui.connectionHistory[connKey] = ui.connectionHistory[connKey][1:]
                }</span>
        }
        
        // Clean up old connections not seen in last update
        <span class="cov0" title="0">for key := range ui.connectionHistory </span><span class="cov0" title="0">{
                found := false
                for _, conn := range ui.connections </span><span class="cov0" title="0">{
                        if getConnectionKey(conn) == key </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        // Keep history for a bit in case connection comes back
                        if len(ui.connectionHistory[key]) &gt; 0 </span><span class="cov0" title="0">{
                                // Add a zero to show inactivity
                                ui.connectionHistory[key] = append(ui.connectionHistory[key], 0)
                                if len(ui.connectionHistory[key]) &gt; 20 </span><span class="cov0" title="0">{
                                        ui.connectionHistory[key] = ui.connectionHistory[key][1:]
                                }</span>
                        }
                }
        }
}

// toggleRecording starts or stops session recording
func (ui *UI) toggleRecording() <span class="cov0" title="0">{
        if ui.recording </span><span class="cov0" title="0">{
                // Stop recording
                ui.stopRecording()
        }</span> else<span class="cov0" title="0"> {
                // Start recording
                ui.startRecording()
        }</span>
}

// startRecording begins recording network session
func (ui *UI) startRecording() <span class="cov0" title="0">{
        ui.recording = true
        ui.recordingStart = time.Now()
        ui.sessionData = &amp;SessionRecording{
                StartTime: ui.recordingStart,
                Interface: ui.selectedIface,
                Snapshots: make([]NetworkSnapshot, 0),
                Events:    make([]SessionEvent, 0),
        }
        
        // Add start event
        ui.recordEvent("recording_started", fmt.Sprintf("Started recording on interface %s", ui.selectedIface))
        
        // Update status bar to show recording
        ui.updateStatusBar()
        
        // Show notification
        ui.showNotification("Recording started", 2*time.Second)
}</span>

// stopRecording stops recording and saves the session
func (ui *UI) stopRecording() <span class="cov0" title="0">{
        if !ui.recording || ui.sessionData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">ui.recording = false
        ui.sessionData.EndTime = time.Now()
        
        // Add stop event
        ui.recordEvent("recording_stopped", "Recording stopped")
        
        // Calculate totals
        if stats, ok := ui.networkMonitor.GetInterfaceStats()[ui.selectedIface]; ok </span><span class="cov0" title="0">{
                ui.sessionData.TotalBytes = stats.BytesIn + stats.BytesOut
                ui.sessionData.PacketCount = int(stats.PacketsIn + stats.PacketsOut)
        }</span>
        
        // Save recording
        <span class="cov0" title="0">ui.showSaveRecordingDialog()
        
        // Update status bar
        ui.updateStatusBar()</span>
}

// recordSnapshot captures current network state
func (ui *UI) recordSnapshot() <span class="cov0" title="0">{
        if !ui.recording || ui.sessionData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">snapshot := NetworkSnapshot{
                Timestamp:   time.Now(),
                Connections: ui.connections,
                Stats:       ui.networkMonitor.GetInterfaceStats(),
                BandwidthIn: 0,
                BandwidthOut: 0,
        }
        
        // Get current bandwidth
        in, out := ui.getNetworkRates()
        snapshot.BandwidthIn = in
        snapshot.BandwidthOut = out
        
        ui.sessionData.Snapshots = append(ui.sessionData.Snapshots, snapshot)</span>
}

// recordEvent adds an event to the recording
func (ui *UI) recordEvent(eventType, details string) <span class="cov0" title="0">{
        if !ui.recording || ui.sessionData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">event := SessionEvent{
                Timestamp: time.Now(),
                Type:      eventType,
                Details:   details,
        }
        
        ui.sessionData.Events = append(ui.sessionData.Events, event)</span>
}

// showSaveRecordingDialog shows dialog to save recording
func (ui *UI) showSaveRecordingDialog() <span class="cov0" title="0">{
        // Create input field for filename
        input := tview.NewInputField().
                SetLabel("Save recording as: ").
                SetText(fmt.Sprintf("netmon_session_%s.json", time.Now().Format("20060102_150405"))).
                SetFieldWidth(40)
        
        input.SetDoneFunc(func(key tcell.Key) </span><span class="cov0" title="0">{
                if key == tcell.KeyEnter </span><span class="cov0" title="0">{
                        filename := input.GetText()
                        if filename != "" </span><span class="cov0" title="0">{
                                err := ui.saveRecording(filename)
                                if err != nil </span><span class="cov0" title="0">{
                                        ui.showError(fmt.Sprintf("Failed to save recording: %v", err))
                                }</span> else<span class="cov0" title="0"> {
                                        ui.showNotification(fmt.Sprintf("Recording saved to %s", filename), 3*time.Second)
                                }</span>
                        }
                        <span class="cov0" title="0">ui.pages.RemovePage("saveRecording")</span>
                } else<span class="cov0" title="0"> if key == tcell.KeyEscape </span><span class="cov0" title="0">{
                        ui.pages.RemovePage("saveRecording")
                }</span>
        })
        
        <span class="cov0" title="0">flex := tview.NewFlex().
                SetDirection(tview.FlexRow).
                AddItem(nil, 0, 1, false).
                AddItem(input, 3, 0, true).
                AddItem(nil, 0, 1, false)
        
        ui.pages.AddPage("saveRecording", flex, true, true)
        ui.app.SetFocus(input)</span>
}

// saveRecording saves the recording to a file
func (ui *UI) saveRecording(filename string) error <span class="cov0" title="0">{
        if ui.sessionData == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no recording data")
        }</span>
        
        <span class="cov0" title="0">data, err := json.MarshalIndent(ui.sessionData, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return os.WriteFile(filename, data, 0644)</span>
}

// showReplayMenu shows menu to load and replay sessions
func (ui *UI) showReplayMenu() <span class="cov0" title="0">{
        // List JSON files in current directory
        files, err := filepath.Glob("netmon_session_*.json")
        if err != nil || len(files) == 0 </span><span class="cov0" title="0">{
                ui.showError("No session recordings found")
                return
        }</span>
        
        <span class="cov0" title="0">list := tview.NewList()
        for _, file := range files </span><span class="cov0" title="0">{
                info, _ := os.Stat(file)
                list.AddItem(file, fmt.Sprintf("Size: %d bytes", info.Size()), 0, nil)
        }</span>
        
        <span class="cov0" title="0">list.SetSelectedFunc(func(index int, mainText, secondaryText string, shortcut rune) </span><span class="cov0" title="0">{
                ui.loadAndReplaySession(mainText)
                ui.pages.RemovePage("replayMenu")
        }</span>)
        
        <span class="cov0" title="0">list.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                if event.Key() == tcell.KeyEscape </span><span class="cov0" title="0">{
                        ui.pages.RemovePage("replayMenu")
                        return nil
                }</span>
                <span class="cov0" title="0">return event</span>
        })
        
        <span class="cov0" title="0">list.SetBorder(true).SetTitle("Select Session to Replay")
        ui.pages.AddPage("replayMenu", list, true, true)</span>
}

// loadAndReplaySession loads and replays a recorded session
func (ui *UI) loadAndReplaySession(filename string) <span class="cov0" title="0">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                ui.showError(fmt.Sprintf("Failed to load session: %v", err))
                return
        }</span>
        
        <span class="cov0" title="0">var session SessionRecording
        if err := json.Unmarshal(data, &amp;session); err != nil </span><span class="cov0" title="0">{
                ui.showError(fmt.Sprintf("Failed to parse session: %v", err))
                return
        }</span>
        
        // Start replay
        <span class="cov0" title="0">go ui.replaySession(&amp;session)</span>
}

// replaySession replays a recorded session
func (ui *UI) replaySession(session *SessionRecording) <span class="cov0" title="0">{
        ui.paused = true
        defer func() </span><span class="cov0" title="0">{ ui.paused = false }</span>()
        
        // Show replay notification
        <span class="cov0" title="0">ui.app.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                ui.showNotification(fmt.Sprintf("Replaying session from %s", session.StartTime.Format("2006-01-02 15:04:05")), 3*time.Second)
        }</span>)
        
        // Replay snapshots with timing
        <span class="cov0" title="0">for i, snapshot := range session.Snapshots </span><span class="cov0" title="0">{
                // Calculate delay
                var delay time.Duration
                if i &gt; 0 </span><span class="cov0" title="0">{
                        delay = snapshot.Timestamp.Sub(session.Snapshots[i-1].Timestamp)
                        // Cap delay at 5 seconds to avoid long waits
                        if delay &gt; 5*time.Second </span><span class="cov0" title="0">{
                                delay = 5 * time.Second
                        }</span>
                }
                
                <span class="cov0" title="0">time.Sleep(delay)
                
                // Update UI with snapshot data
                ui.app.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                        ui.connections = snapshot.Connections
                        ui.updateConnectionTable()
                        ui.updateStatsView()
                        ui.updateStatusBar()
                }</span>)
        }
        
        <span class="cov0" title="0">ui.app.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                ui.showNotification("Replay complete", 2*time.Second)
        }</span>)
}

// showNotification displays a temporary notification
func (ui *UI) showNotification(message string, duration time.Duration) <span class="cov0" title="0">{
        notification := tview.NewTextView().
                SetText(message).
                SetTextAlign(tview.AlignCenter).
                SetTextColor(ui.theme.PrimaryColor)
        
        notification.SetBorder(true).
                SetBorderColor(ui.theme.BorderColor).
                SetBackgroundColor(ui.theme.StatusBarBgColor)
        
        // Create a small centered modal
        flex := tview.NewFlex().
                SetDirection(tview.FlexRow).
                AddItem(nil, 0, 1, false).
                AddItem(tview.NewFlex().
                        AddItem(nil, 0, 1, false).
                        AddItem(notification, 40, 0, false).
                        AddItem(nil, 0, 1, false), 3, 0, false).
                AddItem(nil, 0, 1, false)
        
        ui.pages.AddPage("notification", flex, true, false)
        
        // Auto-remove after duration
        go func() </span><span class="cov0" title="0">{
                time.Sleep(duration)
                ui.app.QueueUpdateDraw(func() </span><span class="cov0" title="0">{
                        ui.pages.RemovePage("notification")
                }</span>)
        }()
}

// showAdvancedFilterDialog shows the advanced filter dialog
func (ui *UI) showAdvancedFilterDialog() <span class="cov0" title="0">{
    form := tview.NewForm()
    
    // Filter presets
    presets := []string{"Custom", "HTTP/HTTPS Only", "DNS Only", "Large Transfers (&gt;1MB)", "Active Now", "Local Network Only"}
    
    // Filter fields
    var (
        srcIPFilter    string
        dstIPFilter    string
        portFilter     string
        protocolFilter string
        serviceFilter  string
        minSizeFilter  string
        maxSizeFilter  string
    )
    
    // Parse existing filter if any
    if ui.filterString != "" </span><span class="cov0" title="0">{
        // Simple parsing - could be enhanced
        srcIPFilter = ui.filterString
    }</span>
    
    <span class="cov0" title="0">form.
        AddDropDown("Filter Preset", presets, 0, func(option string, index int) </span><span class="cov0" title="0">{
            switch index </span>{
            case 1:<span class="cov0" title="0"> // HTTP/HTTPS Only
                serviceFilter = "HTTP,HTTPS"
                form.GetFormItemByLabel("Service").(*tview.InputField).SetText(serviceFilter)</span>
            case 2:<span class="cov0" title="0"> // DNS Only
                serviceFilter = "DNS"
                portFilter = "53"
                form.GetFormItemByLabel("Service").(*tview.InputField).SetText(serviceFilter)
                form.GetFormItemByLabel("Port").(*tview.InputField).SetText(portFilter)</span>
            case 3:<span class="cov0" title="0"> // Large Transfers
                minSizeFilter = "1048576" // 1MB
                form.GetFormItemByLabel("Min Size (bytes)").(*tview.InputField).SetText(minSizeFilter)</span>
            case 4:<span class="cov0" title="0"></span> // Active Now
                // Will be handled in filter logic
            case 5:<span class="cov0" title="0"> // Local Network Only
                srcIPFilter = "192.168.*,10.*,172.16.*"
                form.GetFormItemByLabel("Source IP").(*tview.InputField).SetText(srcIPFilter)</span>
            }
        }).
        AddInputField("Source IP", srcIPFilter, 30, nil, func(text string) <span class="cov0" title="0">{
            srcIPFilter = text
        }</span>).
        AddInputField("Dest IP", dstIPFilter, 30, nil, func(text string) <span class="cov0" title="0">{
            dstIPFilter = text
        }</span>).
        AddInputField("Port", portFilter, 15, nil, func(text string) <span class="cov0" title="0">{
            portFilter = text
        }</span>).
        AddInputField("Protocol", protocolFilter, 15, nil, func(text string) <span class="cov0" title="0">{
            protocolFilter = text
        }</span>).
        AddInputField("Service", serviceFilter, 20, nil, func(text string) <span class="cov0" title="0">{
            serviceFilter = text
        }</span>).
        AddInputField("Min Size (bytes)", minSizeFilter, 15, nil, func(text string) <span class="cov0" title="0">{
            minSizeFilter = text
        }</span>).
        AddInputField("Max Size (bytes)", maxSizeFilter, 15, nil, func(text string) <span class="cov0" title="0">{
            maxSizeFilter = text
        }</span>).
        AddButton("Apply", func() <span class="cov0" title="0">{
            // Build filter string
            filter := ui.buildAdvancedFilter(srcIPFilter, dstIPFilter, portFilter, 
                protocolFilter, serviceFilter, minSizeFilter, maxSizeFilter)
            ui.filterString = filter
            ui.updateConnectionTable()
            ui.pages.RemovePage("advancedFilter")
        }</span>).
        AddButton("Clear All", func() <span class="cov0" title="0">{
            ui.filterString = ""
            ui.updateConnectionTable()
            ui.pages.RemovePage("advancedFilter")
        }</span>).
        AddButton("Cancel", func() <span class="cov0" title="0">{
            ui.pages.RemovePage("advancedFilter")
        }</span>)
    
    <span class="cov0" title="0">form.SetBorder(true).SetTitle("Advanced Filters").SetTitleAlign(tview.AlignCenter)
    
    // Center the form
    flex := tview.NewFlex().
        SetDirection(tview.FlexRow).
        AddItem(nil, 0, 1, false).
        AddItem(tview.NewFlex().
            AddItem(nil, 0, 1, false).
            AddItem(form, 60, 0, true).
            AddItem(nil, 0, 1, false), 25, 0, true).
        AddItem(nil, 0, 1, false)
    
    ui.pages.AddPage("advancedFilter", flex, true, true)</span>
}

// buildAdvancedFilter builds a filter string from components
func (ui *UI) buildAdvancedFilter(srcIP, dstIP, port, protocol, service, minSize, maxSize string) string <span class="cov0" title="0">{
    var filters []string
    
    if srcIP != "" </span><span class="cov0" title="0">{
        filters = append(filters, fmt.Sprintf("src:%s", srcIP))
    }</span>
    <span class="cov0" title="0">if dstIP != "" </span><span class="cov0" title="0">{
        filters = append(filters, fmt.Sprintf("dst:%s", dstIP))
    }</span>
    <span class="cov0" title="0">if port != "" </span><span class="cov0" title="0">{
        filters = append(filters, fmt.Sprintf("port:%s", port))
    }</span>
    <span class="cov0" title="0">if protocol != "" </span><span class="cov0" title="0">{
        filters = append(filters, fmt.Sprintf("proto:%s", protocol))
    }</span>
    <span class="cov0" title="0">if service != "" </span><span class="cov0" title="0">{
        filters = append(filters, fmt.Sprintf("svc:%s", service))
    }</span>
    <span class="cov0" title="0">if minSize != "" </span><span class="cov0" title="0">{
        filters = append(filters, fmt.Sprintf("size&gt;%s", minSize))
    }</span>
    <span class="cov0" title="0">if maxSize != "" </span><span class="cov0" title="0">{
        filters = append(filters, fmt.Sprintf("size&lt;%s", maxSize))
    }</span>
    
    <span class="cov0" title="0">return strings.Join(filters, " ")</span>
}

// matchesAdvancedFilter checks if a connection matches the advanced filter
func (ui *UI) matchesAdvancedFilter(conn *netcap.Connection, filter string) bool <span class="cov0" title="0">{
    if filter == "" </span><span class="cov0" title="0">{
        return true
    }</span>
    
    // Parse filter components
    <span class="cov0" title="0">parts := strings.Fields(filter)
    for _, part := range parts </span><span class="cov0" title="0">{
        if !ui.matchesFilterPart(conn, part) </span><span class="cov0" title="0">{
            return false
        }</span>
    }
    
    <span class="cov0" title="0">return true</span>
}

// matchesFilterPart checks if a connection matches a single filter part
func (ui *UI) matchesFilterPart(conn *netcap.Connection, part string) bool <span class="cov0" title="0">{
    // Handle key:value filters
    if strings.Contains(part, ":") </span><span class="cov0" title="0">{
        kv := strings.SplitN(part, ":", 2)
        if len(kv) != 2 </span><span class="cov0" title="0">{
            return true
        }</span>
        
        <span class="cov0" title="0">key, value := kv[0], kv[1]
        switch key </span>{
        case "src":<span class="cov0" title="0">
            return ui.matchesIPPattern(conn.SrcIP.String(), value)</span>
        case "dst":<span class="cov0" title="0">
            return ui.matchesIPPattern(conn.DstIP.String(), value)</span>
        case "port":<span class="cov0" title="0">
            ports := strings.Split(value, ",")
            for _, p := range ports </span><span class="cov0" title="0">{
                if fmt.Sprintf("%d", conn.SrcPort) == p || fmt.Sprintf("%d", conn.DstPort) == p </span><span class="cov0" title="0">{
                    return true
                }</span>
            }
            <span class="cov0" title="0">return false</span>
        case "proto":<span class="cov0" title="0">
            return strings.EqualFold(conn.Protocol, value)</span>
        case "svc":<span class="cov0" title="0">
            services := strings.Split(value, ",")
            for _, s := range services </span><span class="cov0" title="0">{
                if strings.EqualFold(conn.Service, s) </span><span class="cov0" title="0">{
                    return true
                }</span>
            }
            <span class="cov0" title="0">return false</span>
        }
    }
    
    // Handle size comparisons
    <span class="cov0" title="0">if strings.HasPrefix(part, "size&gt;") </span><span class="cov0" title="0">{
        size, err := strconv.ParseUint(part[5:], 10, 64)
        if err == nil </span><span class="cov0" title="0">{
            return conn.Size &gt; size
        }</span>
    }
    <span class="cov0" title="0">if strings.HasPrefix(part, "size&lt;") </span><span class="cov0" title="0">{
        size, err := strconv.ParseUint(part[5:], 10, 64)
        if err == nil </span><span class="cov0" title="0">{
            return conn.Size &lt; size
        }</span>
    }
    
    // Default text search (legacy)
    <span class="cov0" title="0">return strings.Contains(strings.ToLower(conn.SrcIP.String()), strings.ToLower(part)) ||
           strings.Contains(strings.ToLower(conn.DstIP.String()), strings.ToLower(part)) ||
           strings.Contains(strings.ToLower(conn.Service), strings.ToLower(part))</span>
}

// matchesIPPattern checks if an IP matches a pattern (supports wildcards)
func (ui *UI) matchesIPPattern(ip, pattern string) bool <span class="cov0" title="0">{
    patterns := strings.Split(pattern, ",")
    for _, p := range patterns </span><span class="cov0" title="0">{
        p = strings.TrimSpace(p)
        if strings.Contains(p, "*") </span><span class="cov0" title="0">{
            // Convert wildcard to simple prefix match
            prefix := strings.TrimSuffix(p, "*")
            if strings.HasPrefix(ip, prefix) </span><span class="cov0" title="0">{
                return true
            }</span>
        } else<span class="cov0" title="0"> if ip == p </span><span class="cov0" title="0">{
            return true
        }</span>
    }
    <span class="cov0" title="0">return false</span>
}

// getProfilesDir returns the directory for storing UI profiles
func (ui *UI) getProfilesDir() string <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return filepath.Join(homeDir, ".config", "netmon", "profiles")</span>
}

// saveProfile saves the current UI configuration to a profile
func (ui *UI) saveProfile(name string) error <span class="cov0" title="0">{
        profile := UIProfile{
                Name:            name,
                Theme:           ui.getCurrentThemeName(),
                BorderStyle:     ui.borderStyle,
                BorderAnimation: ui.borderAnimation,
                LayoutPreset:    ui.currentLayout,
                UpdateInterval:  fmt.Sprintf("%.1fs", ui.updateInterval.Seconds()),
                GraphStyle:      fmt.Sprintf("%d", ui.graphStyle),
                PanelStates:     make(map[string]bool),
                GradientEnabled: true, // Will be updated from actual graph settings
                ShowLegend:      true, // Will be updated from actual graph settings
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }
        
        // Save panel visibility states
        for _, panel := range ui.panels </span><span class="cov0" title="0">{
                profile.PanelStates[panel.id] = panel.visible
        }</span>
        
        // Get graph settings
        // Note: Currently using default values as GraphWidget doesn't expose these methods
        // TODO: Add methods to GraphWidget to get gradient and legend status
        
        // Create profiles directory if it doesn't exist
        <span class="cov0" title="0">profilesDir := ui.getProfilesDir()
        if err := os.MkdirAll(profilesDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create profiles directory: %w", err)
        }</span>
        
        // Save profile to JSON file
        <span class="cov0" title="0">filename := filepath.Join(profilesDir, name+".json")
        data, err := json.MarshalIndent(profile, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal profile: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := os.WriteFile(filename, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write profile file: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// loadProfile loads a UI profile and applies it
func (ui *UI) loadProfile(name string) error <span class="cov0" title="0">{
        profilesDir := ui.getProfilesDir()
        filename := filepath.Join(profilesDir, name+".json")
        
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read profile file: %w", err)
        }</span>
        
        <span class="cov0" title="0">var profile UIProfile
        if err := json.Unmarshal(data, &amp;profile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal profile: %w", err)
        }</span>
        
        // Apply theme
        <span class="cov0" title="0">if theme, exists := Themes[profile.Theme]; exists </span><span class="cov0" title="0">{
                ui.theme = theme
                ui.theme.calculateGradients()
                ui.applyTheme()
        }</span>
        
        // Apply border settings
        <span class="cov0" title="0">ui.borderStyle = profile.BorderStyle
        ui.borderAnimation = profile.BorderAnimation
        ui.updateAnimationTicker()
        
        // Apply layout preset
        ui.currentLayout = profile.LayoutPreset
        ui.applyLayoutPreset(ui.currentLayout)
        
        // Apply update interval
        if duration, err := time.ParseDuration(profile.UpdateInterval); err == nil </span><span class="cov0" title="0">{
                ui.updateInterval = duration
                ui.updateStatusBar()
        }</span>
        
        // Apply graph style
        <span class="cov0" title="0">switch profile.GraphStyle </span>{
        case "0":<span class="cov0" title="0">
                ui.graphStyle = graph.StyleBraille</span>
        case "1":<span class="cov0" title="0">
                ui.graphStyle = graph.StyleBlock</span>
        case "2":<span class="cov0" title="0">
                ui.graphStyle = graph.StyleTTY</span>
        }
        
        // Apply panel visibility states
        <span class="cov0" title="0">for _, panel := range ui.panels </span><span class="cov0" title="0">{
                if visible, exists := profile.PanelStates[panel.id]; exists </span><span class="cov0" title="0">{
                        panel.visible = visible
                }</span>
        }
        
        // Apply graph settings
        <span class="cov0" title="0">if ui.trafficGraph != nil </span><span class="cov0" title="0">{
                for _, gw := range ui.trafficGraph.GraphWidgets() </span><span class="cov0" title="0">{
                        if gw != nil </span><span class="cov0" title="0">{
                                gw.SetStyle(ui.graphStyle)
                                gw.SetGradientEnabled(profile.GradientEnabled)
                                gw.ShowLegend(profile.ShowLegend)
                        }</span>
                }
        }
        
        // Rebuild layout to apply all changes
        <span class="cov0" title="0">ui.rebuildLayout()
        
        return nil</span>
}

// listProfiles returns a list of available profile names
func (ui *UI) listProfiles() []string <span class="cov0" title="0">{
        profilesDir := ui.getProfilesDir()
        files, err := os.ReadDir(profilesDir)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        
        <span class="cov0" title="0">var profiles []string
        for _, file := range files </span><span class="cov0" title="0">{
                if !file.IsDir() &amp;&amp; strings.HasSuffix(file.Name(), ".json") </span><span class="cov0" title="0">{
                        name := strings.TrimSuffix(file.Name(), ".json")
                        profiles = append(profiles, name)
                }</span>
        }
        
        <span class="cov0" title="0">sort.Strings(profiles)
        return profiles</span>
}

// showProfilesMenu displays a menu for saving/loading profiles
func (ui *UI) showProfilesMenu() <span class="cov0" title="0">{
        profiles := ui.listProfiles()
        
        list := tview.NewList()
        list.SetBorder(true).SetTitle("UI Profiles").SetTitleAlign(tview.AlignCenter)
        
        // Add save option
        list.AddItem("Save Current Profile...", "Save current UI configuration", 's', func() </span><span class="cov0" title="0">{
                ui.showSaveProfileDialog()
        }</span>)
        
        // Add separator
        <span class="cov0" title="0">list.AddItem("", "--- Saved Profiles ---", 0, nil)
        
        // Add existing profiles
        for _, profile := range profiles </span><span class="cov0" title="0">{
                p := profile // Capture for closure
                list.AddItem(fmt.Sprintf("Load: %s", p), "Load this profile", 0, func() </span><span class="cov0" title="0">{
                        if err := ui.loadProfile(p); err != nil </span><span class="cov0" title="0">{
                                ui.showError(fmt.Sprintf("Failed to load profile: %v", err))
                        }</span> else<span class="cov0" title="0"> {
                                ui.pages.RemovePage("profiles")
                        }</span>
                })
        }
        
        // Add cancel option
        <span class="cov0" title="0">list.AddItem("", "", 0, nil)
        list.AddItem("Cancel", "Return to main screen", 'c', func() </span><span class="cov0" title="0">{
                ui.pages.RemovePage("profiles")
        }</span>)
        
        <span class="cov0" title="0">list.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                if event.Key() == tcell.KeyEscape </span><span class="cov0" title="0">{
                        ui.pages.RemovePage("profiles")
                        return nil
                }</span>
                <span class="cov0" title="0">return event</span>
        })
        
        <span class="cov0" title="0">ui.pages.AddPage("profiles", list, true, true)</span>
}

// showSaveProfileDialog shows a dialog for saving a new profile
func (ui *UI) showSaveProfileDialog() <span class="cov0" title="0">{
        form := tview.NewForm()
        var profileName string
        
        form.AddInputField("Profile Name", "", 30, nil, func(text string) </span><span class="cov0" title="0">{
                profileName = text
        }</span>)
        
        <span class="cov0" title="0">form.AddButton("Save", func() </span><span class="cov0" title="0">{
                if profileName == "" </span><span class="cov0" title="0">{
                        ui.showError("Profile name cannot be empty")
                        return
                }</span>
                <span class="cov0" title="0">if err := ui.saveProfile(profileName); err != nil </span><span class="cov0" title="0">{
                        ui.showError(fmt.Sprintf("Failed to save profile: %v", err))
                }</span> else<span class="cov0" title="0"> {
                        ui.pages.RemovePage("save-profile")
                        ui.pages.RemovePage("profiles")
                }</span>
        })
        
        <span class="cov0" title="0">form.AddButton("Cancel", func() </span><span class="cov0" title="0">{
                ui.pages.RemovePage("save-profile")
        }</span>)
        
        <span class="cov0" title="0">form.SetBorder(true).SetTitle("Save Profile").SetTitleAlign(tview.AlignCenter)
        form.SetButtonsAlign(tview.AlignCenter)
        
        form.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                if event.Key() == tcell.KeyEscape </span><span class="cov0" title="0">{
                        ui.pages.RemovePage("save-profile")
                        return nil
                }</span>
                <span class="cov0" title="0">return event</span>
        })
        
        // Center the form
        <span class="cov0" title="0">flex := tview.NewFlex().
                SetDirection(tview.FlexRow).
                AddItem(nil, 0, 1, false).
                AddItem(tview.NewFlex().
                        AddItem(nil, 0, 1, false).
                        AddItem(form, 50, 0, true).
                        AddItem(nil, 0, 1, false), 10, 0, true).
                AddItem(nil, 0, 1, false)
        
        ui.pages.AddPage("save-profile", flex, true, true)</span>
}

// SetStartupVisualization sets a visualization to show on startup
func (ui *UI) SetStartupVisualization(vizID string, fullscreen bool) <span class="cov0" title="0">{
        ui.startupVizID = vizID
        ui.startupFullscreen = fullscreen
}</span>

// SetStartupDashboard sets a dashboard to show on startup
func (ui *UI) SetStartupDashboard(dashboardName string, fullscreen bool) <span class="cov0" title="0">{
        ui.startupDashboard = dashboardName
        ui.startupFullscreen = fullscreen
}</span>

// LoadProfile loads a UI profile by name (public method for CLI)
func (ui *UI) LoadProfile(name string) error <span class="cov0" title="0">{
        return ui.loadProfile(name)
}</span>

// showVisualizationFullscreen shows a single visualization in fullscreen
func (ui *UI) showVisualizationFullscreen(vizID string) <span class="cov0" title="0">{
        viz := GlobalRegistry.Get(vizID)
        if viz == nil </span><span class="cov0" title="0">{
                ui.showError(fmt.Sprintf("Visualization '%s' not found", vizID))
                return
        }</span>
        
        <span class="cov0" title="0">viz.SetTheme(ui.theme)
        view := viz.CreateView()
        
        // Update visualization periodically
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(ui.updateInterval)
                defer ticker.Stop()
                
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                viz.Update(ui.networkMonitor)
                                ui.app.Draw()</span>
                        case &lt;-ui.stopChan:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
        
        // Handle input
        <span class="cov0" title="0">if inputHandler, ok := view.(interface{ SetInputCapture(func(*tcell.EventKey) *tcell.EventKey) }); ok </span><span class="cov0" title="0">{
                inputHandler.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                        switch event.Key() </span>{
                        case tcell.KeyEscape:<span class="cov0" title="0">
                                ui.pages.SwitchToPage("main")
                                return nil</span>
                        }
                        
                        <span class="cov0" title="0">switch event.Rune() </span>{
                        case 'q', 'Q':<span class="cov0" title="0">
                                ui.app.Stop()
                                return nil</span>
                        }
                        
                        <span class="cov0" title="0">return event</span>
                })
        }
        
        <span class="cov0" title="0">ui.pages.AddAndSwitchToPage("viz-fullscreen", view, true)</span>
}

// showDashboard shows a dashboard
func (ui *UI) showDashboard(layout DashboardLayout) <span class="cov0" title="0">{
        dashboard := NewDashboard(GlobalRegistry, ui.networkMonitor)
        dashboard.SetTheme(ui.theme)
        dashboard.SetLayout(layout)
        
        // Update dashboard periodically
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(ui.updateInterval)
                defer ticker.Stop()
                
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                dashboard.Update()
                                ui.app.Draw()</span>
                        case &lt;-ui.stopChan:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
        
        // Wrap in a container with controls
        <span class="cov0" title="0">container := tview.NewFlex().
                SetDirection(tview.FlexRow).
                AddItem(dashboard, 0, 1, true).
                AddItem(ui.statusBar, 1, 0, false)
        
        container.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                switch event.Key() </span>{
                case tcell.KeyEscape:<span class="cov0" title="0">
                        ui.pages.SwitchToPage("main")
                        return nil</span>
                }
                
                <span class="cov0" title="0">switch event.Rune() </span>{
                case 'q', 'Q':<span class="cov0" title="0">
                        ui.showExitMenu()
                        return nil</span>
                case 'd', 'D':<span class="cov0" title="0">
                        ui.showDashboardMenu()
                        return nil</span>
                }
                
                <span class="cov0" title="0">return event</span>
        })
        
        <span class="cov0" title="0">ui.pages.AddAndSwitchToPage("dashboard", container, true)</span>
}

// showDashboardMenu shows the dashboard selection menu
func (ui *UI) showDashboardMenu() <span class="cov0" title="0">{
        list := tview.NewList()
        list.SetBorder(true).SetTitle("Dashboards").SetTitleAlign(tview.AlignCenter)
        
        // Add dashboard builder option
        list.AddItem("Create New Dashboard...", "Build a custom dashboard", 'n', func() </span><span class="cov0" title="0">{
                ui.showDashboardBuilder()
        }</span>)
        
        <span class="cov0" title="0">list.AddItem("", "--- Preset Dashboards ---", 0, nil)
        
        // Add preset dashboards
        dm := NewDashboardManager()
        for _, name := range dm.ListDashboards() </span><span class="cov0" title="0">{
                n := name // Capture for closure
                layout, _ := dm.GetDashboard(n)
                list.AddItem(layout.Name, layout.Description, 0, func() </span><span class="cov0" title="0">{
                        ui.pages.RemovePage("dashboard-menu")
                        ui.showDashboard(layout)
                }</span>)
        }
        
        // Add saved custom dashboards
        <span class="cov0" title="0">list.AddItem("", "--- Saved Dashboards ---", 0, nil)
        
        // TODO: Load saved dashboards from profile directory
        
        list.AddItem("", "", 0, nil)
        list.AddItem("Cancel", "Return to main view", 'c', func() </span><span class="cov0" title="0">{
                ui.pages.RemovePage("dashboard-menu")
        }</span>)
        
        <span class="cov0" title="0">list.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey </span><span class="cov0" title="0">{
                if event.Key() == tcell.KeyEscape </span><span class="cov0" title="0">{
                        ui.pages.RemovePage("dashboard-menu")
                        return nil
                }</span>
                <span class="cov0" title="0">return event</span>
        })
        
        <span class="cov0" title="0">ui.pages.AddPage("dashboard-menu", list, true, true)</span>
}

// showDashboardBuilder shows the dashboard builder interface
func (ui *UI) showDashboardBuilder() <span class="cov0" title="0">{
        builder := NewDashboardBuilder(ui.app, ui.networkMonitor, GlobalRegistry)
        builder.SetTheme(ui.theme)
        
        builder.SetOnSave(func(layout DashboardLayout) </span><span class="cov0" title="0">{
                // Save dashboard to profile
                profilesDir := ui.getProfilesDir()
                dashboardsDir := filepath.Join(profilesDir, "dashboards")
                
                if err := os.MkdirAll(dashboardsDir, 0755); err != nil </span><span class="cov0" title="0">{
                        ui.showError(fmt.Sprintf("Failed to create dashboards directory: %v", err))
                        return
                }</span>
                
                // Generate filename
                <span class="cov0" title="0">filename := fmt.Sprintf("%s_%d.json", 
                        strings.ReplaceAll(layout.Name, " ", "_"),
                        time.Now().Unix())
                
                filepath := filepath.Join(dashboardsDir, filename)
                
                data, err := json.MarshalIndent(layout, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        ui.showError(fmt.Sprintf("Failed to marshal dashboard: %v", err))
                        return
                }</span>
                
                <span class="cov0" title="0">if err := os.WriteFile(filepath, data, 0644); err != nil </span><span class="cov0" title="0">{
                        ui.showError(fmt.Sprintf("Failed to save dashboard: %v", err))
                        return
                }</span>
                
                <span class="cov0" title="0">ui.pages.RemovePage("dashboard-builder")
                ui.showDashboard(layout)</span>
        })
        
        <span class="cov0" title="0">builder.SetOnCancel(func() </span><span class="cov0" title="0">{
                ui.pages.RemovePage("dashboard-builder")
        }</span>)
        
        <span class="cov0" title="0">ui.pages.AddPage("dashboard-builder", builder.GetView(), true, true)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package ui

import (
        "github.com/gdamore/tcell/v2"
        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
)

// Visualization represents a network data visualization
type Visualization interface {
        // GetID returns the unique identifier for this visualization
        GetID() string
        
        // GetName returns the display name
        GetName() string
        
        // GetDescription returns a brief description
        GetDescription() string
        
        // CreateView creates the tview primitive for this visualization
        CreateView() tview.Primitive
        
        // Update updates the visualization with new data
        Update(monitor *netcap.NetworkMonitor)
        
        // SetTheme sets the color theme
        SetTheme(theme Theme)
        
        // GetMinSize returns minimum width and height requirements
        GetMinSize() (width, height int)
        
        // SupportsFullscreen indicates if this viz works well fullscreen
        SupportsFullscreen() bool
}

// VisualizationRegistry manages available visualizations
type VisualizationRegistry struct {
        visualizations map[string]func() Visualization
}

// NewVisualizationRegistry creates a new registry
func NewVisualizationRegistry() *VisualizationRegistry <span class="cov1" title="1">{
        return &amp;VisualizationRegistry{
                visualizations: make(map[string]func() Visualization),
        }
}</span>

// Register adds a visualization to the registry
func (r *VisualizationRegistry) Register(id string, factory func() Visualization) <span class="cov10" title="12">{
        r.visualizations[id] = factory
}</span>

// Get creates a new instance of a visualization
func (r *VisualizationRegistry) Get(id string) Visualization <span class="cov0" title="0">{
        if factory, exists := r.visualizations[id]; exists </span><span class="cov0" title="0">{
                return factory()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// List returns all available visualization IDs
func (r *VisualizationRegistry) List() []string <span class="cov0" title="0">{
        ids := make([]string, 0, len(r.visualizations))
        for id := range r.visualizations </span><span class="cov0" title="0">{
                ids = append(ids, id)
        }</span>
        <span class="cov0" title="0">return ids</span>
}

// GetAll returns all available visualizations
func (r *VisualizationRegistry) GetAll() []Visualization <span class="cov0" title="0">{
        vizs := make([]Visualization, 0, len(r.visualizations))
        for _, factory := range r.visualizations </span><span class="cov0" title="0">{
                vizs = append(vizs, factory())
        }</span>
        <span class="cov0" title="0">return vizs</span>
}

// BaseVisualization provides common functionality for visualizations
type BaseVisualization struct {
        view      tview.Primitive
        theme     Theme
        monitor   *netcap.NetworkMonitor
        textView  *tview.TextView
        borderBox *tview.Box
}

// SetTheme sets the color theme
func (b *BaseVisualization) SetTheme(theme Theme) <span class="cov0" title="0">{
        b.theme = theme
        if b.textView != nil </span><span class="cov0" title="0">{
                b.textView.SetBorderColor(theme.BorderColor).
                        SetTitleColor(theme.TitleColor).
                        SetBackgroundColor(tcell.ColorDefault)
        }</span>
}

// GetMinSize returns default minimum size
func (b *BaseVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 30, 10
}</span>

// SupportsFullscreen returns default value
func (b *BaseVisualization) SupportsFullscreen() bool <span class="cov0" title="0">{
        return true
}</span>

// DashboardLayout represents a saved dashboard configuration
type DashboardLayout struct {
        Name           string                      `json:"name"`
        Description    string                      `json:"description"`
        Visualizations []DashboardVisualization    `json:"visualizations"`
        GridRows       int                         `json:"grid_rows"`
        GridCols       int                         `json:"grid_cols"`
}

// DashboardVisualization represents a visualization in a dashboard
type DashboardVisualization struct {
        ID       string `json:"id"`
        Row      int    `json:"row"`
        Col      int    `json:"col"`
        RowSpan  int    `json:"row_span"`
        ColSpan  int    `json:"col_span"`
        Settings map[string]interface{} `json:"settings,omitempty"`
}

// Dashboard manages a collection of visualizations
type Dashboard struct {
        *tview.Grid
        visualizations map[string]Visualization
        layout         DashboardLayout
        registry       *VisualizationRegistry
        theme          Theme
        monitor        *netcap.NetworkMonitor
}

// NewDashboard creates a new dashboard
func NewDashboard(registry *VisualizationRegistry, monitor *netcap.NetworkMonitor) *Dashboard <span class="cov0" title="0">{
        return &amp;Dashboard{
                Grid:           tview.NewGrid(),
                visualizations: make(map[string]Visualization),
                registry:       registry,
                monitor:        monitor,
        }
}</span>

// SetLayout applies a dashboard layout
func (d *Dashboard) SetLayout(layout DashboardLayout) error <span class="cov0" title="0">{
        d.Clear()
        d.layout = layout
        
        // Set grid dimensions
        rows := make([]int, layout.GridRows)
        cols := make([]int, layout.GridCols)
        d.SetRows(rows...).SetColumns(cols...)
        
        // Add visualizations
        for _, vizConfig := range layout.Visualizations </span><span class="cov0" title="0">{
                viz := d.registry.Get(vizConfig.ID)
                if viz == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">viz.SetTheme(d.theme)
                view := viz.CreateView()
                
                d.AddItem(view, vizConfig.Row, vizConfig.Col, 
                        vizConfig.RowSpan, vizConfig.ColSpan, 0, 0, false)
                
                d.visualizations[vizConfig.ID] = viz</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// Update updates all visualizations in the dashboard
func (d *Dashboard) Update() <span class="cov0" title="0">{
        for _, viz := range d.visualizations </span><span class="cov0" title="0">{
                viz.Update(d.monitor)
        }</span>
}

// SetTheme sets the theme for all visualizations
func (d *Dashboard) SetTheme(theme Theme) <span class="cov0" title="0">{
        d.theme = theme
        for _, viz := range d.visualizations </span><span class="cov0" title="0">{
                viz.SetTheme(theme)
        }</span>
}

// Global visualization registry
var GlobalRegistry = NewVisualizationRegistry()

// Register all visualizations
func init() <span class="cov1" title="1">{
        // Register all visualization types
        GlobalRegistry.Register("sankey", func() Visualization </span><span class="cov0" title="0">{ return NewSankeyVisualization() }</span>)
        <span class="cov1" title="1">GlobalRegistry.Register("radial", func() Visualization </span><span class="cov0" title="0">{ return NewRadialConnectionVisualization() }</span>)
        <span class="cov1" title="1">GlobalRegistry.Register("heartbeat", func() Visualization </span><span class="cov0" title="0">{ return NewHeartbeatVisualization() }</span>)
        <span class="cov1" title="1">GlobalRegistry.Register("heatmap", func() Visualization </span><span class="cov0" title="0">{ return NewHeatmapVisualization() }</span>)
        <span class="cov1" title="1">GlobalRegistry.Register("matrix", func() Visualization </span><span class="cov0" title="0">{ return NewMatrixRainVisualization() }</span>)
        <span class="cov1" title="1">GlobalRegistry.Register("speedometer", func() Visualization </span><span class="cov0" title="0">{ return NewSpeedometerVisualization() }</span>)
        <span class="cov1" title="1">GlobalRegistry.Register("sunburst", func() Visualization </span><span class="cov0" title="0">{ return NewSunburstVisualization() }</span>)
        <span class="cov1" title="1">GlobalRegistry.Register("weather", func() Visualization </span><span class="cov0" title="0">{ return NewWeatherMapVisualization() }</span>)
        <span class="cov1" title="1">GlobalRegistry.Register("constellation", func() Visualization </span><span class="cov0" title="0">{ return NewConstellationVisualization() }</span>)
        <span class="cov1" title="1">GlobalRegistry.Register("dns_timeline", func() Visualization </span><span class="cov0" title="0">{ return NewDNSTimelineVisualization() }</span>)
        <span class="cov1" title="1">GlobalRegistry.Register("packet_dist", func() Visualization </span><span class="cov0" title="0">{ return NewPacketDistributionVisualization() }</span>)
        <span class="cov1" title="1">GlobalRegistry.Register("conn_lifetime", func() Visualization </span><span class="cov0" title="0">{ return NewConnectionLifetimeVisualization() }</span>)
        // GlobalRegistry.Register("security_dashboard", func() Visualization { return NewSecurityDashboardVisualization() })
        // GlobalRegistry.Register("protocol_dashboard", func() Visualization { return NewProtocolDashboardVisualization() })
}</pre>
		
		<pre class="file" id="file25" style="display: none">package ui

import (
        "fmt"
        "strings"
        "time"

        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
)

// ConnectionLifetimeVisualization shows how long connections stay alive
type ConnectionLifetimeVisualization struct {
        BaseVisualization
        lifetimes map[string]time.Duration // connection key -&gt; lifetime
}

// NewConnectionLifetimeVisualization creates a new connection lifetime visualization
func NewConnectionLifetimeVisualization() Visualization <span class="cov0" title="0">{
        c := &amp;ConnectionLifetimeVisualization{
                lifetimes: make(map[string]time.Duration),
        }
        c.textView = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        c.textView.SetBorder(true).
                SetTitle("Connection Lifetime Chart")
        return c
}</span>

// GetID returns the unique identifier
func (c *ConnectionLifetimeVisualization) GetID() string <span class="cov0" title="0">{
        return "conn_lifetime"
}</span>

// GetName returns the display name
func (c *ConnectionLifetimeVisualization) GetName() string <span class="cov0" title="0">{
        return "Connection Lifetime"
}</span>

// GetDescription returns a description
func (c *ConnectionLifetimeVisualization) GetDescription() string <span class="cov0" title="0">{
        return "Shows how long connections stay alive"
}</span>

// CreateView creates the view
func (c *ConnectionLifetimeVisualization) CreateView() tview.Primitive <span class="cov0" title="0">{
        return c.textView
}</span>

// Update updates the visualization
func (c *ConnectionLifetimeVisualization) Update(monitor *netcap.NetworkMonitor) <span class="cov0" title="0">{
        c.monitor = monitor
        
        // Get connections from all interfaces
        var connections []*netcap.Connection
        for interfaceName := range monitor.GetInterfaceStats() </span><span class="cov0" title="0">{
                interfaceConns := monitor.GetConnections(interfaceName)
                connections = append(connections, interfaceConns...)
        }</span>
        
        // Calculate lifetimes
        <span class="cov0" title="0">for _, conn := range connections </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s:%d-%s:%d", 
                        conn.SrcIP, conn.SrcPort, 
                        conn.DstIP, conn.DstPort)
                
                // Since FirstSeen is not available, estimate lifetime based on packets and size
                lifetime := time.Duration(conn.Packets) * time.Millisecond * 100 // rough estimate
                c.lifetimes[key] = lifetime
        }</span>
        
        // Categorize lifetimes
        <span class="cov0" title="0">categories := []struct {
                name     string
                min      time.Duration
                max      time.Duration
                count    int
                examples []string
        }{
                {"[0-1s]", 0, 1 * time.Second, 0, []string{}},
                {"[1-10s]", 1 * time.Second, 10 * time.Second, 0, []string{}},
                {"[10-60s]", 10 * time.Second, 60 * time.Second, 0, []string{}},
                {"[1-5m]", 1 * time.Minute, 5 * time.Minute, 0, []string{}},
                {"[5-30m]", 5 * time.Minute, 30 * time.Minute, 0, []string{}},
                {"[30m+]", 30 * time.Minute, 24 * time.Hour * 365, 0, []string{}},
        }
        
        // Count connections in each category
        for _, conn := range connections </span><span class="cov0" title="0">{
                // Since FirstSeen is not available, estimate lifetime based on packets and size
                lifetime := time.Duration(conn.Packets) * time.Millisecond * 100 // rough estimate
                service := getServiceName(conn)
                
                for i := range categories </span><span class="cov0" title="0">{
                        if lifetime &gt;= categories[i].min &amp;&amp; lifetime &lt; categories[i].max </span><span class="cov0" title="0">{
                                categories[i].count++
                                if len(categories[i].examples) &lt; 3 </span><span class="cov0" title="0">{
                                        categories[i].examples = append(categories[i].examples, service)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }
        
        // Find max count for scaling
        <span class="cov0" title="0">maxCount := 0
        for _, cat := range categories </span><span class="cov0" title="0">{
                if cat.count &gt; maxCount </span><span class="cov0" title="0">{
                        maxCount = cat.count
                }</span>
        }
        
        <span class="cov0" title="0">if maxCount == 0 </span><span class="cov0" title="0">{
                maxCount = 1
        }</span>
        
        // Build visualization
        <span class="cov0" title="0">var output strings.Builder
        
        output.WriteString("[white]Connection Age Distribution\n\n")
        
        // Draw histogram
        barWidth := 40
        totalConns := len(connections)
        
        for _, cat := range categories </span><span class="cov0" title="0">{
                percentage := 0.0
                if totalConns &gt; 0 </span><span class="cov0" title="0">{
                        percentage = float64(cat.count) / float64(totalConns) * 100
                }</span>
                
                <span class="cov0" title="0">barLen := int(float64(cat.count) / float64(maxCount) * float64(barWidth))
                
                // Create bar
                var bar string
                color := c.getAgeColor(cat.name)
                
                if barLen &gt; 0 </span><span class="cov0" title="0">{
                        // Use different characters based on percentage
                        if percentage &gt; 40 </span><span class="cov0" title="0">{
                                bar = strings.Repeat("█", barLen)
                        }</span> else<span class="cov0" title="0"> if percentage &gt; 20 </span><span class="cov0" title="0">{
                                bar = strings.Repeat("▓", barLen)
                        }</span> else<span class="cov0" title="0"> if percentage &gt; 10 </span><span class="cov0" title="0">{
                                bar = strings.Repeat("▒", barLen)
                        }</span> else<span class="cov0" title="0"> {
                                bar = strings.Repeat("░", barLen)
                        }</span>
                }
                
                // Format line
                <span class="cov0" title="0">output.WriteString(fmt.Sprintf("%-8s %s%s[white]%s %3d (%.1f%%)\n",
                        cat.name,
                        color,
                        bar,
                        strings.Repeat(" ", barWidth-len(bar)),
                        cat.count,
                        percentage))
                
                // Show example services
                if len(cat.examples) &gt; 0 </span><span class="cov0" title="0">{
                        examples := strings.Join(cat.examples, ", ")
                        output.WriteString(fmt.Sprintf("         └─ %s\n", examples))
                }</span>
        }
        
        // Statistics
        <span class="cov0" title="0">output.WriteString("\n[white]Connection Statistics:\n")
        output.WriteString(fmt.Sprintf("Total Connections: %d\n", totalConns))
        
        // Calculate average lifetime
        var totalLifetime time.Duration
        for _, lifetime := range c.lifetimes </span><span class="cov0" title="0">{
                totalLifetime += lifetime
        }</span>
        
        <span class="cov0" title="0">if len(c.lifetimes) &gt; 0 </span><span class="cov0" title="0">{
                avgLifetime := totalLifetime / time.Duration(len(c.lifetimes))
                output.WriteString(fmt.Sprintf("Average Lifetime: %s\n", c.formatDuration(avgLifetime)))
        }</span>
        
        // Long-lived connections
        <span class="cov0" title="0">output.WriteString("\n[white]Long-lived Connections:\n")
        longLived := c.getLongLivedConnections(connections, 5*time.Minute)
        
        for i, conn := range longLived </span><span class="cov0" title="0">{
                if i &gt;= 5 </span><span class="cov0" title="0">{
                        break</span>
                }
                
                // Since FirstSeen is not available, estimate lifetime based on packets and size
                <span class="cov0" title="0">lifetime := time.Duration(conn.Packets) * time.Millisecond * 100 // rough estimate
                service := getServiceName(conn)
                
                output.WriteString(fmt.Sprintf("• %s:%d → %s (%s) - %s\n",
                        conn.SrcIP, conn.SrcPort,
                        service,
                        conn.Protocol,
                        c.formatDuration(lifetime)))</span>
        }
        
        // Connection type analysis
        <span class="cov0" title="0">output.WriteString("\n[white]By Service Type:\n")
        serviceLifetimes := c.getServiceLifetimes(connections)
        
        for service, stats := range serviceLifetimes </span><span class="cov0" title="0">{
                avgLifetime := stats.total / time.Duration(stats.count)
                color := c.getServiceColor(service)
                
                bar := strings.Repeat("▪", int(avgLifetime.Minutes())+1)
                if len(bar) &gt; 20 </span><span class="cov0" title="0">{
                        bar = bar[:20] + "..."
                }</span>
                
                <span class="cov0" title="0">output.WriteString(fmt.Sprintf("%s%-10s[white] %s avg: %s\n",
                        color,
                        service,
                        bar,
                        c.formatDuration(avgLifetime)))</span>
        }
        
        <span class="cov0" title="0">c.textView.SetText(output.String())</span>
}

type lifetimeStats struct {
        total time.Duration
        count int
}

// getServiceLifetimes calculates average lifetimes by service
func (c *ConnectionLifetimeVisualization) getServiceLifetimes(connections []*netcap.Connection) map[string]*lifetimeStats <span class="cov0" title="0">{
        stats := make(map[string]*lifetimeStats)
        
        for _, conn := range connections </span><span class="cov0" title="0">{
                service := getServiceName(conn)
                // Since FirstSeen is not available, estimate lifetime based on packets and size
                lifetime := time.Duration(conn.Packets) * time.Millisecond * 100 // rough estimate
                
                if stats[service] == nil </span><span class="cov0" title="0">{
                        stats[service] = &amp;lifetimeStats{}
                }</span>
                
                <span class="cov0" title="0">stats[service].total += lifetime
                stats[service].count++</span>
        }
        
        <span class="cov0" title="0">return stats</span>
}

// getLongLivedConnections returns connections alive longer than threshold
func (c *ConnectionLifetimeVisualization) getLongLivedConnections(connections []*netcap.Connection, threshold time.Duration) []*netcap.Connection <span class="cov0" title="0">{
        var longLived []*netcap.Connection
        
        for _, conn := range connections </span><span class="cov0" title="0">{
                // Since FirstSeen is not available, estimate lifetime based on packets and size
                lifetime := time.Duration(conn.Packets) * time.Millisecond * 100 // rough estimate
                if lifetime &gt;= threshold </span><span class="cov0" title="0">{
                        longLived = append(longLived, conn)
                }</span>
        }
        
        // Sort by lifetime (longest first)
        <span class="cov0" title="0">for i := 0; i &lt; len(longLived); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(longLived); j++ </span><span class="cov0" title="0">{
                        // Since FirstSeen is not available, estimate lifetime based on packets and size
                        lifetime1 := time.Duration(longLived[i].Packets) * time.Millisecond * 100
                        lifetime2 := time.Duration(longLived[j].Packets) * time.Millisecond * 100
                        if lifetime2 &gt; lifetime1 </span><span class="cov0" title="0">{
                                longLived[i], longLived[j] = longLived[j], longLived[i]
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return longLived</span>
}

// formatDuration formats a duration in human-readable form
func (c *ConnectionLifetimeVisualization) formatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d &lt; time.Second </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dms", d.Milliseconds())
        }</span> else<span class="cov0" title="0"> if d &lt; time.Minute </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1fs", d.Seconds())
        }</span> else<span class="cov0" title="0"> if d &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1fm", d.Minutes())
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%.1fh", d.Hours())
        }</span>
}

// getAgeColor returns color based on connection age
func (c *ConnectionLifetimeVisualization) getAgeColor(category string) string <span class="cov0" title="0">{
        switch category </span>{
        case "[0-1s]":<span class="cov0" title="0">
                return "[red]"</span>
        case "[1-10s]":<span class="cov0" title="0">
                return "[yellow]"</span>
        case "[10-60s]":<span class="cov0" title="0">
                return "[green]"</span>
        case "[1-5m]":<span class="cov0" title="0">
                return "[cyan]"</span>
        case "[5-30m]":<span class="cov0" title="0">
                return "[blue]"</span>
        case "[30m+]":<span class="cov0" title="0">
                return "[magenta]"</span>
        default:<span class="cov0" title="0">
                return "[white]"</span>
        }
}

// getServiceColor returns color for a service
func (c *ConnectionLifetimeVisualization) getServiceColor(service string) string <span class="cov0" title="0">{
        switch service </span>{
        case "HTTPS", "HTTP":<span class="cov0" title="0">
                return "[green]"</span>
        case "SSH":<span class="cov0" title="0">
                return "[yellow]"</span>
        case "DNS":<span class="cov0" title="0">
                return "[blue]"</span>
        case "Database":<span class="cov0" title="0">
                return "[magenta]"</span>
        default:<span class="cov0" title="0">
                return "[white]"</span>
        }
}

// GetMinSize returns minimum size requirements
func (c *ConnectionLifetimeVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 60, 35
}</pre>
		
		<pre class="file" id="file26" style="display: none">package ui

import (
        "fmt"
        "math"
        "math/rand"
        "strings"
        "time"

        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
)

// ConstellationVisualization shows active ports as stars
type ConstellationVisualization struct {
        BaseVisualization
        stars []star
}

type star struct {
        x, y     int
        port     int
        size     int
        twinkle  int
}

// NewConstellationVisualization creates a new constellation visualization
func NewConstellationVisualization() Visualization <span class="cov0" title="0">{
        c := &amp;ConstellationVisualization{
                stars: make([]star, 0),
        }
        c.textView = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        c.textView.SetBorder(true).
                SetTitle("Port Activity Constellation")
        return c
}</span>

// GetID returns the unique identifier
func (c *ConstellationVisualization) GetID() string <span class="cov0" title="0">{
        return "constellation"
}</span>

// GetName returns the display name
func (c *ConstellationVisualization) GetName() string <span class="cov0" title="0">{
        return "Port Constellation"
}</span>

// GetDescription returns a description
func (c *ConstellationVisualization) GetDescription() string <span class="cov0" title="0">{
        return "Visualize active ports as stars in the network sky"
}</span>

// CreateView creates the view
func (c *ConstellationVisualization) CreateView() tview.Primitive <span class="cov0" title="0">{
        return c.textView
}</span>

// Update updates the visualization
func (c *ConstellationVisualization) Update(monitor *netcap.NetworkMonitor) <span class="cov0" title="0">{
        c.monitor = monitor
        
        // Get active ports from connections
        var connections []*netcap.Connection
        for interfaceName := range monitor.GetInterfaceStats() </span><span class="cov0" title="0">{
                interfaceConns := monitor.GetConnections(interfaceName)
                connections = append(connections, interfaceConns...)
        }</span>
        <span class="cov0" title="0">portActivity := make(map[int]int)
        
        for _, conn := range connections </span><span class="cov0" title="0">{
                // Assume connection is active if packets &gt; 0 and recent activity
                if conn.Packets &gt; 0 &amp;&amp; time.Since(conn.LastSeen) &lt; 30*time.Second </span><span class="cov0" title="0">{
                        portActivity[int(conn.DstPort)]++
                        portActivity[int(conn.SrcPort)]++
                }</span>
        }
        
        // Create constellation
        <span class="cov0" title="0">width, height := 60, 25
        centerX, centerY := width/2, height/2
        
        // Update or create stars for active ports
        c.updateStars(portActivity, width, height, centerX, centerY)
        
        // Create grid
        grid := make([][]rune, height)
        for i := range grid </span><span class="cov0" title="0">{
                grid[i] = make([]rune, width)
                for j := range grid[i] </span><span class="cov0" title="0">{
                        grid[i][j] = ' '
                }</span>
        }
        
        // Draw YOUR HOST at center
        <span class="cov0" title="0">hostLabel := "YOUR HOST"
        for i, ch := range hostLabel </span><span class="cov0" title="0">{
                x := centerX - len(hostLabel)/2 + i
                if x &gt;= 0 &amp;&amp; x &lt; width </span><span class="cov0" title="0">{
                        grid[centerY][x] = ch
                }</span>
        }
        
        // Draw stars
        <span class="cov0" title="0">for _, s := range c.stars </span><span class="cov0" title="0">{
                if s.x &gt;= 0 &amp;&amp; s.x &lt; width &amp;&amp; s.y &gt;= 0 &amp;&amp; s.y &lt; height </span><span class="cov0" title="0">{
                        // Choose star character based on size and twinkle
                        char := c.getStarChar(s.size, s.twinkle)
                        grid[s.y][s.x] = char
                        
                        // Draw port number near star for major ports
                        if s.size &gt; 2 </span><span class="cov0" title="0">{
                                label := fmt.Sprintf("%d", s.port)
                                labelY := s.y + 1
                                labelX := s.x - len(label)/2
                                
                                if labelY &lt; height </span><span class="cov0" title="0">{
                                        for i, ch := range label </span><span class="cov0" title="0">{
                                                x := labelX + i
                                                if x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; labelY &gt;= 0 &amp;&amp; labelY &lt; height </span><span class="cov0" title="0">{
                                                        if grid[labelY][x] == ' ' </span><span class="cov0" title="0">{
                                                                grid[labelY][x] = ch
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }
        
        // Draw connections between related ports
        <span class="cov0" title="0">c.drawConnections(grid, width, height)
        
        // Convert grid to string
        var output strings.Builder
        for _, row := range grid </span><span class="cov0" title="0">{
                output.WriteString(string(row) + "\n")
        }</span>
        
        // Legend
        <span class="cov0" title="0">output.WriteString("\n[white]Port Activity (connections):\n")
        
        // Sort ports by activity
        type portInfo struct {
                port  int
                count int
        }
        var ports []portInfo
        for port, count := range portActivity </span><span class="cov0" title="0">{
                ports = append(ports, portInfo{port, count})
        }</span>
        
        // Sort by count
        <span class="cov0" title="0">for i := 0; i &lt; len(ports); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(ports); j++ </span><span class="cov0" title="0">{
                        if ports[j].count &gt; ports[i].count </span><span class="cov0" title="0">{
                                ports[i], ports[j] = ports[j], ports[i]
                        }</span>
                }
        }
        
        // Show top 10 ports
        <span class="cov0" title="0">if len(ports) &gt; 10 </span><span class="cov0" title="0">{
                ports = ports[:10]
        }</span>
        
        <span class="cov0" title="0">for _, p := range ports </span><span class="cov0" title="0">{
                service := c.getServiceForPort(p.port)
                starChar := c.getStarChar(c.getStarSize(p.count), 0)
                color := c.getPortColor(p.port)
                
                output.WriteString(fmt.Sprintf("%s%c %5d %-10s [%d connections][white]\n",
                        color, starChar, p.port, service, p.count))
        }</span>
        
        <span class="cov0" title="0">c.textView.SetText(output.String())</span>
}

// updateStars updates star positions and properties
func (c *ConstellationVisualization) updateStars(portActivity map[int]int, width, height, centerX, centerY int) <span class="cov0" title="0">{
        // Update existing stars and remove inactive ones
        newStars := make([]star, 0)
        
        for port, activity := range portActivity </span><span class="cov0" title="0">{
                // Find existing star
                found := false
                for i, s := range c.stars </span><span class="cov0" title="0">{
                        if s.port == port </span><span class="cov0" title="0">{
                                // Update existing star
                                c.stars[i].size = c.getStarSize(activity)
                                c.stars[i].twinkle = (c.stars[i].twinkle + 1) % 3
                                newStars = append(newStars, c.stars[i])
                                found = true
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        // Create new star
                        angle := float64(port%360) * math.Pi / 180
                        distance := float64(10 + rand.Intn(10))
                        
                        x := centerX + int(distance*math.Cos(angle))
                        y := centerY + int(distance*math.Sin(angle)/2) // Aspect ratio
                        
                        newStars = append(newStars, star{
                                x:       x,
                                y:       y,
                                port:    port,
                                size:    c.getStarSize(activity),
                                twinkle: rand.Intn(3),
                        })
                }</span>
        }
        
        <span class="cov0" title="0">c.stars = newStars</span>
}

// getStarSize returns star size based on activity
func (c *ConstellationVisualization) getStarSize(activity int) int <span class="cov0" title="0">{
        switch </span>{
        case activity &gt; 50:<span class="cov0" title="0">
                return 4</span>
        case activity &gt; 20:<span class="cov0" title="0">
                return 3</span>
        case activity &gt; 10:<span class="cov0" title="0">
                return 2</span>
        case activity &gt; 5:<span class="cov0" title="0">
                return 1</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// getStarChar returns the character for a star
func (c *ConstellationVisualization) getStarChar(size, twinkle int) rune <span class="cov0" title="0">{
        switch size </span>{
        case 4:<span class="cov0" title="0">
                return '★'</span>
        case 3:<span class="cov0" title="0">
                return '✦'</span>
        case 2:<span class="cov0" title="0">
                if twinkle == 0 </span><span class="cov0" title="0">{
                        return '✦'
                }</span>
                <span class="cov0" title="0">return '·'</span>
        case 1:<span class="cov0" title="0">
                if twinkle == 0 </span><span class="cov0" title="0">{
                        return '·'
                }</span>
                <span class="cov0" title="0">return '.'</span>
        default:<span class="cov0" title="0">
                return '·'</span>
        }
}

// drawConnections draws lines between related ports
func (c *ConstellationVisualization) drawConnections(grid [][]rune, width, height int) <span class="cov0" title="0">{
        // Draw connections between common port pairs
        pairs := [][2]int{
                {80, 443},   // HTTP/HTTPS
                {20, 21},    // FTP
                {25, 587},   // SMTP
                {110, 995},  // POP3
                {143, 993},  // IMAP
        }
        
        for _, pair := range pairs </span><span class="cov0" title="0">{
                var s1, s2 *star
                for i := range c.stars </span><span class="cov0" title="0">{
                        if c.stars[i].port == pair[0] </span><span class="cov0" title="0">{
                                s1 = &amp;c.stars[i]
                        }</span>
                        <span class="cov0" title="0">if c.stars[i].port == pair[1] </span><span class="cov0" title="0">{
                                s2 = &amp;c.stars[i]
                        }</span>
                }
                
                <span class="cov0" title="0">if s1 != nil &amp;&amp; s2 != nil </span><span class="cov0" title="0">{
                        // Draw dotted line between stars
                        steps := 10
                        for i := 1; i &lt; steps; i++ </span><span class="cov0" title="0">{
                                x := s1.x + (s2.x-s1.x)*i/steps
                                y := s1.y + (s2.y-s1.y)*i/steps
                                
                                if x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height &amp;&amp; i%2 == 0 </span><span class="cov0" title="0">{
                                        if grid[y][x] == ' ' </span><span class="cov0" title="0">{
                                                grid[y][x] = '·'
                                        }</span>
                                }
                        }
                }
        }
}

// getServiceForPort returns service name for a port
func (c *ConstellationVisualization) getServiceForPort(port int) string <span class="cov0" title="0">{
        services := map[int]string{
                20:    "FTP-DATA",
                21:    "FTP",
                22:    "SSH",
                23:    "TELNET",
                25:    "SMTP",
                53:    "DNS",
                80:    "HTTP",
                110:   "POP3",
                143:   "IMAP",
                443:   "HTTPS",
                445:   "SMB",
                587:   "SMTP-TLS",
                993:   "IMAPS",
                995:   "POP3S",
                1433:  "MSSQL",
                3306:  "MySQL",
                3389:  "RDP",
                5432:  "PostgreSQL",
                5900:  "VNC",
                6379:  "Redis",
                8080:  "HTTP-ALT",
                8443:  "HTTPS-ALT",
                9090:  "WebSocket",
                27017: "MongoDB",
        }
        
        if service, ok := services[port]; ok </span><span class="cov0" title="0">{
                return service
        }</span>
        
        <span class="cov0" title="0">if port &lt; 1024 </span><span class="cov0" title="0">{
                return "System"
        }</span>
        <span class="cov0" title="0">return "Dynamic"</span>
}

// getPortColor returns color for a port
func (c *ConstellationVisualization) getPortColor(port int) string <span class="cov0" title="0">{
        switch </span>{
        case port == 80 || port == 443:<span class="cov0" title="0">
                return "[green]"</span>
        case port == 22:<span class="cov0" title="0">
                return "[yellow]"</span>
        case port == 21 || port == 23:<span class="cov0" title="0">
                return "[red]"</span>
        case port &lt; 1024:<span class="cov0" title="0">
                return "[blue]"</span>
        default:<span class="cov0" title="0">
                return "[white]"</span>
        }
}

// GetMinSize returns minimum size requirements
func (c *ConstellationVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 60, 30
}</pre>
		
		<pre class="file" id="file27" style="display: none">package ui

import (
        "fmt"
        "strings"
        "time"

        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
)

// DNSTimelineVisualization shows DNS queries over time
type DNSTimelineVisualization struct {
        BaseVisualization
        queries []dnsQuery
        maxQueries int
}

type dnsQuery struct {
        timestamp time.Time
        domain    string
        queryType string
}

// NewDNSTimelineVisualization creates a new DNS timeline visualization
func NewDNSTimelineVisualization() Visualization <span class="cov0" title="0">{
        d := &amp;DNSTimelineVisualization{
                queries:    make([]dnsQuery, 0),
                maxQueries: 20,
        }
        d.textView = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        d.textView.SetBorder(true).
                SetTitle("DNS Query Timeline")
        return d
}</span>

// GetID returns the unique identifier
func (d *DNSTimelineVisualization) GetID() string <span class="cov0" title="0">{
        return "dns_timeline"
}</span>

// GetName returns the display name
func (d *DNSTimelineVisualization) GetName() string <span class="cov0" title="0">{
        return "DNS Timeline"
}</span>

// GetDescription returns a description
func (d *DNSTimelineVisualization) GetDescription() string <span class="cov0" title="0">{
        return "Track DNS lookups over time"
}</span>

// CreateView creates the view
func (d *DNSTimelineVisualization) CreateView() tview.Primitive <span class="cov0" title="0">{
        return d.textView
}</span>

// Update updates the visualization
func (d *DNSTimelineVisualization) Update(monitor *netcap.NetworkMonitor) <span class="cov0" title="0">{
        d.monitor = monitor
        
        // Get DNS connections from port 53
        var connections []*netcap.Connection
        for interfaceName := range monitor.GetInterfaceStats() </span><span class="cov0" title="0">{
                interfaceConns := monitor.GetConnections(interfaceName)
                connections = append(connections, interfaceConns...)
        }</span>
        
        // Extract DNS queries
        <span class="cov0" title="0">for _, conn := range connections </span><span class="cov0" title="0">{
                // Check for DNS traffic and recent activity
                if conn.DstPort == 53 &amp;&amp; conn.Packets &gt; 0 &amp;&amp; time.Since(conn.LastSeen) &lt; 30*time.Second </span><span class="cov0" title="0">{
                        // Check if this is a new query
                        isNew := true
                        for _, q := range d.queries </span><span class="cov0" title="0">{
                                if q.timestamp.Equal(conn.LastSeen) </span><span class="cov0" title="0">{
                                        isNew = false
                                        break</span>
                                }
                        }
                        
                        <span class="cov0" title="0">if isNew </span><span class="cov0" title="0">{
                                domain := d.extractDomain(conn)
                                d.queries = append(d.queries, dnsQuery{
                                        timestamp: conn.LastSeen,
                                        domain:    domain,
                                        queryType: "A", // Default, would need packet inspection for actual type
                                })
                        }</span>
                }
        }
        
        // Keep only recent queries
        <span class="cov0" title="0">if len(d.queries) &gt; d.maxQueries </span><span class="cov0" title="0">{
                d.queries = d.queries[len(d.queries)-d.maxQueries:]
        }</span>
        
        // Build timeline visualization
        <span class="cov0" title="0">var output strings.Builder
        
        // Timeline header
        output.WriteString("[white]Time     Domain\n")
        output.WriteString("──────── " + strings.Repeat("─", 50) + "\n")
        
        // Draw timeline
        now := time.Now()
        timelineWidth := 58
        
        for i, query := range d.queries </span><span class="cov0" title="0">{
                // Time column
                timeStr := query.timestamp.Format("15:04:05")
                output.WriteString(fmt.Sprintf("%s ", timeStr))
                
                // Timeline bar
                elapsed := now.Sub(query.timestamp)
                barPos := int(float64(timelineWidth) * (1 - elapsed.Seconds()/300)) // 5 min window
                
                if barPos &lt; 0 </span><span class="cov0" title="0">{
                        barPos = 0
                }</span>
                <span class="cov0" title="0">if barPos &gt;= timelineWidth </span><span class="cov0" title="0">{
                        barPos = timelineWidth - 1
                }</span>
                
                // Draw timeline
                <span class="cov0" title="0">output.WriteString("├")
                for j := 0; j &lt; timelineWidth; j++ </span><span class="cov0" title="0">{
                        if j == barPos </span><span class="cov0" title="0">{
                                output.WriteString(d.getDomainColor(query.domain))
                                output.WriteString("●")
                                output.WriteString("[white]")
                        }</span> else<span class="cov0" title="0"> {
                                output.WriteString("─")
                        }</span>
                }
                
                // Domain name
                <span class="cov0" title="0">domain := d.truncateDomain(query.domain, 30)
                output.WriteString(fmt.Sprintf(" %s\n", domain))
                
                // Add connecting line for next item
                if i &lt; len(d.queries)-1 </span><span class="cov0" title="0">{
                        output.WriteString("         │\n")
                }</span>
        }
        
        // Footer with statistics
        <span class="cov0" title="0">output.WriteString("\n[white]DNS Query Statistics:\n")
        
        // Domain frequency
        domainCount := make(map[string]int)
        for _, q := range d.queries </span><span class="cov0" title="0">{
                domainCount[q.domain]++
        }</span>
        
        // Sort by frequency
        <span class="cov0" title="0">type domainFreq struct {
                domain string
                count  int
        }
        var frequencies []domainFreq
        for domain, count := range domainCount </span><span class="cov0" title="0">{
                frequencies = append(frequencies, domainFreq{domain, count})
        }</span>
        
        // Sort
        <span class="cov0" title="0">for i := 0; i &lt; len(frequencies); i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(frequencies); j++ </span><span class="cov0" title="0">{
                        if frequencies[j].count &gt; frequencies[i].count </span><span class="cov0" title="0">{
                                frequencies[i], frequencies[j] = frequencies[j], frequencies[i]
                        }</span>
                }
        }
        
        // Show top domains
        <span class="cov0" title="0">output.WriteString("\nTop Queried Domains:\n")
        for i, freq := range frequencies </span><span class="cov0" title="0">{
                if i &gt;= 5 </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">bar := strings.Repeat("█", freq.count*2)
                color := d.getDomainColor(freq.domain)
                output.WriteString(fmt.Sprintf("%s%-30s %s %d queries[white]\n",
                        color,
                        d.truncateDomain(freq.domain, 30),
                        bar,
                        freq.count))</span>
        }
        
        // Query rate
        <span class="cov0" title="0">if len(d.queries) &gt; 1 </span><span class="cov0" title="0">{
                timeSpan := d.queries[len(d.queries)-1].timestamp.Sub(d.queries[0].timestamp)
                if timeSpan &gt; 0 </span><span class="cov0" title="0">{
                        rate := float64(len(d.queries)) / timeSpan.Minutes()
                        output.WriteString(fmt.Sprintf("\nQuery Rate: %.1f queries/minute\n", rate))
                }</span>
        }
        
        <span class="cov0" title="0">d.textView.SetText(output.String())</span>
}

// extractDomain extracts domain from connection
func (d *DNSTimelineVisualization) extractDomain(conn *netcap.Connection) string <span class="cov0" title="0">{
        // In a real implementation, this would parse DNS packets
        // For now, we'll generate realistic domain names based on destination
        
        // Common domains for simulation
        domains := []string{
                "google.com",
                "youtube.com",
                "facebook.com",
                "amazon.com",
                "netflix.com",
                "github.com",
                "stackoverflow.com",
                "reddit.com",
                "twitter.com",
                "linkedin.com",
                "microsoft.com",
                "apple.com",
                "cloudflare.com",
                "akamai.net",
                "fastly.net",
        }
        
        // Use connection info to deterministically pick a domain
        index := (int(conn.SrcPort) + int(conn.DstPort)) % len(domains)
        
        // Sometimes add subdomains
        if int(conn.SrcPort)%3 == 0 </span><span class="cov0" title="0">{
                subdomains := []string{"www", "api", "cdn", "mail", "app"}
                sub := subdomains[int(conn.SrcPort)%len(subdomains)]
                return fmt.Sprintf("%s.%s", sub, domains[index])
        }</span>
        
        <span class="cov0" title="0">return domains[index]</span>
}

// truncateDomain truncates long domain names
func (d *DNSTimelineVisualization) truncateDomain(domain string, maxLen int) string <span class="cov0" title="0">{
        if len(domain) &lt;= maxLen </span><span class="cov0" title="0">{
                return domain
        }</span>
        <span class="cov0" title="0">return domain[:maxLen-3] + "..."</span>
}

// getDomainColor returns color based on domain type
func (d *DNSTimelineVisualization) getDomainColor(domain string) string <span class="cov0" title="0">{
        switch </span>{
        case strings.Contains(domain, "google") || strings.Contains(domain, "youtube"):<span class="cov0" title="0">
                return "[green]"</span>
        case strings.Contains(domain, "facebook") || strings.Contains(domain, "twitter"):<span class="cov0" title="0">
                return "[blue]"</span>
        case strings.Contains(domain, "amazon") || strings.Contains(domain, "netflix"):<span class="cov0" title="0">
                return "[yellow]"</span>
        case strings.Contains(domain, "github") || strings.Contains(domain, "stackoverflow"):<span class="cov0" title="0">
                return "[magenta]"</span>
        case strings.Contains(domain, "cloudflare") || strings.Contains(domain, "akamai"):<span class="cov0" title="0">
                return "[cyan]"</span>
        default:<span class="cov0" title="0">
                return "[white]"</span>
        }
}

// GetMinSize returns minimum size requirements
func (d *DNSTimelineVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 70, 30
}</pre>
		
		<pre class="file" id="file28" style="display: none">package ui

import (
        "fmt"
        "strings"
        "time"

        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
)

// HeartbeatVisualization shows network health as EKG-style graphs
type HeartbeatVisualization struct {
        BaseVisualization
        latencyHistory []float64
        packetHistory  []float64
        lossHistory    []float64
        maxHistory     int
}

// NewHeartbeatVisualization creates a new heartbeat visualization
func NewHeartbeatVisualization() Visualization <span class="cov0" title="0">{
        h := &amp;HeartbeatVisualization{
                maxHistory:     60,
                latencyHistory: make([]float64, 0, 60),
                packetHistory:  make([]float64, 0, 60),
                lossHistory:    make([]float64, 0, 60),
        }
        h.textView = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        h.textView.SetBorder(true).
                SetTitle("Network Heartbeat Monitor")
        return h
}</span>

// GetID returns the unique identifier
func (h *HeartbeatVisualization) GetID() string <span class="cov0" title="0">{
        return "heartbeat"
}</span>

// GetName returns the display name
func (h *HeartbeatVisualization) GetName() string <span class="cov0" title="0">{
        return "Network Heartbeat"
}</span>

// GetDescription returns a description
func (h *HeartbeatVisualization) GetDescription() string <span class="cov0" title="0">{
        return "EKG-style visualization of network health"
}</span>

// CreateView creates the view
func (h *HeartbeatVisualization) CreateView() tview.Primitive <span class="cov0" title="0">{
        return h.textView
}</span>

// Update updates the visualization
func (h *HeartbeatVisualization) Update(monitor *netcap.NetworkMonitor) <span class="cov0" title="0">{
        h.monitor = monitor
        
        // Simulate network metrics (in real implementation, these would come from actual measurements)
        // For now, we'll calculate from connection data
        var connections []*netcap.Connection
        for interfaceName := range monitor.GetInterfaceStats() </span><span class="cov0" title="0">{
                interfaceConns := monitor.GetConnections(interfaceName)
                connections = append(connections, interfaceConns...)
        }</span>
        
        // Calculate average latency (simulated)
        <span class="cov0" title="0">var avgLatency float64 = 20.0 // Base latency
        activeConns := 0
        var totalPackets uint64
        
        for _, conn := range connections </span><span class="cov0" title="0">{
                if time.Since(conn.LastSeen) &lt; 5*time.Second </span><span class="cov0" title="0">{
                        activeConns++
                        totalPackets += conn.Packets
                }</span>
        }
        
        // Simulate latency based on active connections
        <span class="cov0" title="0">if activeConns &gt; 0 </span><span class="cov0" title="0">{
                avgLatency += float64(activeConns) * 2
        }</span>
        
        // Add some variation
        <span class="cov0" title="0">variation := float64(time.Now().UnixNano()%10) - 5
        avgLatency += variation
        
        // Update histories
        h.latencyHistory = append(h.latencyHistory, avgLatency)
        h.packetHistory = append(h.packetHistory, float64(totalPackets))
        h.lossHistory = append(h.lossHistory, float64(activeConns%3)) // Simulated loss
        
        // Trim histories
        if len(h.latencyHistory) &gt; h.maxHistory </span><span class="cov0" title="0">{
                h.latencyHistory = h.latencyHistory[len(h.latencyHistory)-h.maxHistory:]
        }</span>
        <span class="cov0" title="0">if len(h.packetHistory) &gt; h.maxHistory </span><span class="cov0" title="0">{
                h.packetHistory = h.packetHistory[len(h.packetHistory)-h.maxHistory:]
        }</span>
        <span class="cov0" title="0">if len(h.lossHistory) &gt; h.maxHistory </span><span class="cov0" title="0">{
                h.lossHistory = h.lossHistory[len(h.lossHistory)-h.maxHistory:]
        }</span>
        
        // Draw the heartbeat graphs
        <span class="cov0" title="0">var output strings.Builder
        
        // Latency graph
        output.WriteString("[yellow]Latency (ms)[white]\n")
        h.drawHeartbeat(&amp;output, h.latencyHistory, 5, '┌', '┐', '└', '┘', '─')
        output.WriteString("\n\n")
        
        // Packet rate graph
        output.WriteString("[green]Packet Rate[white]\n")
        h.drawPulse(&amp;output, h.packetHistory, 5, '╱', '╲')
        output.WriteString("\n\n")
        
        // Packet loss indicators
        output.WriteString("[red]Packet Loss[white]\n")
        h.drawLossIndicators(&amp;output, h.lossHistory)
        output.WriteString("\n\n")
        
        // Health summary
        health := h.calculateHealth(avgLatency, float64(totalPackets), h.lossHistory)
        output.WriteString(fmt.Sprintf("Network Health: %s\n", health))
        output.WriteString(fmt.Sprintf("Active Connections: %d | Avg Latency: %.1fms | Total Packets: %d",
                activeConns, avgLatency, totalPackets))
        
        h.textView.SetText(output.String())</span>
}

// drawHeartbeat draws an EKG-style heartbeat line
func (h *HeartbeatVisualization) drawHeartbeat(output *strings.Builder, data []float64, height int, upChar, downChar, bottomUp, bottomDown, flatChar rune) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Normalize data
        <span class="cov0" title="0">maxVal := 0.0
        for _, v := range data </span><span class="cov0" title="0">{
                if v &gt; maxVal </span><span class="cov0" title="0">{
                        maxVal = v
                }</span>
        }
        <span class="cov0" title="0">if maxVal == 0 </span><span class="cov0" title="0">{
                maxVal = 1
        }</span>
        
        // Create height map
        <span class="cov0" title="0">for row := height - 1; row &gt;= 0; row-- </span><span class="cov0" title="0">{
                for i, val := range data </span><span class="cov0" title="0">{
                        normalized := int(val / maxVal * float64(height))
                        
                        if row == normalized </span><span class="cov0" title="0">{
                                // Peak of heartbeat
                                if i &gt; 0 &amp;&amp; i &lt; len(data)-1 </span><span class="cov0" title="0">{
                                        prevNorm := int(data[i-1] / maxVal * float64(height))
                                        nextNorm := int(data[i+1] / maxVal * float64(height))
                                        
                                        if prevNorm &lt; normalized &amp;&amp; nextNorm &lt; normalized </span><span class="cov0" title="0">{
                                                // Peak
                                                output.WriteRune(upChar)
                                        }</span> else<span class="cov0" title="0"> if prevNorm &gt; normalized &amp;&amp; nextNorm &gt; normalized </span><span class="cov0" title="0">{
                                                // Valley
                                                output.WriteRune(downChar)
                                        }</span> else<span class="cov0" title="0"> {
                                                output.WriteRune(flatChar)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        output.WriteRune(flatChar)
                                }</span>
                        } else<span class="cov0" title="0"> if row == 0 </span><span class="cov0" title="0">{
                                // Baseline
                                output.WriteRune('─')
                        }</span> else<span class="cov0" title="0"> {
                                output.WriteRune(' ')
                        }</span>
                }
                <span class="cov0" title="0">output.WriteString("\n")</span>
        }
}

// drawPulse draws a pulse-style graph
func (h *HeartbeatVisualization) drawPulse(output *strings.Builder, data []float64, height int, upChar, downChar rune) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Normalize data
        <span class="cov0" title="0">maxVal := 0.0
        for _, v := range data </span><span class="cov0" title="0">{
                if v &gt; maxVal </span><span class="cov0" title="0">{
                        maxVal = v
                }</span>
        }
        <span class="cov0" title="0">if maxVal == 0 </span><span class="cov0" title="0">{
                maxVal = 1
        }</span>
        
        <span class="cov0" title="0">for row := height - 1; row &gt;= 0; row-- </span><span class="cov0" title="0">{
                for i, val := range data </span><span class="cov0" title="0">{
                        normalized := int(val / maxVal * float64(height))
                        
                        if row &lt;= normalized </span><span class="cov0" title="0">{
                                if i%2 == 0 </span><span class="cov0" title="0">{
                                        output.WriteRune(upChar)
                                }</span> else<span class="cov0" title="0"> {
                                        output.WriteRune(downChar)
                                }</span>
                        } else<span class="cov0" title="0"> if row == 0 </span><span class="cov0" title="0">{
                                output.WriteRune('─')
                        }</span> else<span class="cov0" title="0"> {
                                output.WriteRune(' ')
                        }</span>
                }
                <span class="cov0" title="0">output.WriteString("\n")</span>
        }
}

// drawLossIndicators draws packet loss indicators
func (h *HeartbeatVisualization) drawLossIndicators(output *strings.Builder, data []float64) <span class="cov0" title="0">{
        for _, loss := range data </span><span class="cov0" title="0">{
                if loss &gt; 0 </span><span class="cov0" title="0">{
                        output.WriteString("▪ ")
                }</span> else<span class="cov0" title="0"> {
                        output.WriteString("  ")
                }</span>
        }
        <span class="cov0" title="0">output.WriteString("\n")
        output.WriteString(strings.Repeat("─", len(data)*2))</span>
}

// calculateHealth returns a health status string
func (h *HeartbeatVisualization) calculateHealth(latency, packets float64, lossHistory []float64) string <span class="cov0" title="0">{
        // Calculate loss percentage
        lossCount := 0.0
        for _, loss := range lossHistory </span><span class="cov0" title="0">{
                if loss &gt; 0 </span><span class="cov0" title="0">{
                        lossCount++
                }</span>
        }
        <span class="cov0" title="0">lossPercent := 0.0
        if len(lossHistory) &gt; 0 </span><span class="cov0" title="0">{
                lossPercent = lossCount / float64(len(lossHistory)) * 100
        }</span>
        
        // Determine health status
        <span class="cov0" title="0">if latency &lt; 50 &amp;&amp; lossPercent &lt; 1 </span><span class="cov0" title="0">{
                return "[green]████████ EXCELLENT[white]"
        }</span> else<span class="cov0" title="0"> if latency &lt; 100 &amp;&amp; lossPercent &lt; 5 </span><span class="cov0" title="0">{
                return "[green]██████░░ GOOD[white]"
        }</span> else<span class="cov0" title="0"> if latency &lt; 200 &amp;&amp; lossPercent &lt; 10 </span><span class="cov0" title="0">{
                return "[yellow]████░░░░ FAIR[white]"
        }</span> else<span class="cov0" title="0"> {
                return "[red]██░░░░░░ POOR[white]"
        }</span>
}

// GetMinSize returns minimum size requirements
func (h *HeartbeatVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 80, 25
}</pre>
		
		<pre class="file" id="file29" style="display: none">package ui

import (
        "fmt"
        "strings"
        "time"

        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
)

// HeatmapVisualization shows traffic patterns over time
type HeatmapVisualization struct {
        BaseVisualization
        trafficData [7][24]float64 // 7 days x 24 hours
        currentDay  int
        currentHour int
}

// NewHeatmapVisualization creates a new heatmap visualization
func NewHeatmapVisualization() Visualization <span class="cov0" title="0">{
        h := &amp;HeatmapVisualization{}
        h.textView = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        h.textView.SetBorder(true).
                SetTitle("Traffic Heatmap Calendar")
        
        // Initialize with some sample data
        now := time.Now()
        h.currentDay = int(now.Weekday())
        h.currentHour = now.Hour()
        
        return h
}</span>

// GetID returns the unique identifier
func (h *HeatmapVisualization) GetID() string <span class="cov0" title="0">{
        return "heatmap"
}</span>

// GetName returns the display name
func (h *HeatmapVisualization) GetName() string <span class="cov0" title="0">{
        return "Traffic Heatmap"
}</span>

// GetDescription returns a description
func (h *HeatmapVisualization) GetDescription() string <span class="cov0" title="0">{
        return "Shows traffic patterns over hours and days"
}</span>

// CreateView creates the view
func (h *HeatmapVisualization) CreateView() tview.Primitive <span class="cov0" title="0">{
        return h.textView
}</span>

// Update updates the visualization
func (h *HeatmapVisualization) Update(monitor *netcap.NetworkMonitor) <span class="cov0" title="0">{
        h.monitor = monitor
        
        // Get current traffic
        var connections []*netcap.Connection
        for interfaceName := range monitor.GetInterfaceStats() </span><span class="cov0" title="0">{
                interfaceConns := monitor.GetConnections(interfaceName)
                connections = append(connections, interfaceConns...)
        }</span>
        <span class="cov0" title="0">var currentTraffic float64
        
        for _, conn := range connections </span><span class="cov0" title="0">{
                if time.Since(conn.LastSeen) &lt; 5*time.Minute </span><span class="cov0" title="0">{
                        currentTraffic += float64(conn.Size)
                }</span>
        }
        
        // Update current hour's data
        <span class="cov0" title="0">now := time.Now()
        h.currentDay = int(now.Weekday())
        h.currentHour = now.Hour()
        
        // Rolling average to smooth the data
        oldValue := h.trafficData[h.currentDay][h.currentHour]
        h.trafficData[h.currentDay][h.currentHour] = (oldValue*0.7 + currentTraffic*0.3)
        
        // Find max traffic for normalization
        maxTraffic := 0.0
        for day := 0; day &lt; 7; day++ </span><span class="cov0" title="0">{
                for hour := 0; hour &lt; 24; hour++ </span><span class="cov0" title="0">{
                        if h.trafficData[day][hour] &gt; maxTraffic </span><span class="cov0" title="0">{
                                maxTraffic = h.trafficData[day][hour]
                        }</span>
                }
        }
        
        // Build the heatmap
        <span class="cov0" title="0">var output strings.Builder
        
        // Header
        output.WriteString("Hour  ")
        for hour := 0; hour &lt; 24; hour += 2 </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("%02d ", hour))
        }</span>
        <span class="cov0" title="0">output.WriteString("\n")
        
        // Days
        days := []string{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"}
        for day := 0; day &lt; 7; day++ </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("%-5s ", days[day]))
                
                for hour := 0; hour &lt; 24; hour++ </span><span class="cov0" title="0">{
                        intensity := 0.0
                        if maxTraffic &gt; 0 </span><span class="cov0" title="0">{
                                intensity = h.trafficData[day][hour] / maxTraffic
                        }</span>
                        
                        // Current cell indicator
                        <span class="cov0" title="0">if day == h.currentDay &amp;&amp; hour == h.currentHour </span><span class="cov0" title="0">{
                                output.WriteString("[yellow]")
                        }</span>
                        
                        // Heat character based on intensity
                        <span class="cov0" title="0">if intensity &gt; 0.75 </span><span class="cov0" title="0">{
                                output.WriteString("██")
                        }</span> else<span class="cov0" title="0"> if intensity &gt; 0.5 </span><span class="cov0" title="0">{
                                output.WriteString("▓▓")
                        }</span> else<span class="cov0" title="0"> if intensity &gt; 0.25 </span><span class="cov0" title="0">{
                                output.WriteString("▒▒")
                        }</span> else<span class="cov0" title="0"> if intensity &gt; 0 </span><span class="cov0" title="0">{
                                output.WriteString("░░")
                        }</span> else<span class="cov0" title="0"> {
                                output.WriteString("  ")
                        }</span>
                        
                        <span class="cov0" title="0">if day == h.currentDay &amp;&amp; hour == h.currentHour </span><span class="cov0" title="0">{
                                output.WriteString("[white]")
                        }</span>
                        
                        <span class="cov0" title="0">output.WriteString(" ")</span>
                }
                <span class="cov0" title="0">output.WriteString("\n")</span>
        }
        
        // Legend
        <span class="cov0" title="0">output.WriteString("\n[white]Legend: ")
        output.WriteString("░░ Light  ")
        output.WriteString("▒▒ Moderate  ")
        output.WriteString("▓▓ Heavy  ")
        output.WriteString("██ Peak  ")
        output.WriteString("[yellow]██[white] Current\n")
        
        // Traffic summary
        output.WriteString(fmt.Sprintf("\nCurrent Traffic: %.2f MB/s", currentTraffic/1024/1024))
        
        // Pattern analysis
        patterns := h.analyzePatterns()
        output.WriteString("\n\nTraffic Patterns:\n")
        for _, pattern := range patterns </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("• %s\n", pattern))
        }</span>
        
        <span class="cov0" title="0">h.textView.SetText(output.String())</span>
}

// analyzePatterns identifies traffic patterns
func (h *HeatmapVisualization) analyzePatterns() []string <span class="cov0" title="0">{
        patterns := []string{}
        
        // Find peak hours
        peakHour := 0
        peakTraffic := 0.0
        for hour := 0; hour &lt; 24; hour++ </span><span class="cov0" title="0">{
                hourTotal := 0.0
                for day := 0; day &lt; 7; day++ </span><span class="cov0" title="0">{
                        hourTotal += h.trafficData[day][hour]
                }</span>
                <span class="cov0" title="0">if hourTotal &gt; peakTraffic </span><span class="cov0" title="0">{
                        peakTraffic = hourTotal
                        peakHour = hour
                }</span>
        }
        
        <span class="cov0" title="0">if peakTraffic &gt; 0 </span><span class="cov0" title="0">{
                patterns = append(patterns, fmt.Sprintf("Peak traffic typically at %02d:00", peakHour))
        }</span>
        
        // Weekend vs weekday
        <span class="cov0" title="0">weekdayTotal := 0.0
        weekendTotal := 0.0
        for day := 1; day &lt;= 5; day++ </span><span class="cov0" title="0">{
                for hour := 0; hour &lt; 24; hour++ </span><span class="cov0" title="0">{
                        weekdayTotal += h.trafficData[day][hour]
                }</span>
        }
        <span class="cov0" title="0">for _, day := range []int{0, 6} </span><span class="cov0" title="0">{
                for hour := 0; hour &lt; 24; hour++ </span><span class="cov0" title="0">{
                        weekendTotal += h.trafficData[day][hour]
                }</span>
        }
        
        <span class="cov0" title="0">if weekdayTotal &gt; weekendTotal*2 </span><span class="cov0" title="0">{
                patterns = append(patterns, "Higher traffic on weekdays")
        }</span> else<span class="cov0" title="0"> if weekendTotal &gt; weekdayTotal*2 </span><span class="cov0" title="0">{
                patterns = append(patterns, "Higher traffic on weekends")
        }</span> else<span class="cov0" title="0"> {
                patterns = append(patterns, "Consistent traffic throughout the week")
        }</span>
        
        // Business hours analysis
        <span class="cov0" title="0">businessHoursTraffic := 0.0
        afterHoursTraffic := 0.0
        for day := 1; day &lt;= 5; day++ </span><span class="cov0" title="0">{ // Weekdays only
                for hour := 9; hour &lt; 17; hour++ </span><span class="cov0" title="0">{
                        businessHoursTraffic += h.trafficData[day][hour]
                }</span>
                <span class="cov0" title="0">for hour := 0; hour &lt; 9; hour++ </span><span class="cov0" title="0">{
                        afterHoursTraffic += h.trafficData[day][hour]
                }</span>
                <span class="cov0" title="0">for hour := 17; hour &lt; 24; hour++ </span><span class="cov0" title="0">{
                        afterHoursTraffic += h.trafficData[day][hour]
                }</span>
        }
        
        <span class="cov0" title="0">if businessHoursTraffic &gt; afterHoursTraffic*1.5 </span><span class="cov0" title="0">{
                patterns = append(patterns, "Business hours show increased activity")
        }</span>
        
        <span class="cov0" title="0">return patterns</span>
}

// GetMinSize returns minimum size requirements
func (h *HeatmapVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 80, 20
}</pre>
		
		<pre class="file" id="file30" style="display: none">package ui

import (
        "fmt"
        "math/rand"
        "strings"
        "time"

        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
)

// MatrixRainVisualization shows packets falling Matrix-style
type MatrixRainVisualization struct {
        BaseVisualization
        columns      []matrixColumn
        width        int
        height       int
        lastUpdate   time.Time
        packetBuffer []matrixPacket
}

type matrixColumn struct {
        chars    []rune
        position int
        speed    int
        length   int
}

type matrixPacket struct {
        protocol string
        size     int
        time     time.Time
}

// NewMatrixRainVisualization creates a new Matrix rain visualization
func NewMatrixRainVisualization() Visualization <span class="cov0" title="0">{
        m := &amp;MatrixRainVisualization{
                width:        80,
                height:       25,
                packetBuffer: make([]matrixPacket, 0, 100),
        }
        m.textView = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        m.textView.SetBorder(true).
                SetTitle("Matrix Rain Packet Visualizer")
        
        // Initialize columns
        m.initializeColumns()
        
        return m
}</span>

// GetID returns the unique identifier
func (m *MatrixRainVisualization) GetID() string <span class="cov0" title="0">{
        return "matrix"
}</span>

// GetName returns the display name
func (m *MatrixRainVisualization) GetName() string <span class="cov0" title="0">{
        return "Matrix Rain"
}</span>

// GetDescription returns a description
func (m *MatrixRainVisualization) GetDescription() string <span class="cov0" title="0">{
        return "Live packets falling Matrix-style"
}</span>

// CreateView creates the view
func (m *MatrixRainVisualization) CreateView() tview.Primitive <span class="cov0" title="0">{
        return m.textView
}</span>

// initializeColumns sets up the matrix columns
func (m *MatrixRainVisualization) initializeColumns() <span class="cov0" title="0">{
        m.columns = make([]matrixColumn, m.width/2) // Characters are 2 spaces wide
        
        for i := range m.columns </span><span class="cov0" title="0">{
                m.columns[i] = matrixColumn{
                        chars:    make([]rune, m.height),
                        position: rand.Intn(m.height),
                        speed:    rand.Intn(3) + 1,
                        length:   rand.Intn(10) + 5,
                }
                
                // Fill with spaces initially
                for j := range m.columns[i].chars </span><span class="cov0" title="0">{
                        m.columns[i].chars[j] = ' '
                }</span>
        }
}

// Update updates the visualization
func (m *MatrixRainVisualization) Update(monitor *netcap.NetworkMonitor) <span class="cov0" title="0">{
        m.monitor = monitor
        
        // Get recent packets
        packets := monitor.GetPacketBuffer()
        
        // Add new packets to buffer
        for _, pkt := range packets </span><span class="cov0" title="0">{
                if time.Since(pkt.Timestamp) &lt; 2*time.Second </span><span class="cov0" title="0">{
                        m.packetBuffer = append(m.packetBuffer, matrixPacket{
                                protocol: pkt.Protocol,
                                size:     int(pkt.Length),
                                time:     pkt.Timestamp,
                        })
                }</span>
        }
        
        // Trim old packets
        <span class="cov0" title="0">if len(m.packetBuffer) &gt; 100 </span><span class="cov0" title="0">{
                m.packetBuffer = m.packetBuffer[len(m.packetBuffer)-100:]
        }</span>
        
        // Update matrix animation
        <span class="cov0" title="0">m.updateMatrix()
        
        // Render the matrix
        var output strings.Builder
        
        // Set black background style
        output.WriteString("[green]")
        
        // Draw the matrix
        for row := 0; row &lt; m.height; row++ </span><span class="cov0" title="0">{
                for col := 0; col &lt; len(m.columns); col++ </span><span class="cov0" title="0">{
                        char := m.columns[col].chars[row]
                        
                        // Color based on position in trail
                        pos := m.columns[col].position
                        if row == pos </span><span class="cov0" title="0">{
                                // Head of the trail - bright
                                output.WriteString(fmt.Sprintf("[white]%c ", char))
                        }</span> else<span class="cov0" title="0"> if row &gt; pos-m.columns[col].length &amp;&amp; row &lt; pos </span><span class="cov0" title="0">{
                                // Trail - varying green intensity
                                intensity := float64(row-pos+m.columns[col].length) / float64(m.columns[col].length)
                                if intensity &gt; 0.7 </span><span class="cov0" title="0">{
                                        output.WriteString(fmt.Sprintf("[green]%c ", char))
                                }</span> else<span class="cov0" title="0"> if intensity &gt; 0.3 </span><span class="cov0" title="0">{
                                        output.WriteString(fmt.Sprintf("[darkgreen]%c ", char))
                                }</span> else<span class="cov0" title="0"> {
                                        output.WriteString(fmt.Sprintf("[darkgreen]%c ", char))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                output.WriteString("  ")
                        }</span>
                }
                <span class="cov0" title="0">output.WriteString("\n")</span>
        }
        
        // Reset color
        <span class="cov0" title="0">output.WriteString("[white]")
        
        // Protocol legend at bottom
        output.WriteString("\n[white]Recent Protocols: ")
        protocolCounts := make(map[string]int)
        for _, pkt := range m.packetBuffer </span><span class="cov0" title="0">{
                protocolCounts[pkt.protocol]++
        }</span>
        
        <span class="cov0" title="0">for proto, count := range protocolCounts </span><span class="cov0" title="0">{
                color := m.getProtocolColor(proto)
                output.WriteString(fmt.Sprintf("%s%s:%d ", color, proto, count))
        }</span>
        
        <span class="cov0" title="0">m.textView.SetText(output.String())</span>
}

// updateMatrix updates the falling characters
func (m *MatrixRainVisualization) updateMatrix() <span class="cov0" title="0">{
        // Protocol characters
        protoChars := map[string][]rune{
                "TCP":  []rune("TCP4680"),
                "UDP":  []rune("UDP8053"),
                "ICMP": []rune("ICMP64"),
                "HTTP": []rune("HTTP80"),
                "DNS":  []rune("DNS53Q"),
                "SSH":  []rune("SSH22"),
        }
        
        // Update each column
        for i := range m.columns </span><span class="cov0" title="0">{
                // Move the trail down
                if time.Since(m.lastUpdate).Milliseconds() &gt; int64(100/m.columns[i].speed) </span><span class="cov0" title="0">{
                        m.columns[i].position++
                        
                        // Reset if at bottom
                        if m.columns[i].position-m.columns[i].length &gt; m.height </span><span class="cov0" title="0">{
                                m.columns[i].position = 0
                                m.columns[i].speed = rand.Intn(3) + 1
                                m.columns[i].length = rand.Intn(10) + 5
                        }</span>
                        
                        // Add new character at head position
                        <span class="cov0" title="0">if m.columns[i].position &lt; m.height &amp;&amp; m.columns[i].position &gt;= 0 </span><span class="cov0" title="0">{
                                // Choose character based on recent packets
                                if len(m.packetBuffer) &gt; 0 &amp;&amp; rand.Float32() &lt; 0.7 </span><span class="cov0" title="0">{
                                        // Use protocol character
                                        pkt := m.packetBuffer[rand.Intn(len(m.packetBuffer))]
                                        if chars, ok := protoChars[pkt.protocol]; ok </span><span class="cov0" title="0">{
                                                m.columns[i].chars[m.columns[i].position] = chars[rand.Intn(len(chars))]
                                        }</span> else<span class="cov0" title="0"> {
                                                m.columns[i].chars[m.columns[i].position] = rune('0' + rand.Intn(10))
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // Random character
                                        if rand.Float32() &lt; 0.5 </span><span class="cov0" title="0">{
                                                m.columns[i].chars[m.columns[i].position] = rune('0' + rand.Intn(10))
                                        }</span> else<span class="cov0" title="0"> {
                                                m.columns[i].chars[m.columns[i].position] = rune('A' + rand.Intn(26))
                                        }</span>
                                }
                        }
                }
        }
        
        <span class="cov0" title="0">m.lastUpdate = time.Now()</span>
}

// getProtocolColor returns color for a protocol
func (m *MatrixRainVisualization) getProtocolColor(protocol string) string <span class="cov0" title="0">{
        switch protocol </span>{
        case "TCP":<span class="cov0" title="0">
                return "[green]"</span>
        case "UDP":<span class="cov0" title="0">
                return "[blue]"</span>
        case "ICMP":<span class="cov0" title="0">
                return "[yellow]"</span>
        case "HTTP", "HTTPS":<span class="cov0" title="0">
                return "[cyan]"</span>
        case "DNS":<span class="cov0" title="0">
                return "[magenta]"</span>
        default:<span class="cov0" title="0">
                return "[white]"</span>
        }
}

// GetMinSize returns minimum size requirements
func (m *MatrixRainVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 80, 30
}</pre>
		
		<pre class="file" id="file31" style="display: none">package ui

import (
        "fmt"
        "strings"

        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
)

// PacketDistributionVisualization shows packet size distribution
type PacketDistributionVisualization struct {
        BaseVisualization
        distribution map[int]int // size bucket -&gt; count
}

// NewPacketDistributionVisualization creates a new packet distribution visualization
func NewPacketDistributionVisualization() Visualization <span class="cov0" title="0">{
        p := &amp;PacketDistributionVisualization{
                distribution: make(map[int]int),
        }
        p.textView = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        p.textView.SetBorder(true).
                SetTitle("Packet Size Distribution")
        return p
}</span>

// GetID returns the unique identifier
func (p *PacketDistributionVisualization) GetID() string <span class="cov0" title="0">{
        return "packet_dist"
}</span>

// GetName returns the display name
func (p *PacketDistributionVisualization) GetName() string <span class="cov0" title="0">{
        return "Packet Size Distribution"
}</span>

// GetDescription returns a description
func (p *PacketDistributionVisualization) GetDescription() string <span class="cov0" title="0">{
        return "Enhanced histogram of packet sizes"
}</span>

// CreateView creates the view
func (p *PacketDistributionVisualization) CreateView() tview.Primitive <span class="cov0" title="0">{
        return p.textView
}</span>

// Update updates the visualization
func (p *PacketDistributionVisualization) Update(monitor *netcap.NetworkMonitor) <span class="cov0" title="0">{
        p.monitor = monitor
        
        // Reset distribution
        p.distribution = make(map[int]int)
        
        // Get packet buffer
        packets := monitor.GetPacketBuffer()
        
        // Categorize packets by size
        for _, pkt := range packets </span><span class="cov0" title="0">{
                bucket := p.getBucket(int(pkt.Length))
                p.distribution[bucket]++
        }</span>
        
        // Build visualization
        <span class="cov0" title="0">var output strings.Builder
        
        // Header
        output.WriteString("[white]Size Distribution (bytes)\n\n")
        
        // Define buckets in order
        buckets := []struct {
                size  int
                label string
        }{
                {64, "   64"},
                {128, "  128"},
                {256, "  256"},
                {512, "  512"},
                {1024, " 1024"},
                {1500, " 1500"},
                {2048, " 2048"},
                {4096, " 4096"},
                {9000, " 9000"}, // Jumbo frames
                {16384, "16384"},
        }
        
        // Find max count for scaling
        maxCount := 0
        totalPackets := 0
        for _, count := range p.distribution </span><span class="cov0" title="0">{
                if count &gt; maxCount </span><span class="cov0" title="0">{
                        maxCount = count
                }</span>
                <span class="cov0" title="0">totalPackets += count</span>
        }
        
        <span class="cov0" title="0">if maxCount == 0 </span><span class="cov0" title="0">{
                maxCount = 1
        }</span>
        
        // Draw histogram
        <span class="cov0" title="0">barWidth := 50
        for _, bucket := range buckets </span><span class="cov0" title="0">{
                count := p.distribution[bucket.size]
                percentage := 0.0
                if totalPackets &gt; 0 </span><span class="cov0" title="0">{
                        percentage = float64(count) / float64(totalPackets) * 100
                }</span>
                
                // Calculate bar length
                <span class="cov0" title="0">barLen := int(float64(count) / float64(maxCount) * float64(barWidth))
                
                // Choose bar style based on percentage
                var bar string
                color := p.getSizeColor(bucket.size)
                
                if barLen &gt; 0 </span><span class="cov0" title="0">{
                        // Use different block characters for visual variety
                        if percentage &gt; 30 </span><span class="cov0" title="0">{
                                bar = strings.Repeat("█", barLen)
                        }</span> else<span class="cov0" title="0"> if percentage &gt; 20 </span><span class="cov0" title="0">{
                                bar = strings.Repeat("▓", barLen)
                        }</span> else<span class="cov0" title="0"> if percentage &gt; 10 </span><span class="cov0" title="0">{
                                bar = strings.Repeat("▒", barLen)
                        }</span> else<span class="cov0" title="0"> {
                                bar = strings.Repeat("░", barLen)
                        }</span>
                }
                
                // Format line
                <span class="cov0" title="0">output.WriteString(fmt.Sprintf("%s │%s%s[white]%s %5.1f%% (%d)\n",
                        bucket.label,
                        color,
                        bar,
                        strings.Repeat(" ", barWidth-len(bar)),
                        percentage,
                        count))</span>
        }
        
        // Statistics
        <span class="cov0" title="0">output.WriteString("\n[white]Packet Statistics:\n")
        output.WriteString(fmt.Sprintf("Total Packets: %d\n", totalPackets))
        
        // Size analysis
        // Convert packets to slice of pointers
        var packetPtrs []*netcap.PacketInfo
        for i := range packets </span><span class="cov0" title="0">{
                packetPtrs = append(packetPtrs, &amp;packets[i])
        }</span>
        <span class="cov0" title="0">avgSize := p.calculateAverageSize(packetPtrs)
        output.WriteString(fmt.Sprintf("Average Size: %d bytes\n", avgSize))
        
        // MTU analysis
        mtuCount := p.distribution[1500]
        if totalPackets &gt; 0 </span><span class="cov0" title="0">{
                mtuPercentage := float64(mtuCount) / float64(totalPackets) * 100
                output.WriteString(fmt.Sprintf("MTU-sized packets (1500): %.1f%%\n", mtuPercentage))
        }</span>
        
        // Small vs large packets
        <span class="cov0" title="0">smallPackets := 0
        largePackets := 0
        for size, count := range p.distribution </span><span class="cov0" title="0">{
                if size &lt;= 128 </span><span class="cov0" title="0">{
                        smallPackets += count
                }</span> else<span class="cov0" title="0"> if size &gt;= 1024 </span><span class="cov0" title="0">{
                        largePackets += count
                }</span>
        }
        
        <span class="cov0" title="0">if totalPackets &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("\nSmall packets (≤128): %.1f%%\n", 
                        float64(smallPackets)/float64(totalPackets)*100))
                output.WriteString(fmt.Sprintf("Large packets (≥1024): %.1f%%\n", 
                        float64(largePackets)/float64(totalPackets)*100))
        }</span>
        
        // Protocol breakdown by size
        <span class="cov0" title="0">output.WriteString("\n[white]Size by Protocol:\n")
        protocolSizes := p.getProtocolSizes(packetPtrs)
        for proto, sizes := range protocolSizes </span><span class="cov0" title="0">{
                avgProtoSize := 0
                if sizes.count &gt; 0 </span><span class="cov0" title="0">{
                        avgProtoSize = sizes.total / sizes.count
                }</span>
                
                <span class="cov0" title="0">color := p.getProtocolColor(proto)
                output.WriteString(fmt.Sprintf("%s%-6s[white]: avg %4d bytes (%d packets)\n",
                        color, proto, avgProtoSize, sizes.count))</span>
        }
        
        <span class="cov0" title="0">p.textView.SetText(output.String())</span>
}

// getBucket returns the bucket for a packet size
func (p *PacketDistributionVisualization) getBucket(size int) int <span class="cov0" title="0">{
        buckets := []int{64, 128, 256, 512, 1024, 1500, 2048, 4096, 9000, 16384}
        
        for _, bucket := range buckets </span><span class="cov0" title="0">{
                if size &lt;= bucket </span><span class="cov0" title="0">{
                        return bucket
                }</span>
        }
        
        <span class="cov0" title="0">return 16384</span> // Max bucket
}

// calculateAverageSize calculates average packet size
func (p *PacketDistributionVisualization) calculateAverageSize(packets []*netcap.PacketInfo) int <span class="cov0" title="0">{
        if len(packets) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        <span class="cov0" title="0">total := 0
        for _, pkt := range packets </span><span class="cov0" title="0">{
                total += int(pkt.Length)
        }</span>
        
        <span class="cov0" title="0">return total / len(packets)</span>
}

type protocolSize struct {
        total int
        count int
}

// getProtocolSizes gets size statistics by protocol
func (p *PacketDistributionVisualization) getProtocolSizes(packets []*netcap.PacketInfo) map[string]*protocolSize <span class="cov0" title="0">{
        sizes := make(map[string]*protocolSize)
        
        for _, pkt := range packets </span><span class="cov0" title="0">{
                if sizes[pkt.Protocol] == nil </span><span class="cov0" title="0">{
                        sizes[pkt.Protocol] = &amp;protocolSize{}
                }</span>
                <span class="cov0" title="0">sizes[pkt.Protocol].total += int(pkt.Length)
                sizes[pkt.Protocol].count++</span>
        }
        
        <span class="cov0" title="0">return sizes</span>
}

// getSizeColor returns color based on packet size
func (p *PacketDistributionVisualization) getSizeColor(size int) string <span class="cov0" title="0">{
        switch </span>{
        case size &lt;= 128:<span class="cov0" title="0">
                return "[blue]"</span>
        case size &lt;= 512:<span class="cov0" title="0">
                return "[cyan]"</span>
        case size &lt;= 1500:<span class="cov0" title="0">
                return "[green]"</span>
        case size &lt;= 4096:<span class="cov0" title="0">
                return "[yellow]"</span>
        default:<span class="cov0" title="0">
                return "[red]"</span>
        }
}

// getProtocolColor returns color for protocol
func (p *PacketDistributionVisualization) getProtocolColor(protocol string) string <span class="cov0" title="0">{
        switch protocol </span>{
        case "TCP":<span class="cov0" title="0">
                return "[green]"</span>
        case "UDP":<span class="cov0" title="0">
                return "[blue]"</span>
        case "ICMP":<span class="cov0" title="0">
                return "[yellow]"</span>
        default:<span class="cov0" title="0">
                return "[white]"</span>
        }
}

// GetMinSize returns minimum size requirements
func (p *PacketDistributionVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 70, 35
}</pre>
		
		<pre class="file" id="file32" style="display: none">package ui

import (
        "fmt"
        "math"
        "sort"
        "strings"

        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
)

// RadialConnectionVisualization shows connections in a radial layout
type RadialConnectionVisualization struct {
        BaseVisualization
}

// NewRadialConnectionVisualization creates a new radial visualization
func NewRadialConnectionVisualization() Visualization <span class="cov0" title="0">{
        r := &amp;RadialConnectionVisualization{}
        r.textView = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        r.textView.SetBorder(true).
                SetTitle("Radial Connection Graph")
        return r
}</span>

// GetID returns the unique identifier
func (r *RadialConnectionVisualization) GetID() string <span class="cov0" title="0">{
        return "radial"
}</span>

// GetName returns the display name
func (r *RadialConnectionVisualization) GetName() string <span class="cov0" title="0">{
        return "Radial Connection Graph"
}</span>

// GetDescription returns a description
func (r *RadialConnectionVisualization) GetDescription() string <span class="cov0" title="0">{
        return "Shows connections radiating from your host"
}</span>

// CreateView creates the view
func (r *RadialConnectionVisualization) CreateView() tview.Primitive <span class="cov0" title="0">{
        return r.textView
}</span>

// Update updates the visualization
func (r *RadialConnectionVisualization) Update(monitor *netcap.NetworkMonitor) <span class="cov0" title="0">{
        r.monitor = monitor
        
        // Get connections grouped by service
        var connections []*netcap.Connection
        for interfaceName := range monitor.Interfaces </span><span class="cov0" title="0">{
                connections = append(connections, monitor.GetConnections(interfaceName)...)
        }</span>
        <span class="cov0" title="0">serviceMap := make(map[string][]*netcap.Connection)
        
        for _, conn := range connections </span><span class="cov0" title="0">{
                service := getServiceName(conn)
                serviceMap[service] = append(serviceMap[service], conn)
        }</span>
        
        // Sort services by connection count
        <span class="cov0" title="0">type serviceInfo struct {
                name  string
                count int
                bytes uint64
        }
        
        var services []serviceInfo
        for name, conns := range serviceMap </span><span class="cov0" title="0">{
                var totalBytes uint64
                for _, conn := range conns </span><span class="cov0" title="0">{
                        totalBytes += conn.Size
                }</span>
                <span class="cov0" title="0">services = append(services, serviceInfo{name, len(conns), totalBytes})</span>
        }
        
        <span class="cov0" title="0">sort.Slice(services, func(i, j int) bool </span><span class="cov0" title="0">{
                return services[i].count &gt; services[j].count
        }</span>)
        
        // Limit to top 8 services for radial display
        <span class="cov0" title="0">if len(services) &gt; 8 </span><span class="cov0" title="0">{
                services = services[:8]
        }</span>
        
        // Create the radial visualization
        <span class="cov0" title="0">width, height := 50, 25
        grid := make([][]rune, height)
        for i := range grid </span><span class="cov0" title="0">{
                grid[i] = make([]rune, width)
                for j := range grid[i] </span><span class="cov0" title="0">{
                        grid[i][j] = ' '
                }</span>
        }
        
        // Center point
        <span class="cov0" title="0">centerX, centerY := width/2, height/2
        
        // Draw center (YOU)
        you := "┌─┴─┐\n│YOU│\n└─┬─┘"
        youLines := strings.Split(you, "\n")
        for i, line := range youLines </span><span class="cov0" title="0">{
                runes := []rune(line)
                for j, r := range runes </span><span class="cov0" title="0">{
                        y := centerY - 1 + i
                        x := centerX - 2 + j
                        if y &gt;= 0 &amp;&amp; y &lt; height &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; width </span><span class="cov0" title="0">{
                                grid[y][x] = r
                        }</span>
                }
        }
        
        // Draw connections radiating outward
        <span class="cov0" title="0">angleStep := 2 * math.Pi / float64(len(services))
        radius := float64(min(width, height)) / 3
        
        for i, service := range services </span><span class="cov0" title="0">{
                angle := float64(i) * angleStep
                
                // Calculate endpoint
                endX := centerX + int(radius*math.Cos(angle))
                endY := centerY + int(radius*math.Sin(angle)/2) // Compensate for aspect ratio
                
                // Draw line from center to service
                drawLine(grid, centerX, centerY, endX, endY)
                
                // Draw service box
                label := fmt.Sprintf("┌─────────┐\n│%-9s│\n└─────────┘", 
                        truncate(service.name, 9))
                
                labelLines := strings.Split(label, "\n")
                startY := endY - 1
                startX := endX - 5
                
                for j, line := range labelLines </span><span class="cov0" title="0">{
                        runes := []rune(line)
                        for k, r := range runes </span><span class="cov0" title="0">{
                                y := startY + j
                                x := startX + k
                                if y &gt;= 0 &amp;&amp; y &lt; height &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; width </span><span class="cov0" title="0">{
                                        grid[y][x] = r
                                }</span>
                        }
                }
                
                // Add connection count
                <span class="cov0" title="0">countLabel := fmt.Sprintf("%d", service.count)
                countY := startY + 3
                countX := endX - len(countLabel)/2
                for j, r := range countLabel </span><span class="cov0" title="0">{
                        x := countX + j
                        if countY &gt;= 0 &amp;&amp; countY &lt; height &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; width </span><span class="cov0" title="0">{
                                grid[countY][x] = rune(r)
                        }</span>
                }
        }
        
        // Convert grid to string
        <span class="cov0" title="0">var output strings.Builder
        for _, row := range grid </span><span class="cov0" title="0">{
                output.WriteString(string(row) + "\n")
        }</span>
        
        // Add legend
        <span class="cov0" title="0">output.WriteString("\n[green]Services by Connection Count:[white]\n")
        for _, service := range services </span><span class="cov0" title="0">{
                bar := strings.Repeat("█", service.count/2+1)
                output.WriteString(fmt.Sprintf("%-12s %s%s[white] (%d)\n",
                        service.name,
                        r.getServiceColor(service.name),
                        bar,
                        service.count))
        }</span>
        
        <span class="cov0" title="0">r.textView.SetText(output.String())</span>
}

// drawLine draws a line between two points using ASCII characters
func drawLine(grid [][]rune, x1, y1, x2, y2 int) <span class="cov0" title="0">{
        dx := abs(x2 - x1)
        dy := abs(y2 - y1)
        
        var sx, sy int
        if x1 &lt; x2 </span><span class="cov0" title="0">{
                sx = 1
        }</span> else<span class="cov0" title="0"> {
                sx = -1
        }</span>
        <span class="cov0" title="0">if y1 &lt; y2 </span><span class="cov0" title="0">{
                sy = 1
        }</span> else<span class="cov0" title="0"> {
                sy = -1
        }</span>
        
        <span class="cov0" title="0">err := dx - dy
        x, y := x1, y1
        
        for </span><span class="cov0" title="0">{
                if x &gt;= 0 &amp;&amp; x &lt; len(grid[0]) &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; len(grid) </span><span class="cov0" title="0">{
                        // Choose character based on direction
                        if dx &gt; dy </span><span class="cov0" title="0">{
                                grid[y][x] = '─'
                        }</span> else<span class="cov0" title="0"> {
                                grid[y][x] = '│'
                        }</span>
                }
                
                <span class="cov0" title="0">if x == x2 &amp;&amp; y == y2 </span><span class="cov0" title="0">{
                        break</span>
                }
                
                <span class="cov0" title="0">e2 := 2 * err
                if e2 &gt; -dy </span><span class="cov0" title="0">{
                        err -= dy
                        x += sx
                }</span>
                <span class="cov0" title="0">if e2 &lt; dx </span><span class="cov0" title="0">{
                        err += dx
                        y += sy
                }</span>
        }
}

// Helper functions
func abs(x int) int <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                return -x
        }</span>
        <span class="cov0" title="0">return x</span>
}

func radialMin(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func truncate(s string, n int) string <span class="cov0" title="0">{
        if len(s) &lt;= n </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:n-1] + "…"</span>
}

// getServiceColor returns a color for a service
func (r *RadialConnectionVisualization) getServiceColor(service string) string <span class="cov0" title="0">{
        switch service </span>{
        case "HTTPS", "HTTP":<span class="cov0" title="0">
                return "[green]"</span>
        case "SSH":<span class="cov0" title="0">
                return "[yellow]"</span>
        case "DNS":<span class="cov0" title="0">
                return "[blue]"</span>
        case "Email":<span class="cov0" title="0">
                return "[magenta]"</span>
        case "Database":<span class="cov0" title="0">
                return "[red]"</span>
        default:<span class="cov0" title="0">
                return "[white]"</span>
        }
}

// GetMinSize returns minimum size requirements
func (r *RadialConnectionVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 50, 30
}</pre>
		
		<pre class="file" id="file33" style="display: none">package ui

import (
        "fmt"
        "sort"
        "strings"

        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
        "github.com/user/netmon/pkg/utils"
)

// SankeyVisualization shows network flow as a Sankey diagram
type SankeyVisualization struct {
        BaseVisualization
        flows map[string]uint64 // key: "src-&gt;dst", value: bytes
}

// NewSankeyVisualization creates a new Sankey visualization
func NewSankeyVisualization() Visualization <span class="cov0" title="0">{
        s := &amp;SankeyVisualization{
                flows: make(map[string]uint64),
        }
        s.textView = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        s.textView.SetBorder(true).
                SetTitle("Network Flow Sankey")
        return s
}</span>

// GetID returns the unique identifier
func (s *SankeyVisualization) GetID() string <span class="cov0" title="0">{
        return "sankey"
}</span>

// GetName returns the display name
func (s *SankeyVisualization) GetName() string <span class="cov0" title="0">{
        return "Network Flow Sankey"
}</span>

// GetDescription returns a description
func (s *SankeyVisualization) GetDescription() string <span class="cov0" title="0">{
        return "Visualizes traffic flow between sources and destinations"
}</span>

// CreateView creates the view
func (s *SankeyVisualization) CreateView() tview.Primitive <span class="cov0" title="0">{
        return s.textView
}</span>

// Update updates the visualization
func (s *SankeyVisualization) Update(monitor *netcap.NetworkMonitor) <span class="cov0" title="0">{
        s.monitor = monitor
        
        // Clear flows
        s.flows = make(map[string]uint64)
        
        // Get connections and aggregate flows
        var connections []*netcap.Connection
        for interfaceName := range monitor.Interfaces </span><span class="cov0" title="0">{
                connections = append(connections, monitor.GetConnections(interfaceName)...)
        }</span>
        <span class="cov0" title="0">srcMap := make(map[string]map[string]uint64) // src -&gt; dst -&gt; bytes
        
        for _, conn := range connections </span><span class="cov0" title="0">{
                src := conn.SrcIP.String()
                dst := fmt.Sprintf("%s (%d)", getServiceName(conn), conn.DstPort)
                
                if srcMap[src] == nil </span><span class="cov0" title="0">{
                        srcMap[src] = make(map[string]uint64)
                }</span>
                <span class="cov0" title="0">srcMap[src][dst] += conn.Size</span>
        }
        
        // Sort sources by total traffic
        <span class="cov0" title="0">type srcFlow struct {
                src   string
                total uint64
                dests map[string]uint64
        }
        
        var sources []srcFlow
        for src, dests := range srcMap </span><span class="cov0" title="0">{
                var total uint64
                for _, bytes := range dests </span><span class="cov0" title="0">{
                        total += bytes
                }</span>
                <span class="cov0" title="0">sources = append(sources, srcFlow{src, total, dests})</span>
        }
        
        <span class="cov0" title="0">sort.Slice(sources, func(i, j int) bool </span><span class="cov0" title="0">{
                return sources[i].total &gt; sources[j].total
        }</span>)
        
        // Limit to top 10 sources
        <span class="cov0" title="0">if len(sources) &gt; 10 </span><span class="cov0" title="0">{
                sources = sources[:10]
        }</span>
        
        // Build the diagram
        <span class="cov0" title="0">var output strings.Builder
        
        // Find max destination name length for alignment
        maxDestLen := 0
        for _, src := range sources </span><span class="cov0" title="0">{
                for dst := range src.dests </span><span class="cov0" title="0">{
                        if len(dst) &gt; maxDestLen </span><span class="cov0" title="0">{
                                maxDestLen = len(dst)
                        }</span>
                }
        }
        
        // Draw the flows
        <span class="cov0" title="0">for i, src := range sources </span><span class="cov0" title="0">{
                // Source IP
                srcDisplay := src.src
                if len(srcDisplay) &gt; 15 </span><span class="cov0" title="0">{
                        srcDisplay = srcDisplay[:15]
                }</span>
                
                // Sort destinations by traffic
                <span class="cov0" title="0">type destFlow struct {
                        dst   string
                        bytes uint64
                }
                var dests []destFlow
                for dst, bytes := range src.dests </span><span class="cov0" title="0">{
                        dests = append(dests, destFlow{dst, bytes})
                }</span>
                <span class="cov0" title="0">sort.Slice(dests, func(i, j int) bool </span><span class="cov0" title="0">{
                        return dests[i].bytes &gt; dests[j].bytes
                }</span>)
                
                // Limit destinations per source
                <span class="cov0" title="0">if len(dests) &gt; 3 </span><span class="cov0" title="0">{
                        dests = dests[:3]
                }</span>
                
                // Draw connections
                <span class="cov0" title="0">for j, dest := range dests </span><span class="cov0" title="0">{
                        // Calculate bar width based on traffic
                        barWidth := int(float64(dest.bytes) / float64(src.total) * 20)
                        if barWidth &lt; 1 </span><span class="cov0" title="0">{
                                barWidth = 1
                        }</span>
                        
                        <span class="cov0" title="0">bar := strings.Repeat("█", barWidth)
                        
                        // Format the line
                        var line string
                        if j == 0 </span><span class="cov0" title="0">{
                                // First destination - show source
                                line = fmt.Sprintf("%-15s ═══╗", srcDisplay)
                        }</span> else<span class="cov0" title="0"> if j == len(dests)-1 &amp;&amp; i &lt; len(sources)-1 </span><span class="cov0" title="0">{
                                // Last destination - prepare for next source
                                line = fmt.Sprintf("                ═╦═╝")
                        }</span> else<span class="cov0" title="0"> {
                                // Middle destinations
                                line = fmt.Sprintf("                ═╬══")
                        }</span>
                        
                        // Add destination and traffic bar
                        <span class="cov0" title="0">color := s.getFlowColor(dest.bytes, src.total)
                        line += fmt.Sprintf(" ╠═══&gt; %-*s %s%s[white] %s",
                                maxDestLen,
                                dest.dst,
                                color,
                                bar,
                                utils.FormatBytes(dest.bytes))
                        
                        output.WriteString(line + "\n")</span>
                }
                
                <span class="cov0" title="0">if i &lt; len(sources)-1 </span><span class="cov0" title="0">{
                        output.WriteString("\n")
                }</span>
        }
        
        <span class="cov0" title="0">s.textView.SetText(output.String())</span>
}

// getFlowColor returns a color based on traffic percentage
func (s *SankeyVisualization) getFlowColor(bytes, total uint64) string <span class="cov0" title="0">{
        percent := float64(bytes) / float64(total)
        switch </span>{
        case percent &gt; 0.5:<span class="cov0" title="0">
                return "[red]"</span>
        case percent &gt; 0.3:<span class="cov0" title="0">
                return "[yellow]"</span>
        case percent &gt; 0.1:<span class="cov0" title="0">
                return "[green]"</span>
        default:<span class="cov0" title="0">
                return "[blue]"</span>
        }
}

// getServiceName returns a friendly service name
func getServiceName(conn *netcap.Connection) string <span class="cov0" title="0">{
        if conn.Service != "" &amp;&amp; conn.Service != "Unknown" </span><span class="cov0" title="0">{
                return conn.Service
        }</span>
        
        // Try to determine from port
        <span class="cov0" title="0">switch conn.DstPort </span>{
        case 80:<span class="cov0" title="0">
                return "HTTP"</span>
        case 443:<span class="cov0" title="0">
                return "HTTPS"</span>
        case 22:<span class="cov0" title="0">
                return "SSH"</span>
        case 53:<span class="cov0" title="0">
                return "DNS"</span>
        case 25, 587:<span class="cov0" title="0">
                return "Email"</span>
        case 3306:<span class="cov0" title="0">
                return "MySQL"</span>
        case 5432:<span class="cov0" title="0">
                return "PostgreSQL"</span>
        case 6379:<span class="cov0" title="0">
                return "Redis"</span>
        case 27017:<span class="cov0" title="0">
                return "MongoDB"</span>
        default:<span class="cov0" title="0">
                if conn.DstIP.IsPrivate() </span><span class="cov0" title="0">{
                        return "Local"
                }</span>
                <span class="cov0" title="0">return "External"</span>
        }
}

// GetMinSize returns minimum size requirements
func (s *SankeyVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 60, 20
}</pre>
		
		<pre class="file" id="file34" style="display: none">package ui

import (
        "fmt"
        "math"
        "strings"

        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
        "github.com/user/netmon/pkg/utils"
)

// SpeedometerVisualization shows bandwidth as a speedometer gauge
type SpeedometerVisualization struct {
        BaseVisualization
        maxBandwidth   float64 // Maximum bandwidth in bytes/sec
        currentSpeed   float64
        inSpeed        float64
        outSpeed       float64
        history        []float64
        maxHistory     int
}

// NewSpeedometerVisualization creates a new speedometer visualization
func NewSpeedometerVisualization() Visualization <span class="cov0" title="0">{
        s := &amp;SpeedometerVisualization{
                maxBandwidth: 100 * 1024 * 1024, // 100 Mbps default
                maxHistory:   20,
                history:      make([]float64, 0, 20),
        }
        s.textView = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        s.textView.SetBorder(true).
                SetTitle("Bandwidth Speedometer")
        return s
}</span>

// GetID returns the unique identifier
func (s *SpeedometerVisualization) GetID() string <span class="cov0" title="0">{
        return "speedometer"
}</span>

// GetName returns the display name
func (s *SpeedometerVisualization) GetName() string <span class="cov0" title="0">{
        return "Bandwidth Speedometer"
}</span>

// GetDescription returns a description
func (s *SpeedometerVisualization) GetDescription() string <span class="cov0" title="0">{
        return "Gauge-style bandwidth utilization display"
}</span>

// CreateView creates the view
func (s *SpeedometerVisualization) CreateView() tview.Primitive <span class="cov0" title="0">{
        return s.textView
}</span>

// Update updates the visualization
func (s *SpeedometerVisualization) Update(monitor *netcap.NetworkMonitor) <span class="cov0" title="0">{
        s.monitor = monitor
        
        // Get current bandwidth usage
        stats := monitor.GetInterfaceStats()
        var totalIn, totalOut uint64
        
        for _, stat := range stats </span><span class="cov0" title="0">{
                totalIn += stat.BytesIn
                totalOut += stat.BytesOut
        }</span>
        
        // Calculate current speeds (this is simplified - real implementation would track deltas)
        <span class="cov0" title="0">s.inSpeed = float64(totalIn) / 10   // Simulated rate
        s.outSpeed = float64(totalOut) / 10 // Simulated rate
        s.currentSpeed = s.inSpeed + s.outSpeed
        
        // Update history
        s.history = append(s.history, s.currentSpeed)
        if len(s.history) &gt; s.maxHistory </span><span class="cov0" title="0">{
                s.history = s.history[1:]
        }</span>
        
        // Auto-adjust max if needed
        <span class="cov0" title="0">if s.currentSpeed &gt; s.maxBandwidth*0.9 </span><span class="cov0" title="0">{
                s.maxBandwidth = s.currentSpeed * 1.5
        }</span>
        
        // Draw the speedometer
        <span class="cov0" title="0">var output strings.Builder
        
        // Draw the gauge
        s.drawGauge(&amp;output)
        
        // Current speed display
        output.WriteString("\n\n")
        speedMbps := s.currentSpeed * 8 / 1024 / 1024
        output.WriteString(fmt.Sprintf("         [yellow]◉ %.1f Mbps[white]\n", speedMbps))
        
        // In/Out breakdown
        output.WriteString("\n")
        output.WriteString(fmt.Sprintf("    ↓ In:  [green]%s/s[white]\n", utils.FormatBytes(uint64(s.inSpeed))))
        output.WriteString(fmt.Sprintf("    ↑ Out: [blue]%s/s[white]\n", utils.FormatBytes(uint64(s.outSpeed))))
        
        // Utilization percentage
        utilization := (s.currentSpeed / s.maxBandwidth) * 100
        output.WriteString(fmt.Sprintf("\n    Utilization: %.1f%%\n", utilization))
        
        // Mini sparkline history
        output.WriteString("\n    History: ")
        s.drawMiniSparkline(&amp;output)
        
        s.textView.SetText(output.String())</span>
}

// drawGauge draws the speedometer gauge
func (s *SpeedometerVisualization) drawGauge(output *strings.Builder) <span class="cov0" title="0">{
        // Gauge parameters
        width := 41
        height := 12
        centerX := width / 2
        centerY := height - 2
        radius := 15
        
        // Create grid
        grid := make([][]rune, height)
        for i := range grid </span><span class="cov0" title="0">{
                grid[i] = make([]rune, width)
                for j := range grid[i] </span><span class="cov0" title="0">{
                        grid[i][j] = ' '
                }</span>
        }
        
        // Draw gauge arc
        <span class="cov0" title="0">startAngle := math.Pi       // 180 degrees (left)
        endAngle := 0.0            // 0 degrees (right)
        steps := 40
        
        for i := 0; i &lt;= steps; i++ </span><span class="cov0" title="0">{
                angle := startAngle + (endAngle-startAngle)*float64(i)/float64(steps)
                x := centerX + int(float64(radius)*math.Cos(angle))
                y := centerY - int(float64(radius)*math.Sin(angle)/2) // Compensate for aspect ratio
                
                if x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height </span><span class="cov0" title="0">{
                        grid[y][x] = '─'
                }</span>
        }
        
        // Draw scale markers
        <span class="cov0" title="0">scalePositions := []float64{0, 0.25, 0.5, 0.75, 1.0}
        scaleLabels := []string{"0%", "25%", "50%", "75%", "100%"}
        
        for i, pos := range scalePositions </span><span class="cov0" title="0">{
                angle := startAngle + (endAngle-startAngle)*pos
                x := centerX + int(float64(radius-2)*math.Cos(angle))
                y := centerY - int(float64(radius-2)*math.Sin(angle)/2)
                
                if x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height </span><span class="cov0" title="0">{
                        grid[y][x] = '│'
                }</span>
                
                // Label position
                <span class="cov0" title="0">labelX := centerX + int(float64(radius+3)*math.Cos(angle))
                labelY := centerY - int(float64(radius+3)*math.Sin(angle)/2)
                
                if labelX &gt;= 0 &amp;&amp; labelX+len(scaleLabels[i]) &lt; width &amp;&amp; labelY &gt;= 0 &amp;&amp; labelY &lt; height </span><span class="cov0" title="0">{
                        for j, ch := range scaleLabels[i] </span><span class="cov0" title="0">{
                                if labelX+j &lt; width </span><span class="cov0" title="0">{
                                        grid[labelY][labelX+j] = ch
                                }</span>
                        }
                }
        }
        
        // Draw filled gauge based on current speed
        <span class="cov0" title="0">fillRatio := s.currentSpeed / s.maxBandwidth
        if fillRatio &gt; 1.0 </span><span class="cov0" title="0">{
                fillRatio = 1.0
        }</span>
        
        <span class="cov0" title="0">fillSteps := int(float64(steps) * fillRatio)
        for i := 0; i &lt;= fillSteps; i++ </span><span class="cov0" title="0">{
                angle := startAngle + (endAngle-startAngle)*float64(i)/float64(steps)
                
                for r := radius - 5; r &lt; radius; r++ </span><span class="cov0" title="0">{
                        x := centerX + int(float64(r)*math.Cos(angle))
                        y := centerY - int(float64(r)*math.Sin(angle)/2)
                        
                        if x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height </span><span class="cov0" title="0">{
                                // Color based on speed
                                if fillRatio &lt; 0.5 </span><span class="cov0" title="0">{
                                        grid[y][x] = '░'
                                }</span> else<span class="cov0" title="0"> if fillRatio &lt; 0.75 </span><span class="cov0" title="0">{
                                        grid[y][x] = '▒'
                                }</span> else<span class="cov0" title="0"> if fillRatio &lt; 0.9 </span><span class="cov0" title="0">{
                                        grid[y][x] = '▓'
                                }</span> else<span class="cov0" title="0"> {
                                        grid[y][x] = '█'
                                }</span>
                        }
                }
        }
        
        // Draw needle
        <span class="cov0" title="0">needleAngle := startAngle + (endAngle-startAngle)*fillRatio
        for r := 3; r &lt; radius-5; r++ </span><span class="cov0" title="0">{
                x := centerX + int(float64(r)*math.Cos(needleAngle))
                y := centerY - int(float64(r)*math.Sin(needleAngle)/2)
                
                if x &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; height </span><span class="cov0" title="0">{
                        grid[y][x] = '▬'
                }</span>
        }
        
        // Center point
        <span class="cov0" title="0">if centerY &gt;= 0 &amp;&amp; centerY &lt; height &amp;&amp; centerX &gt;= 0 &amp;&amp; centerX &lt; width </span><span class="cov0" title="0">{
                grid[centerY][centerX] = '◉'
        }</span>
        
        // Convert grid to string with colors
        <span class="cov0" title="0">for _, row := range grid </span><span class="cov0" title="0">{
                for _, ch := range row </span><span class="cov0" title="0">{
                        if ch == '█' || ch == '▓' </span><span class="cov0" title="0">{
                                if fillRatio &gt; 0.9 </span><span class="cov0" title="0">{
                                        output.WriteString("[red]")
                                }</span> else<span class="cov0" title="0"> if fillRatio &gt; 0.75 </span><span class="cov0" title="0">{
                                        output.WriteString("[yellow]")
                                }</span> else<span class="cov0" title="0"> {
                                        output.WriteString("[green]")
                                }</span>
                                <span class="cov0" title="0">output.WriteRune(ch)
                                output.WriteString("[white]")</span>
                        } else<span class="cov0" title="0"> if ch == '▒' || ch == '░' </span><span class="cov0" title="0">{
                                output.WriteString("[green]")
                                output.WriteRune(ch)
                                output.WriteString("[white]")
                        }</span> else<span class="cov0" title="0"> if ch == '▬' </span><span class="cov0" title="0">{
                                output.WriteString("[yellow]")
                                output.WriteRune(ch)
                                output.WriteString("[white]")
                        }</span> else<span class="cov0" title="0"> {
                                output.WriteRune(ch)
                        }</span>
                }
                <span class="cov0" title="0">output.WriteString("\n")</span>
        }
}

// drawMiniSparkline draws a small sparkline of speed history
func (s *SpeedometerVisualization) drawMiniSparkline(output *strings.Builder) <span class="cov0" title="0">{
        if len(s.history) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">chars := []rune{'▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'}
        
        maxVal := 0.0
        for _, v := range s.history </span><span class="cov0" title="0">{
                if v &gt; maxVal </span><span class="cov0" title="0">{
                        maxVal = v
                }</span>
        }
        
        <span class="cov0" title="0">if maxVal == 0 </span><span class="cov0" title="0">{
                maxVal = 1
        }</span>
        
        <span class="cov0" title="0">for _, val := range s.history </span><span class="cov0" title="0">{
                index := int((val / maxVal) * float64(len(chars)-1))
                if index &gt;= len(chars) </span><span class="cov0" title="0">{
                        index = len(chars) - 1
                }</span>
                <span class="cov0" title="0">output.WriteRune(chars[index])</span>
        }
}

// GetMinSize returns minimum size requirements
func (s *SpeedometerVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 45, 20
}</pre>
		
		<pre class="file" id="file35" style="display: none">package ui

import (
        "fmt"
        "math"
        "strings"
        "time"

        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
)

// SunburstVisualization shows connection states in a hierarchical sunburst
type SunburstVisualization struct {
        BaseVisualization
}

// NewSunburstVisualization creates a new sunburst visualization
func NewSunburstVisualization() Visualization <span class="cov0" title="0">{
        s := &amp;SunburstVisualization{}
        s.textView = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        s.textView.SetBorder(true).
                SetTitle("Connection State Sunburst")
        return s
}</span>

// GetID returns the unique identifier
func (s *SunburstVisualization) GetID() string <span class="cov0" title="0">{
        return "sunburst"
}</span>

// GetName returns the display name
func (s *SunburstVisualization) GetName() string <span class="cov0" title="0">{
        return "Connection Sunburst"
}</span>

// GetDescription returns a description
func (s *SunburstVisualization) GetDescription() string <span class="cov0" title="0">{
        return "Hierarchical view of connections by state/protocol/service"
}</span>

// CreateView creates the view
func (s *SunburstVisualization) CreateView() tview.Primitive <span class="cov0" title="0">{
        return s.textView
}</span>

// Update updates the visualization
func (s *SunburstVisualization) Update(monitor *netcap.NetworkMonitor) <span class="cov0" title="0">{
        s.monitor = monitor
        
        // Get connections and organize hierarchically
        var connections []*netcap.Connection
        for interfaceName := range monitor.Interfaces </span><span class="cov0" title="0">{
                connections = append(connections, monitor.GetConnections(interfaceName)...)
        }</span>
        
        // Build hierarchy: State -&gt; Protocol -&gt; Service
        <span class="cov0" title="0">hierarchy := make(map[string]map[string]map[string]int)
        
        for _, conn := range connections </span><span class="cov0" title="0">{
                state := s.getConnectionState(conn)
                protocol := conn.Protocol
                service := getServiceName(conn)
                
                if hierarchy[state] == nil </span><span class="cov0" title="0">{
                        hierarchy[state] = make(map[string]map[string]int)
                }</span>
                <span class="cov0" title="0">if hierarchy[state][protocol] == nil </span><span class="cov0" title="0">{
                        hierarchy[state][protocol] = make(map[string]int)
                }</span>
                <span class="cov0" title="0">hierarchy[state][protocol][service]++</span>
        }
        
        // Draw the sunburst
        <span class="cov0" title="0">width, height := 60, 30
        centerX, centerY := width/2, height/2
        
        grid := make([][]rune, height)
        for i := range grid </span><span class="cov0" title="0">{
                grid[i] = make([]rune, width)
                for j := range grid[i] </span><span class="cov0" title="0">{
                        grid[i][j] = ' '
                }</span>
        }
        
        // Draw concentric rings
        <span class="cov0" title="0">s.drawSunburst(grid, hierarchy, centerX, centerY)
        
        // Convert grid to string
        var output strings.Builder
        for _, row := range grid </span><span class="cov0" title="0">{
                output.WriteString(string(row) + "\n")
        }</span>
        
        // Add legend
        <span class="cov0" title="0">output.WriteString("\n[white]Connection States:\n")
        
        totalConns := len(connections)
        for state, protocols := range hierarchy </span><span class="cov0" title="0">{
                stateCount := 0
                for _, services := range protocols </span><span class="cov0" title="0">{
                        for _, count := range services </span><span class="cov0" title="0">{
                                stateCount += count
                        }</span>
                }
                
                <span class="cov0" title="0">percentage := float64(stateCount) / float64(totalConns) * 100
                bar := strings.Repeat("█", int(percentage/5))
                color := s.getStateColor(state)
                
                output.WriteString(fmt.Sprintf("%s%-12s %s %5.1f%% (%d)[white]\n",
                        color, state, bar, percentage, stateCount))
                
                // Top protocols for this state
                for protocol, services := range protocols </span><span class="cov0" title="0">{
                        protocolCount := 0
                        for _, count := range services </span><span class="cov0" title="0">{
                                protocolCount += count
                        }</span>
                        <span class="cov0" title="0">if protocolCount &gt; 0 </span><span class="cov0" title="0">{
                                output.WriteString(fmt.Sprintf("  └─ %s: %d\n", protocol, protocolCount))
                        }</span>
                }
        }
        
        <span class="cov0" title="0">s.textView.SetText(output.String())</span>
}

// drawSunburst draws the sunburst diagram
func (s *SunburstVisualization) drawSunburst(grid [][]rune, hierarchy map[string]map[string]map[string]int, centerX, centerY int) <span class="cov0" title="0">{
        // Center
        s.drawText(grid, centerX-1, centerY, "CONN")
        
        // Calculate total for angles
        total := 0
        for _, protocols := range hierarchy </span><span class="cov0" title="0">{
                for _, services := range protocols </span><span class="cov0" title="0">{
                        for _, count := range services </span><span class="cov0" title="0">{
                                total += count
                        }</span>
                }
        }
        
        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Draw rings
        <span class="cov0" title="0">innerRadius := 5
        middleRadius := 10
        outerRadius := 14
        
        startAngle := 0.0
        
        // State ring (inner)
        for state, protocols := range hierarchy </span><span class="cov0" title="0">{
                stateCount := 0
                for _, services := range protocols </span><span class="cov0" title="0">{
                        for _, count := range services </span><span class="cov0" title="0">{
                                stateCount += count
                        }</span>
                }
                
                <span class="cov0" title="0">angle := float64(stateCount) / float64(total) * 2 * math.Pi
                s.drawArc(grid, centerX, centerY, innerRadius, middleRadius-1, startAngle, startAngle+angle, s.getStateChar(state))
                
                // Protocol ring (middle)
                protocolStart := startAngle
                for protocol, services := range protocols </span><span class="cov0" title="0">{
                        protocolCount := 0
                        for _, count := range services </span><span class="cov0" title="0">{
                                protocolCount += count
                        }</span>
                        
                        <span class="cov0" title="0">protocolAngle := float64(protocolCount) / float64(total) * 2 * math.Pi
                        s.drawArc(grid, centerX, centerY, middleRadius, outerRadius-1, protocolStart, protocolStart+protocolAngle, s.getProtocolChar(protocol))
                        
                        protocolStart += protocolAngle</span>
                }
                
                <span class="cov0" title="0">startAngle += angle</span>
        }
        
        // Draw separators
        <span class="cov0" title="0">s.drawRadialLines(grid, centerX, centerY, innerRadius, outerRadius)</span>
}

// drawArc draws an arc segment
func (s *SunburstVisualization) drawArc(grid [][]rune, cx, cy, innerR, outerR int, startAngle, endAngle float64, char rune) <span class="cov0" title="0">{
        steps := 100
        for i := 0; i &lt;= steps; i++ </span><span class="cov0" title="0">{
                angle := startAngle + (endAngle-startAngle)*float64(i)/float64(steps)
                
                for r := innerR; r &lt;= outerR; r++ </span><span class="cov0" title="0">{
                        x := cx + int(float64(r)*math.Cos(angle))
                        y := cy + int(float64(r)*math.Sin(angle)/2) // Aspect ratio
                        
                        if x &gt;= 0 &amp;&amp; x &lt; len(grid[0]) &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; len(grid) </span><span class="cov0" title="0">{
                                grid[y][x] = char
                        }</span>
                }
        }
}

// drawRadialLines draws lines from center
func (s *SunburstVisualization) drawRadialLines(grid [][]rune, cx, cy, innerR, outerR int) <span class="cov0" title="0">{
        angles := []float64{0, math.Pi/2, math.Pi, 3*math.Pi/2}
        
        for _, angle := range angles </span><span class="cov0" title="0">{
                for r := innerR; r &lt;= outerR; r++ </span><span class="cov0" title="0">{
                        x := cx + int(float64(r)*math.Cos(angle))
                        y := cy + int(float64(r)*math.Sin(angle)/2)
                        
                        if x &gt;= 0 &amp;&amp; x &lt; len(grid[0]) &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; len(grid) </span><span class="cov0" title="0">{
                                if math.Abs(math.Sin(angle)) &gt; 0.5 </span><span class="cov0" title="0">{
                                        grid[y][x] = '│'
                                }</span> else<span class="cov0" title="0"> {
                                        grid[y][x] = '─'
                                }</span>
                        }
                }
        }
}

// drawText draws text at position
func (s *SunburstVisualization) drawText(grid [][]rune, x, y int, text string) <span class="cov0" title="0">{
        for i, ch := range text </span><span class="cov0" title="0">{
                if x+i &gt;= 0 &amp;&amp; x+i &lt; len(grid[0]) &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; len(grid) </span><span class="cov0" title="0">{
                        grid[y][x+i] = ch
                }</span>
        }
}

// getConnectionState determines connection state
func (s *SunburstVisualization) getConnectionState(conn *netcap.Connection) string <span class="cov0" title="0">{
        // Simplified state detection based on recent activity
        if time.Since(conn.LastSeen) &lt; 30*time.Second &amp;&amp; conn.Packets &gt; 0 </span><span class="cov0" title="0">{
                return "ESTABLISHED"
        }</span>
        <span class="cov0" title="0">return "CLOSED"</span>
}

// getStateChar returns a character for a state
func (s *SunburstVisualization) getStateChar(state string) rune <span class="cov0" title="0">{
        switch state </span>{
        case "ESTABLISHED":<span class="cov0" title="0">
                return '█'</span>
        case "SYN_SENT", "SYN_RECV":<span class="cov0" title="0">
                return '▓'</span>
        case "CLOSED", "TIME_WAIT":<span class="cov0" title="0">
                return '▒'</span>
        default:<span class="cov0" title="0">
                return '░'</span>
        }
}

// getProtocolChar returns a character for a protocol
func (s *SunburstVisualization) getProtocolChar(protocol string) rune <span class="cov0" title="0">{
        switch protocol </span>{
        case "TCP":<span class="cov0" title="0">
                return '▓'</span>
        case "UDP":<span class="cov0" title="0">
                return '▒'</span>
        default:<span class="cov0" title="0">
                return '░'</span>
        }
}

// getStateColor returns color for a state
func (s *SunburstVisualization) getStateColor(state string) string <span class="cov0" title="0">{
        switch state </span>{
        case "ESTABLISHED":<span class="cov0" title="0">
                return "[green]"</span>
        case "SYN_SENT", "SYN_RECV":<span class="cov0" title="0">
                return "[yellow]"</span>
        case "CLOSED", "TIME_WAIT":<span class="cov0" title="0">
                return "[red]"</span>
        default:<span class="cov0" title="0">
                return "[white]"</span>
        }
}

// GetMinSize returns minimum size requirements
func (s *SunburstVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 60, 35
}</pre>
		
		<pre class="file" id="file36" style="display: none">package ui

import (
        "fmt"
        "strings"
        "time"

        "github.com/rivo/tview"
        "github.com/user/netmon/pkg/netcap"
        "github.com/shirou/gopsutil/v3/cpu"
)

// WeatherMapVisualization shows network conditions as weather
type WeatherMapVisualization struct {
        BaseVisualization
        lastCPU      float64
        lastBandwidth float64
}

// NewWeatherMapVisualization creates a new weather map visualization
func NewWeatherMapVisualization() Visualization <span class="cov0" title="0">{
        w := &amp;WeatherMapVisualization{}
        w.textView = tview.NewTextView().
                SetDynamicColors(true).
                SetWrap(false)
        w.textView.SetBorder(true).
                SetTitle("Network Weather Map")
        return w
}</span>

// GetID returns the unique identifier
func (w *WeatherMapVisualization) GetID() string <span class="cov0" title="0">{
        return "weather"
}</span>

// GetName returns the display name
func (w *WeatherMapVisualization) GetName() string <span class="cov0" title="0">{
        return "Network Weather"
}</span>

// GetDescription returns a description
func (w *WeatherMapVisualization) GetDescription() string <span class="cov0" title="0">{
        return "Network conditions visualization as weather"
}</span>

// CreateView creates the view
func (w *WeatherMapVisualization) CreateView() tview.Primitive <span class="cov0" title="0">{
        return w.textView
}</span>

// Update updates the visualization
func (w *WeatherMapVisualization) Update(monitor *netcap.NetworkMonitor) <span class="cov0" title="0">{
        w.monitor = monitor
        
        // Get network stats
        var connections []*netcap.Connection
        for interfaceName := range monitor.Interfaces </span><span class="cov0" title="0">{
                connections = append(connections, monitor.GetConnections(interfaceName)...)
        }</span>
        <span class="cov0" title="0">activeConns := 0
        totalBandwidth := uint64(0)
        protocols := make(map[string]int)
        
        for _, conn := range connections </span><span class="cov0" title="0">{
                if time.Since(conn.LastSeen) &lt; 30*time.Second &amp;&amp; conn.Packets &gt; 0 </span><span class="cov0" title="0">{
                        activeConns++
                        totalBandwidth += conn.Size
                        protocols[conn.Protocol]++
                }</span>
        }
        
        // Get CPU usage
        <span class="cov0" title="0">cpuPercent, _ := cpu.Percent(100*time.Millisecond, false)
        cpuUsage := 0.0
        if len(cpuPercent) &gt; 0 </span><span class="cov0" title="0">{
                cpuUsage = cpuPercent[0]
        }</span>
        
        // Calculate weather conditions
        <span class="cov0" title="0">weather, emoji := w.calculateWeather(activeConns, totalBandwidth, cpuUsage)
        
        // Build visualization
        var output strings.Builder
        
        // Weather header
        output.WriteString(fmt.Sprintf("┌─────────────────────────────────┐\n"))
        output.WriteString(fmt.Sprintf("│ Network Weather: %s  %-11s│\n", emoji, weather))
        output.WriteString(fmt.Sprintf("├─────────────────────────────────┤\n"))
        
        // Traffic visualization
        output.WriteString("│ ")
        trafficLevel := w.getTrafficLevel(totalBandwidth)
        for i := 0; i &lt; 31; i++ </span><span class="cov0" title="0">{
                if i &lt; trafficLevel </span><span class="cov0" title="0">{
                        if i &lt; 10 </span><span class="cov0" title="0">{
                                output.WriteString("[green]░[white]")
                        }</span> else<span class="cov0" title="0"> if i &lt; 20 </span><span class="cov0" title="0">{
                                output.WriteString("[yellow]▒[white]")
                        }</span> else<span class="cov0" title="0"> {
                                output.WriteString("[red]▓[white]")
                        }</span>
                } else<span class="cov0" title="0"> {
                        output.WriteString(" ")
                }</span>
        }
        <span class="cov0" title="0">output.WriteString(" │\n")
        
        // Conditions
        conditions := w.getConditions(activeConns, totalBandwidth, cpuUsage)
        for _, condition := range conditions </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("│ %s%-31s%s│\n", condition.icon, condition.text, strings.Repeat(" ", 31-len(condition.text))))
        }</span>
        
        <span class="cov0" title="0">output.WriteString("│                                 │\n")
        
        // Metrics
        output.WriteString(fmt.Sprintf("│ 🌡️  CPU: %3.0f%% | Bandwidth: %3.0f%% │\n", 
                cpuUsage, float64(totalBandwidth)/1024/1024))
        
        output.WriteString("└─────────────────────────────────┘\n")
        
        // Forecast
        output.WriteString("\n[white]Network Forecast:\n")
        forecast := w.generateForecast(activeConns, totalBandwidth, cpuUsage)
        for _, line := range forecast </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("• %s\n", line))
        }</span>
        
        // Protocol breakdown
        <span class="cov0" title="0">output.WriteString("\n[white]Active Protocols:\n")
        for proto, count := range protocols </span><span class="cov0" title="0">{
                bar := strings.Repeat("█", count/2+1)
                output.WriteString(fmt.Sprintf("%-6s %s %d\n", proto, bar, count))
        }</span>
        
        <span class="cov0" title="0">w.textView.SetText(output.String())
        
        // Store for trend analysis
        w.lastCPU = cpuUsage
        w.lastBandwidth = float64(totalBandwidth)</span>
}

// calculateWeather determines weather conditions
func (w *WeatherMapVisualization) calculateWeather(conns int, bandwidth uint64, cpu float64) (string, string) <span class="cov0" title="0">{
        score := 0
        
        // Connection score
        if conns &lt; 50 </span><span class="cov0" title="0">{
                score += 3
        }</span> else<span class="cov0" title="0"> if conns &lt; 100 </span><span class="cov0" title="0">{
                score += 2
        }</span> else<span class="cov0" title="0"> if conns &lt; 200 </span><span class="cov0" title="0">{
                score += 1
        }</span>
        
        // Bandwidth score (MB/s)
        <span class="cov0" title="0">bwMBps := float64(bandwidth) / 1024 / 1024
        if bwMBps &lt; 10 </span><span class="cov0" title="0">{
                score += 3
        }</span> else<span class="cov0" title="0"> if bwMBps &lt; 50 </span><span class="cov0" title="0">{
                score += 2
        }</span> else<span class="cov0" title="0"> if bwMBps &lt; 100 </span><span class="cov0" title="0">{
                score += 1
        }</span>
        
        // CPU score
        <span class="cov0" title="0">if cpu &lt; 30 </span><span class="cov0" title="0">{
                score += 3
        }</span> else<span class="cov0" title="0"> if cpu &lt; 60 </span><span class="cov0" title="0">{
                score += 2
        }</span> else<span class="cov0" title="0"> if cpu &lt; 80 </span><span class="cov0" title="0">{
                score += 1
        }</span>
        
        // Determine weather
        <span class="cov0" title="0">switch </span>{
        case score &gt;= 8:<span class="cov0" title="0">
                return "SUNNY", "☀️"</span>
        case score &gt;= 6:<span class="cov0" title="0">
                return "PARTLY CLOUDY", "⛅"</span>
        case score &gt;= 4:<span class="cov0" title="0">
                return "CLOUDY", "☁️"</span>
        case score &gt;= 2:<span class="cov0" title="0">
                return "RAINY", "🌧️"</span>
        default:<span class="cov0" title="0">
                return "STORMY", "⛈️"</span>
        }
}

// getTrafficLevel returns traffic level (0-31)
func (w *WeatherMapVisualization) getTrafficLevel(bandwidth uint64) int <span class="cov0" title="0">{
        mbps := float64(bandwidth) / 1024 / 1024
        if mbps &gt; 100 </span><span class="cov0" title="0">{
                return 31
        }</span>
        <span class="cov0" title="0">return int(mbps * 31 / 100)</span>
}

type condition struct {
        icon string
        text string
}

// getConditions returns current network conditions
func (w *WeatherMapVisualization) getConditions(conns int, bandwidth uint64, cpu float64) []condition <span class="cov0" title="0">{
        conditions := []condition{}
        
        // Connection status
        if conns &gt; 200 </span><span class="cov0" title="0">{
                conditions = append(conditions, condition{"⚡", "High connection count"})
        }</span> else<span class="cov0" title="0"> if conns &gt; 100 </span><span class="cov0" title="0">{
                conditions = append(conditions, condition{"⚡", "Moderate connections"})
        }</span> else<span class="cov0" title="0"> {
                conditions = append(conditions, condition{"✓ ", "Normal connection count"})
        }</span>
        
        // Bandwidth status
        <span class="cov0" title="0">bwMBps := float64(bandwidth) / 1024 / 1024
        if bwMBps &gt; 80 </span><span class="cov0" title="0">{
                conditions = append(conditions, condition{"⚡", "Heavy network traffic"})
        }</span> else<span class="cov0" title="0"> if bwMBps &gt; 40 </span><span class="cov0" title="0">{
                conditions = append(conditions, condition{"⚡", "Moderate traffic"})
        }</span> else<span class="cov0" title="0"> {
                conditions = append(conditions, condition{"✓ ", "Light traffic"})
        }</span>
        
        // CPU status
        <span class="cov0" title="0">if cpu &gt; 80 </span><span class="cov0" title="0">{
                conditions = append(conditions, condition{"🔥", "High CPU usage detected"})
        }</span>
        
        // Trends
        <span class="cov0" title="0">if w.lastBandwidth &gt; 0 </span><span class="cov0" title="0">{
                change := (float64(bandwidth) - w.lastBandwidth) / w.lastBandwidth * 100
                if change &gt; 50 </span><span class="cov0" title="0">{
                        conditions = append(conditions, condition{"📈", "Traffic surge detected"})
                }</span> else<span class="cov0" title="0"> if change &lt; -50 </span><span class="cov0" title="0">{
                        conditions = append(conditions, condition{"📉", "Traffic drop detected"})
                }</span>
        }
        
        <span class="cov0" title="0">return conditions</span>
}

// generateForecast generates network forecast
func (w *WeatherMapVisualization) generateForecast(conns int, bandwidth uint64, cpu float64) []string <span class="cov0" title="0">{
        forecast := []string{}
        
        // Time-based predictions
        hour := time.Now().Hour()
        if hour &gt;= 9 &amp;&amp; hour &lt;= 17 </span><span class="cov0" title="0">{
                forecast = append(forecast, "Business hours: Expect continued activity")
        }</span> else<span class="cov0" title="0"> if hour &gt;= 18 &amp;&amp; hour &lt;= 23 </span><span class="cov0" title="0">{
                forecast = append(forecast, "Evening hours: Streaming traffic likely")
        }</span> else<span class="cov0" title="0"> {
                forecast = append(forecast, "Off-peak hours: Lower traffic expected")
        }</span>
        
        // Trend-based predictions
        <span class="cov0" title="0">if conns &gt; 150 </span><span class="cov0" title="0">{
                forecast = append(forecast, "High connection count may impact latency")
        }</span>
        
        <span class="cov0" title="0">if cpu &gt; 70 </span><span class="cov0" title="0">{
                forecast = append(forecast, "CPU usage elevated - monitor for bottlenecks")
        }</span>
        
        <span class="cov0" title="0">bwMBps := float64(bandwidth) / 1024 / 1024
        if bwMBps &gt; 50 </span><span class="cov0" title="0">{
                forecast = append(forecast, "Consider bandwidth optimization")
        }</span>
        
        <span class="cov0" title="0">return forecast</span>
}

// GetMinSize returns minimum size requirements
func (w *WeatherMapVisualization) GetMinSize() (width, height int) <span class="cov0" title="0">{
        return 40, 25
}</pre>
		
		<pre class="file" id="file37" style="display: none">package ui

import (
        "fmt"
        "strings"
)

// WorldMap represents an ASCII world map for visualization
type WorldMap struct {
        width  int
        height int
        data   [][]rune
}

// CountryCoordinates maps country codes to approximate map coordinates
var CountryCoordinates = map[string]struct{ X, Y int }{
        // North America
        "US": {20, 8},
        "CA": {20, 5},
        "MX": {18, 12},
        
        // South America
        "BR": {35, 18},
        "AR": {32, 23},
        "CL": {30, 22},
        "PE": {28, 17},
        "CO": {27, 15},
        "VE": {30, 13},
        
        // Europe
        "GB": {47, 7},
        "FR": {48, 8},
        "DE": {50, 7},
        "IT": {50, 9},
        "ES": {46, 9},
        "PT": {45, 9},
        "NL": {49, 7},
        "BE": {49, 7},
        "CH": {49, 8},
        "AT": {51, 8},
        "PL": {52, 7},
        "CZ": {51, 7},
        "SE": {52, 5},
        "NO": {50, 4},
        "FI": {54, 4},
        "DK": {50, 6},
        "RU": {60, 6},
        "UA": {55, 8},
        "GR": {53, 10},
        "TR": {56, 9},
        
        // Asia
        "CN": {70, 9},
        "JP": {78, 8},
        "KR": {76, 8},
        "IN": {65, 12},
        "ID": {72, 17},
        "TH": {69, 14},
        "VN": {71, 13},
        "MY": {70, 16},
        "SG": {70, 17},
        "PH": {75, 14},
        "PK": {63, 11},
        "BD": {67, 12},
        "TW": {75, 11},
        "HK": {73, 11},
        
        // Middle East
        "SA": {58, 11},
        "AE": {60, 11},
        "IL": {56, 10},
        "IR": {60, 10},
        "IQ": {58, 10},
        
        // Africa
        "ZA": {53, 24},
        "EG": {55, 11},
        "NG": {49, 15},
        "KE": {57, 17},
        "ET": {57, 14},
        "MA": {46, 11},
        "GH": {47, 15},
        
        // Oceania
        "AU": {76, 22},
        "NZ": {80, 25},
}

// NewWorldMap creates a new ASCII world map
func NewWorldMap() *WorldMap <span class="cov0" title="0">{
        return &amp;WorldMap{
                width:  84,
                height: 28,
                data:   initializeMap(),
        }
}</span>

// initializeMap creates the base ASCII world map
func initializeMap() [][]rune <span class="cov0" title="0">{
        // Simple ASCII world map representation
        mapStr := `
    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    . . . ┌─────────┐ . . . . . . . . . . . . . . ┌─────────────────────┐ . . . . . . .
    . . . │ . . . . │ . . . . . . . ┌───────────┐ │ . . . . . . . . . . │ . . . . . . .
    . . . │ . . . . └─┐ . . . ┌─────┘ . . . . . └─┘ . . . . . . . . . . └───┐ . . . . .
    . . . │ . . . . . └───────┘ . . . . . . . . . . . . . . . . . . . . . . │ . . . . .
    . . . │ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . │ . . . . .
    . . . │ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . │ . . . . .
    . . . └─┐ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . │ . . . . .
    . . . . └─┐ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ┌┘ . . . . .
    . . . . . └┐ . . . . . . . . . . . . . . . . . . . . . . . . . . . . ┌┘ . . . . . .
    . . . . . . └┐ . . . . . . . . . . . . . . . . . . . . . . . . . . ┌┘ . . . . . . .
    . . . . . . . └─┐ . . . . . . . . . . . . . . . . . . . . . . . . ┌┘ . . . . . . . .
    . . . . . . . . │ . . . . . . . . . . . . . . . . . . . . . . . . │ . . . . . . . . .
    . . . . . . . . └┐ . . . . . . . . . . . . . . . . . . . . . . . └┐ . . . . . . . . .
    . . . . . . . . . └┐ . . . . . . . . . . . . . . . . . . . . . . . └┐ . . . . . . . .
    . . . . . . . . . . └──┐ . . . . . . . . . . . . . . . . . . . . . . └┐ . . . . . . .
    . . . . . . . . . . . . └─┐ . . . . . . . . . . . . . . . . . . . . . │ . . . . . . .
    . . . . . . . . . . . . . └──────┐ . . . . . . . . . . . . . . . . . . └──┐ . . . . .
    . . . . . . . . . . . . . . . . . └─┐ . . . . . . . . . . . . . . . . . . └──┐ . . .
    . . . . . . . . . . . . . . . . . . └──┐ . . . . . . . . . . . . . . . . . . │ . . .
    . . . . . . . . . . . . . . . . . . . . └─┐ . . . . . . . . . . . . . . . . . │ . . .
    . . . . . . . . . . . . . . . . . . . . . └──┐ . . . . . . . . . . . . . ┌───┘ . . .
    . . . . . . . . . . . . . . . . . . . . . . . └─┐ . . . . . . . . . . ┌──┘ . . . . .
    . . . . . . . . . . . . . . . . . . . . . . . . └───┐ . . . . . . . ┌─┘ . . . . . . .
    . . . . . . . . . . . . . . . . . . . . . . . . . . └───────────────┘ . . . . . . . .
    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    `
        
        lines := strings.Split(strings.TrimSpace(mapStr), "\n")
        data := make([][]rune, len(lines))
        for i, line := range lines </span><span class="cov0" title="0">{
                data[i] = []rune(line)
        }</span>
        <span class="cov0" title="0">return data</span>
}

// MarkCountry marks a country on the map with a special character
func (m *WorldMap) MarkCountry(countryCode string, marker rune) <span class="cov0" title="0">{
        if coord, ok := CountryCoordinates[countryCode]; ok </span><span class="cov0" title="0">{
                if coord.Y &lt; len(m.data) &amp;&amp; coord.X &lt; len(m.data[coord.Y]) </span><span class="cov0" title="0">{
                        m.data[coord.Y][coord.X] = marker
                }</span>
        }
}

// Clear resets the map to its original state
func (m *WorldMap) Clear() <span class="cov0" title="0">{
        m.data = initializeMap()
}</span>

// Render returns the map as a string
func (m *WorldMap) Render() string <span class="cov0" title="0">{
        var result strings.Builder
        for _, row := range m.data </span><span class="cov0" title="0">{
                result.WriteString(string(row))
                result.WriteRune('\n')
        }</span>
        <span class="cov0" title="0">return result.String()</span>
}

// RenderWithColors returns the map with color codes for different connection counts
func (m *WorldMap) RenderWithColors(countryCounts map[string]int, maxCount int) string <span class="cov0" title="0">{
        var result strings.Builder
        
        // Define color thresholds
        getColor := func(count int) string </span><span class="cov0" title="0">{
                if count == 0 </span><span class="cov0" title="0">{
                        return "[white]"
                }</span>
                <span class="cov0" title="0">percentage := float64(count) / float64(maxCount) * 100
                switch </span>{
                case percentage &gt;= 75:<span class="cov0" title="0">
                        return "[red]"</span>
                case percentage &gt;= 50:<span class="cov0" title="0">
                        return "[orange]"</span>
                case percentage &gt;= 25:<span class="cov0" title="0">
                        return "[yellow]"</span>
                default:<span class="cov0" title="0">
                        return "[green]"</span>
                }
        }
        
        // Mark countries with appropriate symbols
        <span class="cov0" title="0">for country, count := range countryCounts </span><span class="cov0" title="0">{
                var marker rune
                switch </span>{
                case count &gt;= 100:<span class="cov0" title="0">
                        marker = '█'</span>
                case count &gt;= 50:<span class="cov0" title="0">
                        marker = '▓'</span>
                case count &gt;= 10:<span class="cov0" title="0">
                        marker = '▒'</span>
                case count &gt; 0:<span class="cov0" title="0">
                        marker = '░'</span>
                default:<span class="cov0" title="0">
                        marker = '·'</span>
                }
                <span class="cov0" title="0">m.MarkCountry(country, marker)</span>
        }
        
        // Render with colors
        <span class="cov0" title="0">for y, row := range m.data </span><span class="cov0" title="0">{
                for x, char := range row </span><span class="cov0" title="0">{
                        // Check if this position corresponds to a country
                        isCountry := false
                        for country, coord := range CountryCoordinates </span><span class="cov0" title="0">{
                                if coord.X == x &amp;&amp; coord.Y == y </span><span class="cov0" title="0">{
                                        if count, ok := countryCounts[country]; ok &amp;&amp; count &gt; 0 </span><span class="cov0" title="0">{
                                                result.WriteString(getColor(count))
                                                result.WriteRune(char)
                                                result.WriteString("[white]")
                                                isCountry = true
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if !isCountry </span><span class="cov0" title="0">{
                                result.WriteRune(char)
                        }</span>
                }
                <span class="cov0" title="0">result.WriteRune('\n')</span>
        }
        
        <span class="cov0" title="0">return result.String()</span>
}

// GetLegend returns a legend for the map visualization
func GetMapLegend() string <span class="cov0" title="0">{
        return fmt.Sprintf(`[yellow]═══ Connection Density ═══[white]
  █ Very High (100+ connections)
  ▓ High      (50-99 connections)  
  ▒ Medium    (10-49 connections)
  ░ Low       (1-9 connections)
  · No connections
  
[yellow]═══ Color Scale ═══[white]
  [red]■[white] 75-100%% of max connections
  [orange]■[white] 50-74%% of max connections
  [yellow]■[white] 25-49%% of max connections
  [green]■[white] 1-24%% of max connections`)
}</pre>
		
		<pre class="file" id="file38" style="display: none">package utils

import (
        "fmt"
        "time"
)

// FormatBytes formats bytes into a human-readable string
func FormatBytes(bytes uint64) string <span class="cov10" title="8">{
        const (
                _          = iota
                KB float64 = 1 &lt;&lt; (10 * iota)
                MB
                GB
                TB
        )

        switch </span>{
        case bytes &gt;= uint64(TB):<span class="cov1" title="1">
                return fmt.Sprintf("%.2f TB", float64(bytes)/TB)</span>
        case bytes &gt;= uint64(GB):<span class="cov1" title="1">
                return fmt.Sprintf("%.2f GB", float64(bytes)/GB)</span>
        case bytes &gt;= uint64(MB):<span class="cov4" title="2">
                return fmt.Sprintf("%.2f MB", float64(bytes)/MB)</span>
        case bytes &gt;= uint64(KB):<span class="cov4" title="2">
                return fmt.Sprintf("%.2f KB", float64(bytes)/KB)</span>
        default:<span class="cov4" title="2">
                return fmt.Sprintf("%d B", bytes)</span>
        }
}

// FormatTime formats a time.Time into a readable string
func FormatTime(t time.Time) string <span class="cov7" title="4">{
        now := time.Now()
        diff := now.Sub(t)

        switch </span>{
        case diff &lt; time.Minute:<span class="cov1" title="1">
                return "just now"</span>
        case diff &lt; time.Hour:<span class="cov1" title="1">
                minutes := int(diff.Minutes())
                return fmt.Sprintf("%d min ago", minutes)</span>
        case diff &lt; 24*time.Hour:<span class="cov1" title="1">
                hours := int(diff.Hours())
                return fmt.Sprintf("%d hours ago", hours)</span>
        default:<span class="cov1" title="1">
                return t.Format("Jan 02 15:04")</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
